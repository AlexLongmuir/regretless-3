/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(() => {
var exports = {};
exports.id = "app/api/create/schedule-actions/route";
exports.ids = ["app/api/create/schedule-actions/route"];
exports.modules = {

/***/ "(rsc)/./app/api/create/schedule-actions/route.ts":
/*!**************************************************!*\
  !*** ./app/api/create/schedule-actions/route.ts ***!
  \**************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   POST: () => (/* binding */ POST)\n/* harmony export */ });\n/* harmony import */ var next_server__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! next/server */ \"(rsc)/./node_modules/next/dist/api/server.js\");\n/* harmony import */ var _lib_supabaseServer__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../../lib/supabaseServer */ \"(rsc)/./lib/supabaseServer.ts\");\n/* harmony import */ var _lib_scheduling_scheduler__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../../../lib/scheduling/scheduler */ \"(rsc)/./lib/scheduling/scheduler.ts\");\n\n\n\nasync function getUser(req) {\n    const token = req.headers.get('authorization')?.replace('Bearer ', '');\n    if (!token) return null;\n    const supabase = (0,_lib_supabaseServer__WEBPACK_IMPORTED_MODULE_1__.supabaseServer)();\n    const { data, error } = await supabase.auth.getUser(token);\n    return data.user ?? null;\n}\nasync function POST(req) {\n    try {\n        const token = req.headers.get('authorization')?.replace('Bearer ', '');\n        if (!token) {\n            return next_server__WEBPACK_IMPORTED_MODULE_0__.NextResponse.json({\n                error: 'Unauthorized'\n            }, {\n                status: 401\n            });\n        }\n        const { dream_id } = await req.json();\n        if (!dream_id) {\n            return next_server__WEBPACK_IMPORTED_MODULE_0__.NextResponse.json({\n                error: 'dream_id is required'\n            }, {\n                status: 400\n            });\n        }\n        // Get user from auth\n        const user = await getUser(req);\n        if (!user) {\n            return next_server__WEBPACK_IMPORTED_MODULE_0__.NextResponse.json({\n                error: 'Unauthorized'\n            }, {\n                status: 401\n            });\n        }\n        // Use authenticated client that respects RLS\n        const sb = (0,_lib_supabaseServer__WEBPACK_IMPORTED_MODULE_1__.supabaseServerAuth)(token);\n        // Fetch dream data - RLS will automatically filter by user_id\n        const { data: dream, error: dreamError } = await sb.from('dreams').select('*').eq('id', dream_id).single();\n        if (dreamError || !dream) {\n            return next_server__WEBPACK_IMPORTED_MODULE_0__.NextResponse.json({\n                error: 'Dream not found'\n            }, {\n                status: 404\n            });\n        }\n        // Fetch areas for this dream\n        console.log('Fetching areas for dream:', dream_id, 'user:', user.id);\n        const { data: areas, error: areasError } = await sb.from('areas').select('*').eq('dream_id', dream_id).is('deleted_at', null).order('position');\n        if (areasError) {\n            console.error('Areas fetch error:', areasError);\n            return next_server__WEBPACK_IMPORTED_MODULE_0__.NextResponse.json({\n                error: 'Failed to fetch areas',\n                details: areasError.message\n            }, {\n                status: 500\n            });\n        }\n        console.log('Found areas:', areas?.length || 0);\n        // Fetch actions for this dream\n        console.log('Fetching actions for areas:', areas.map((area)=>area.id));\n        // First, let's check what actions exist for these areas (without filters)\n        const { data: allActions, error: allActionsError } = await sb.from('actions').select('*').in('area_id', areas.map((area)=>area.id));\n        console.log('All actions found (no filters):', allActions?.length || 0);\n        if (allActions && allActions.length > 0) {\n            console.log('Sample action:', {\n                id: allActions[0].id,\n                area_id: allActions[0].area_id,\n                is_active: allActions[0].is_active,\n                deleted_at: allActions[0].deleted_at,\n                position: allActions[0].position\n            });\n        }\n        // Now try with filters\n        const { data: actions, error: actionsError } = await sb.from('actions').select('*').in('area_id', areas.map((area)=>area.id)).is('deleted_at', null).eq('is_active', true).order('position');\n        if (actionsError) {\n            console.error('Actions fetch error:', actionsError);\n            return next_server__WEBPACK_IMPORTED_MODULE_0__.NextResponse.json({\n                error: 'Failed to fetch actions',\n                details: actionsError.message\n            }, {\n                status: 500\n            });\n        }\n        console.log('Found actions:', actions?.length || 0);\n        // Fetch existing occurrences to avoid duplicates\n        const { data: existingOccurrences, error: occurrencesError } = await sb.from('action_occurrences').select('*').in('action_id', actions.map((action)=>action.id));\n        if (occurrencesError) {\n            return next_server__WEBPACK_IMPORTED_MODULE_0__.NextResponse.json({\n                error: 'Failed to fetch existing occurrences'\n            }, {\n                status: 500\n            });\n        }\n        // Prepare scheduling context\n        const context = {\n            user_id: user.id,\n            timezone: 'Europe/London' // Default timezone, could be made configurable\n        };\n        const dreamData = {\n            dream: dream,\n            areas: areas,\n            actions: actions,\n            existing_occurrences: existingOccurrences\n        };\n        // Run scheduling algorithm\n        console.log('Running scheduling algorithm...');\n        const schedulingResult = await (0,_lib_scheduling_scheduler__WEBPACK_IMPORTED_MODULE_2__.scheduleDreamActions)(context, dreamData);\n        console.log('Scheduling result:', {\n            success: schedulingResult.success,\n            occurrencesCount: schedulingResult.occurrences.length,\n            errors: schedulingResult.errors,\n            warnings: schedulingResult.warnings\n        });\n        if (!schedulingResult.success) {\n            return next_server__WEBPACK_IMPORTED_MODULE_0__.NextResponse.json({\n                error: 'Scheduling failed',\n                details: schedulingResult.errors\n            }, {\n                status: 500\n            });\n        }\n        // Insert new occurrences into database\n        if (schedulingResult.occurrences.length > 0) {\n            console.log('Inserting occurrences:', schedulingResult.occurrences.length);\n            console.log('Sample occurrence:', {\n                action_id: schedulingResult.occurrences[0].action_id,\n                occurrence_no: schedulingResult.occurrences[0].occurrence_no,\n                planned_due_on: schedulingResult.occurrences[0].planned_due_on,\n                due_on: schedulingResult.occurrences[0].due_on\n            });\n            // Deduplicate occurrences by (action_id, occurrence_no) to avoid conflicts\n            const uniqueOccurrences = schedulingResult.occurrences.reduce((acc, occ)=>{\n                const key = `${occ.action_id}-${occ.occurrence_no}`;\n                if (!acc.has(key)) {\n                    acc.set(key, occ);\n                }\n                return acc;\n            }, new Map());\n            const deduplicatedOccurrences = Array.from(uniqueOccurrences.values());\n            console.log('Deduplicated occurrences:', deduplicatedOccurrences.length);\n            const { error: insertError } = await sb.from('action_occurrences').upsert(deduplicatedOccurrences.map((occ)=>({\n                    action_id: occ.action_id,\n                    area_id: occ.area_id,\n                    dream_id: dream_id,\n                    occurrence_no: occ.occurrence_no,\n                    planned_due_on: occ.planned_due_on,\n                    due_on: occ.due_on,\n                    defer_count: occ.defer_count,\n                    user_id: user.id\n                })), {\n                onConflict: 'action_id,occurrence_no',\n                ignoreDuplicates: false\n            });\n            if (insertError) {\n                console.error('Insert error:', insertError);\n                return next_server__WEBPACK_IMPORTED_MODULE_0__.NextResponse.json({\n                    error: 'Failed to insert occurrences',\n                    details: insertError\n                }, {\n                    status: 500\n                });\n            }\n            console.log('Successfully inserted occurrences');\n        } else {\n            console.log('No occurrences to insert');\n        }\n        // Update dream with scheduling metadata if needed\n        const dreamUpdates = {};\n        if (schedulingResult.auto_compacted) {\n        // Could add a field to track auto-compaction\n        // dreamUpdates.auto_compacted = true\n        }\n        if (schedulingResult.too_tight) {\n        // Could add a field to track tight scheduling\n        // dreamUpdates.too_tight = true\n        }\n        if (Object.keys(dreamUpdates).length > 0) {\n            await sb.from('dreams').update(dreamUpdates).eq('id', dream_id);\n        }\n        return next_server__WEBPACK_IMPORTED_MODULE_0__.NextResponse.json({\n            success: true,\n            scheduled_count: schedulingResult.occurrences.length,\n            warnings: schedulingResult.warnings,\n            auto_compacted: schedulingResult.auto_compacted,\n            too_tight: schedulingResult.too_tight,\n            recommended_end: schedulingResult.recommended_end\n        });\n    } catch (error) {\n        console.error('Scheduling error:', error);\n        return next_server__WEBPACK_IMPORTED_MODULE_0__.NextResponse.json({\n            error: 'Internal server error'\n        }, {\n            status: 500\n        });\n    }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9hcHAvYXBpL2NyZWF0ZS9zY2hlZHVsZS1hY3Rpb25zL3JvdXRlLnRzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7QUFBMEM7QUFDeUM7QUFDUjtBQUczRSxlQUFlSSxRQUFRQyxHQUFZO0lBQ2pDLE1BQU1DLFFBQVFELElBQUlFLE9BQU8sQ0FBQ0MsR0FBRyxDQUFDLGtCQUFrQkMsUUFBUSxXQUFVO0lBQ2xFLElBQUksQ0FBQ0gsT0FBTyxPQUFPO0lBQ25CLE1BQU1JLFdBQVdULG1FQUFjQTtJQUMvQixNQUFNLEVBQUVVLElBQUksRUFBRUMsS0FBSyxFQUFFLEdBQUcsTUFBTUYsU0FBU0csSUFBSSxDQUFDVCxPQUFPLENBQUNFO0lBQ3BELE9BQU9LLEtBQUtHLElBQUksSUFBSTtBQUN0QjtBQUVPLGVBQWVDLEtBQUtWLEdBQVk7SUFDckMsSUFBSTtRQUNGLE1BQU1DLFFBQVFELElBQUlFLE9BQU8sQ0FBQ0MsR0FBRyxDQUFDLGtCQUFrQkMsUUFBUSxXQUFVO1FBQ2xFLElBQUksQ0FBQ0gsT0FBTztZQUNWLE9BQU9OLHFEQUFZQSxDQUFDZ0IsSUFBSSxDQUN0QjtnQkFBRUosT0FBTztZQUFlLEdBQ3hCO2dCQUFFSyxRQUFRO1lBQUk7UUFFbEI7UUFFQSxNQUFNLEVBQUVDLFFBQVEsRUFBRSxHQUFHLE1BQU1iLElBQUlXLElBQUk7UUFFbkMsSUFBSSxDQUFDRSxVQUFVO1lBQ2IsT0FBT2xCLHFEQUFZQSxDQUFDZ0IsSUFBSSxDQUN0QjtnQkFBRUosT0FBTztZQUF1QixHQUNoQztnQkFBRUssUUFBUTtZQUFJO1FBRWxCO1FBRUEscUJBQXFCO1FBQ3JCLE1BQU1ILE9BQU8sTUFBTVYsUUFBUUM7UUFDM0IsSUFBSSxDQUFDUyxNQUFNO1lBQ1QsT0FBT2QscURBQVlBLENBQUNnQixJQUFJLENBQ3RCO2dCQUFFSixPQUFPO1lBQWUsR0FDeEI7Z0JBQUVLLFFBQVE7WUFBSTtRQUVsQjtRQUVBLDZDQUE2QztRQUM3QyxNQUFNRSxLQUFLakIsdUVBQWtCQSxDQUFDSTtR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QVFkLEtBQUssQ0FBQyxpQkFBaUJnRTtnQkFDL0IsT0FBTzVFLHFEQUFZQSxDQUFDZ0IsSUFBSSxDQUN0QjtvQkFBRUosT0FBTztvQkFBZ0NxQixTQUFTMkM7Z0JBQVksR0FDOUQ7b0JBQUUzRCxRQUFRO2dCQUFJO1lBRWxCO1lBRUFTLFFBQVFDLEdBQUcsQ0FBQztRQUNkLE9BQU87WUFDTEQsUUFBUUMsR0FBRyxDQUFDO1FBQ2Q7UUFFQSxrREFBa0Q7UUFDbEQsTUFBTXNELGVBQStCLENBQUM7UUFDdEMsSUFBSTFCLGlCQUFpQjJCLGNBQWMsRUFBRTtRQUNuQyw2Q0FBNkM7UUFDN0MscUNBQXFDO1FBQ3ZDO1FBQ0EsSUFBSTNCLGlCQUFpQjRCLFNBQVMsRUFBRTtRQUM5Qiw4Q0FBOEM7UUFDOUMsZ0NBQWdDO1FBQ2xDO1FBRUEsSUFBSUMsT0FBT0MsSUFBSSxDQUFDSixjQUFjOUMsTUFBTSxHQUFHLEdBQUc7WUFDeEMsTUFBTWhCLEdBQ0hHLElBQUksQ0FBQyxVQUNMZ0UsTUFBTSxDQUFDTCxjQUNQekQsRUFBRSxDQUFDLE1BQU1OO1FBQ2Q7UUFFQSxPQUFPbEIscURBQVlBLENBQUNnQixJQUFJLENBQUM7WUFDdkJ3QyxTQUFTO1lBQ1QrQixpQkFBaUJoQyxpQkFBaUJHLFdBQVcsQ0FBQ3ZCLE1BQU07WUFDcER5QixVQUFVTCxpQkFBaUJLLFFBQVE7WUFDbkNzQixnQkFBZ0IzQixpQkFBaUIyQixjQUFjO1lBQy9DQyxXQUFXNUIsaUJBQWlCNEIsU0FBUztZQUNyQ0ssaUJBQWlCakMsaUJBQWlCaUMsZUFBZTtRQUNuRDtJQUVGLEVBQUUsT0FBTzVFLE9BQU87UUFDZGMsUUFBUWQsS0FBSyxDQUFDLHFCQUFxQkE7UUFDbkMsT0FBT1oscURBQVlBLENBQUNnQixJQUFJLENBQ3RCO1lBQUVKLE9BQU87UUFBd0IsR0FDakM7WUFBRUssUUFBUTtRQUFJO0lBRWxCO0FBQ0YiLCJzb3VyY2VzIjpbIi9Vc2Vycy9hbGV4L3JlZ3JldGxlc3MtMy9iYWNrZW5kL2FwcC9hcGkvY3JlYXRlL3NjaGVkdWxlLWFjdGlvbnMvcm91dGUudHMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgTmV4dFJlc3BvbnNlIH0gZnJvbSAnbmV4dC9zZXJ2ZXInXG5pbXBvcnQgeyBzdXBhYmFzZVNlcnZlciwgc3VwYWJhc2VTZXJ2ZXJBdXRoIH0gZnJvbSAnLi4vLi4vLi4vLi4vbGliL3N1cGFiYXNlU2VydmVyJ1xuaW1wb3J0IHsgc2NoZWR1bGVEcmVhbUFjdGlvbnMgfSBmcm9tICcuLi8uLi8uLi8uLi9saWIvc2NoZWR1bGluZy9zY2hlZHVsZXInXG5pbXBvcnQgdHlwZSB7IERyZWFtLCBBcmVhLCBBY3Rpb24sIEFjdGlvbk9jY3VycmVuY2UgfSBmcm9tICcuLi8uLi8uLi8uLi9kYXRhYmFzZS90eXBlcydcblxuYXN5bmMgZnVuY3Rpb24gZ2V0VXNlcihyZXE6IFJlcXVlc3QpIHtcbiAgY29uc3QgdG9rZW4gPSByZXEuaGVhZGVycy5nZXQoJ2F1dGhvcml6YXRpb24nKT8ucmVwbGFjZSgnQmVhcmVyICcsJycpXG4gIGlmICghdG9rZW4pIHJldHVybiBudWxsXG4gIGNvbnN0IHN1cGFiYXNlID0gc3VwYWJhc2VTZXJ2ZXIoKVxuICBjb25zdCB7IGRhdGEsIGVycm9yIH0gPSBhd2FpdCBzdXBhYmFzZS5hdXRoLmdldFVzZXIodG9rZW4pXG4gIHJldHVybiBkYXRhLnVzZXIgPz8gbnVsbFxufVxuXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gUE9TVChyZXE6IFJlcXVlc3QpIHtcbiAgdHJ5IHtcbiAgICBjb25zdCB0b2tlbiA9IHJlcS5oZWFkZXJzLmdldCgnYXV0aG9yaXphdGlvbicpPy5yZXBsYWNlKCdCZWFyZXIgJywnJylcbiAgICBpZiAoIXRva2VuKSB7XG4gICAgICByZXR1cm4gTmV4dFJlc3BvbnNlLmpzb24oXG4gICAgICAgIHsgZXJyb3I6ICdVbmF1dGhvcml6ZWQnIH0sXG4gICAgICAgIHsgc3RhdHVzOiA0MDEgfVxuICAgICAgKVxuICAgIH1cblxuICAgIGNvbnN0IHsgZHJlYW1faWQgfSA9IGF3YWl0IHJlcS5qc29uKClcbiAgICBcbiAgICBpZiAoIWRyZWFtX2lkKSB7XG4gICAgICByZXR1cm4gTmV4dFJlc3BvbnNlLmpzb24oXG4gICAgICAgIHsgZXJyb3I6ICdkcmVhbV9pZCBpcyByZXF1aXJlZCcgfSxcbiAgICAgICAgeyBzdGF0dXM6IDQwMCB9XG4gICAgICApXG4gICAgfVxuXG4gICAgLy8gR2V0IHVzZXIgZnJvbSBhdXRoXG4gICAgY29uc3QgdXNlciA9IGF3YWl0IGdldFVzZXIocmVxKVxuICAgIGlmICghdXNlcikge1xuICAgICAgcmV0dXJuIE5leHRSZXNwb25zZS5qc29uKFxuICAgICAgICB7IGVycm9yOiAnVW5hdXRob3JpemVkJyB9LFxuICAgICAgICB7IHN0YXR1czogNDAxIH1cbiAgICAgIClcbiAgICB9XG5cbiAgICAvLyBVc2UgYXV0aGVudGljYXRlZCBjbGllbnQgdGhhdCByZXNwZWN0cyBSTFNcbiAgICBjb25zdCBzYiA9IHN1cGFiYXNlU2VydmVyQXV0aCh0b2tlbilcblxuICAgIC8vIEZldGNoIGRyZWFtIGRhdGEgLSBSTFMgd2lsbCBhdXRvbWF0aWNhbGx5IGZpbHRlciBieSB1c2VyX2lkXG4gICAgY29uc3QgeyBkYXRhOiBkcmVhbSwgZXJyb3I6IGRyZWFtRXJyb3IgfSA9IGF3YWl0IHNiXG4gICAgICAuZnJvbSgnZHJlYW1zJylcbiAgICAgIC5zZWxlY3QoJyonKVxuICAgICAgLmVxKCdpZCcsIGRyZWFtX2lkKVxuICAgICAgLnNpbmdsZSgpXG5cbiAgICBpZiAoZHJlYW1FcnJvciB8fCAhZHJlYW0pIHtcbiAgICAgIHJldHVybiBOZXh0UmVzcG9uc2UuanNvbihcbiAgICAgICAgeyBlcnJvcjogJ0RyZWFtIG5vdCBmb3VuZCcgfSxcbiAgICAgICAgeyBzdGF0dXM6IDQwNCB9XG4gICAgICApXG4gICAgfVxuXG4gICAgLy8gRmV0Y2ggYXJlYXMgZm9yIHRoaXMgZHJlYW1cbiAgICBjb25zb2xlLmxvZygnRmV0Y2hpbmcgYXJlYXMgZm9yIGRyZWFtOicsIGRyZWFtX2lkLCAndXNlcjonLCB1c2VyLmlkKVxuICAgIGNvbnN0IHsgZGF0YTogYXJlYXMsIGVycm9yOiBhcmVhc0Vycm9yIH0gPSBhd2FpdCBzYlxuICAgICAgLmZyb20oJ2FyZWFzJylcbiAgICAgIC5zZWxlY3QoJyonKVxuICAgICAgLmVxKCdkcmVhbV9pZCcsIGRyZWFtX2lkKVxuICAgICAgLmlzKCdkZWxldGVkX2F0JywgbnVsbClcbiAgICAgIC5vcmRlcigncG9zaXRpb24nKVxuXG4gICAgaWYgKGFyZWFzRXJyb3IpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ0FyZWFzIGZldGNoIGVycm9yOicsIGFyZWFzRXJyb3IpXG4gICAgICByZXR1cm4gTmV4dFJlc3BvbnNlLmpzb24oXG4gICAgICAgIHsgZXJyb3I6ICdGYWlsZWQgdG8gZmV0Y2ggYXJlYXMnLCBkZXRhaWxzOiBhcmVhc0Vycm9yLm1lc3NhZ2UgfSxcbiAgICAgICAgeyBzdGF0dXM6IDUwMCB9XG4gICAgICApXG4gICAgfVxuXG4gICAgY29uc29sZS5sb2coJ0ZvdW5kIGFyZWFzOicsIGFyZWFzPy5sZW5ndGggfHwgMClcblxuICAgIC8vIEZldGNoIGFjdGlvbnMgZm9yIHRoaXMgZHJlYW1cbiAgICBjb25zb2xlLmxvZygnRmV0Y2hpbmcgYWN0aW9ucyBmb3IgYXJlYXM6JywgYXJlYXMubWFwKGFyZWEgPT4gYXJlYS5pZCkpXG4gICAgXG4gICAgLy8gRmlyc3QsIGxldCdzIGNoZWNrIHdoYXQgYWN0aW9ucyBleGlzdCBmb3IgdGhlc2UgYXJlYXMgKHdpdGhvdXQgZmlsdGVycylcbiAgICBjb25zdCB7IGRhdGE6IGFsbEFjdGlvbnMsIGVycm9yOiBhbGxBY3Rpb25zRXJyb3IgfSA9IGF3YWl0IHNiXG4gICAgICAuZnJvbSgnYWN0aW9ucycpXG4gICAgICAuc2VsZWN0KCcqJylcbiAgICAgIC5pbignYXJlYV9pZCcsIGFyZWFzLm1hcChhcmVhID0+IGFyZWEuaWQpKVxuICAgIFxuICAgIGNvbnNvbGUubG9nKCdBbGwgYWN0aW9ucyBmb3VuZCAobm8gZmlsdGVycyk6JywgYWxsQWN0aW9ucz8ubGVuZ3RoIHx8IDApXG4gICAgaWYgKGFsbEFjdGlvbnMgJiYgYWxsQWN0aW9ucy5sZW5ndGggPiAwKSB7XG4gICAgICBjb25zb2xlLmxvZygnU2FtcGxlIGFjdGlvbjonLCB7XG4gICAgICAgIGlkOiBhbGxBY3Rpb25zWzBdLmlkLFxuICAgICAgICBhcmVhX2lkOiBhbGxBY3Rpb25zWzBdLmFyZWFfaWQsXG4gICAgICAgIGlzX2FjdGl2ZTogYWxsQWN0aW9uc1swXS5pc19hY3RpdmUsXG4gICAgICAgIGRlbGV0ZWRfYXQ6IGFsbEFjdGlvbnNbMF0uZGVsZXRlZF9hdCxcbiAgICAgICAgcG9zaXRpb246IGFsbEFjdGlvbnNbMF0ucG9zaXRpb25cbiAgICAgIH0pXG4gICAgfVxuICAgIFxuICAgIC8vIE5vdyB0cnkgd2l0aCBmaWx0ZXJzXG4gICAgY29uc3QgeyBkYXRhOiBhY3Rpb25zLCBlcnJvcjogYWN0aW9uc0Vycm9yIH0gPSBhd2FpdCBzYlxuICAgICAgLmZyb20oJ2FjdGlvbnMnKVxuICAgICAgLnNlbGVjdCgnKicpXG4gICAgICAuaW4oJ2FyZWFfaWQnLCBhcmVhcy5tYXAoYXJlYSA9PiBhcmVhLmlkKSlcbiAgICAgIC5pcygnZGVsZXRlZF9hdCcsIG51bGwpXG4gICAgICAuZXEoJ2lzX2FjdGl2ZScsIHRydWUpXG4gICAgICAub3JkZXIoJ3Bvc2l0aW9uJylcblxuICAgIGlmIChhY3Rpb25zRXJyb3IpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ0FjdGlvbnMgZmV0Y2ggZXJyb3I6JywgYWN0aW9uc0Vycm9yKVxuICAgICAgcmV0dXJuIE5leHRSZXNwb25zZS5qc29uKFxuICAgICAgICB7IGVycm9yOiAnRmFpbGVkIHRvIGZldGNoIGFjdGlvbnMnLCBkZXRhaWxzOiBhY3Rpb25zRXJyb3IubWVzc2FnZSB9LFxuICAgICAgICB7IHN0YXR1czogNTAwIH1cbiAgICAgIClcbiAgICB9XG5cbiAgICBjb25zb2xlLmxvZygnRm91bmQgYWN0aW9uczonLCBhY3Rpb25zPy5sZW5ndGggfHwgMClcblxuICAgIC8vIEZldGNoIGV4aXN0aW5nIG9jY3VycmVuY2VzIHRvIGF2b2lkIGR1cGxpY2F0ZXNcbiAgICBjb25zdCB7IGRhdGE6IGV4aXN0aW5nT2NjdXJyZW5jZXMsIGVycm9yOiBvY2N1cnJlbmNlc0Vycm9yIH0gPSBhd2FpdCBzYlxuICAgICAgLmZyb20oJ2FjdGlvbl9vY2N1cnJlbmNlcycpXG4gICAgICAuc2VsZWN0KCcqJylcbiAgICAgIC5pbignYWN0aW9uX2lkJywgYWN0aW9ucy5tYXAoYWN0aW9uID0+IGFjdGlvbi5pZCkpXG5cbiAgICBpZiAob2NjdXJyZW5jZXNFcnJvcikge1xuICAgICAgcmV0dXJuIE5leHRSZXNwb25zZS5qc29uKFxuICAgICAgICB7IGVycm9yOiAnRmFpbGVkIHRvIGZldGNoIGV4aXN0aW5nIG9jY3VycmVuY2VzJyB9LFxuICAgICAgICB7IHN0YXR1czogNTAwIH1cbiAgICAgIClcbiAgICB9XG5cbiAgICAvLyBQcmVwYXJlIHNjaGVkdWxpbmcgY29udGV4dFxuICAgIGNvbnN0IGNvbnRleHQgPSB7XG4gICAgICB1c2VyX2lkOiB1c2VyLmlkLFxuICAgICAgdGltZXpvbmU6ICdFdXJvcGUvTG9uZG9uJyAvLyBEZWZhdWx0IHRpbWV6b25lLCBjb3VsZCBiZSBtYWRlIGNvbmZpZ3VyYWJsZVxuICAgIH1cblxuICAgIGNvbnN0IGRyZWFtRGF0YSA9IHtcbiAgICAgIGRyZWFtOiBkcmVhbSBhcyBEcmVhbSxcbiAgICAgIGFyZWFzOiBhcmVhcyBhcyBBcmVhW10sXG4gICAgICBhY3Rpb25zOiBhY3Rpb25zIGFzIEFjdGlvbltdLFxuICAgICAgZXhpc3Rpbmdfb2NjdXJyZW5jZXM6IGV4aXN0aW5nT2NjdXJyZW5jZXMgYXMgQWN0aW9uT2NjdXJyZW5jZVtdXG4gICAgfVxuXG4gICAgLy8gUnVuIHNjaGVkdWxpbmcgYWxnb3JpdGhtXG4gICAgY29uc29sZS5sb2coJ1J1bm5pbmcgc2NoZWR1bGluZyBhbGdvcml0aG0uLi4nKVxuICAgIGNvbnN0IHNjaGVkdWxpbmdSZXN1bHQgPSBhd2FpdCBzY2hlZHVsZURyZWFtQWN0aW9ucyhjb250ZXh0LCBkcmVhbURhdGEpXG5cbiAgICBjb25zb2xlLmxvZygnU2NoZWR1bGluZyByZXN1bHQ6Jywge1xuICAgICAgc3VjY2Vzczogc2NoZWR1bGluZ1Jlc3VsdC5zdWNjZXNzLFxuICAgICAgb2NjdXJyZW5jZXNDb3VudDogc2NoZWR1bGluZ1Jlc3VsdC5vY2N1cnJlbmNlcy5sZW5ndGgsXG4gICAgICBlcnJvcnM6IHNjaGVkdWxpbmdSZXN1bHQuZXJyb3JzLFxuICAgICAgd2FybmluZ3M6IHNjaGVkdWxpbmdSZXN1bHQud2FybmluZ3NcbiAgICB9KVxuXG4gICAgaWYgKCFzY2hlZHVsaW5nUmVzdWx0LnN1Y2Nlc3MpIHtcbiAgICAgIHJldHVybiBOZXh0UmVzcG9uc2UuanNvbihcbiAgICAgICAgeyBcbiAgICAgICAgICBlcnJvcjogJ1NjaGVkdWxpbmcgZmFpbGVkJyxcbiAgICAgICAgICBkZXRhaWxzOiBzY2hlZHVsaW5nUmVzdWx0LmVycm9yc1xuICAgICAgICB9LFxuICAgICAgICB7IHN0YXR1czogNTAwIH1cbiAgICAgIClcbiAgICB9XG5cbiAgICAvLyBJbnNlcnQgbmV3IG9jY3VycmVuY2VzIGludG8gZGF0YWJhc2VcbiAgICBpZiAoc2NoZWR1bGluZ1Jlc3VsdC5vY2N1cnJlbmNlcy5sZW5ndGggPiAwKSB7XG4gICAgICBjb25zb2xlLmxvZygnSW5zZXJ0aW5nIG9jY3VycmVuY2VzOicsIHNjaGVkdWxpbmdSZXN1bHQub2NjdXJyZW5jZXMubGVuZ3RoKVxuICAgICAgY29uc29sZS5sb2coJ1NhbXBsZSBvY2N1cnJlbmNlOicsIHtcbiAgICAgICAgYWN0aW9uX2lkOiBzY2hlZHVsaW5nUmVzdWx0Lm9jY3VycmVuY2VzWzBdLmFjdGlvbl9pZCxcbiAgICAgICAgb2NjdXJyZW5jZV9ubzogc2NoZWR1bGluZ1Jlc3VsdC5vY2N1cnJlbmNlc1swXS5vY2N1cnJlbmNlX25vLFxuICAgICAgICBwbGFubmVkX2R1ZV9vbjogc2NoZWR1bGluZ1Jlc3VsdC5vY2N1cnJlbmNlc1swXS5wbGFubmVkX2R1ZV9vbixcbiAgICAgICAgZHVlX29uOiBzY2hlZHVsaW5nUmVzdWx0Lm9jY3VycmVuY2VzWzBdLmR1ZV9vblxuICAgICAgfSlcbiAgICAgIFxuICAgICAgLy8gRGVkdXBsaWNhdGUgb2NjdXJyZW5jZXMgYnkgKGFjdGlvbl9pZCwgb2NjdXJyZW5jZV9ubykgdG8gYXZvaWQgY29uZmxpY3RzXG4gICAgICBjb25zdCB1bmlxdWVPY2N1cnJlbmNlcyA9IHNjaGVkdWxpbmdSZXN1bHQub2NjdXJyZW5jZXMucmVkdWNlKChhY2MsIG9jYykgPT4ge1xuICAgICAgICBjb25zdCBrZXkgPSBgJHtvY2MuYWN0aW9uX2lkfS0ke29jYy5vY2N1cnJlbmNlX25vfWBcbiAgICAgICAgaWYgKCFhY2MuaGFzKGtleSkpIHtcbiAgICAgICAgICBhY2Muc2V0KGtleSwgb2NjKVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBhY2NcbiAgICAgIH0sIG5ldyBNYXAoKSlcbiAgICAgIFxuICAgICAgY29uc3QgZGVkdXBsaWNhdGVkT2NjdXJyZW5jZXMgPSBBcnJheS5mcm9tKHVuaXF1ZU9jY3VycmVuY2VzLnZhbHVlcygpKVxuICAgICAgY29uc29sZS5sb2coJ0RlZHVwbGljYXRlZCBvY2N1cnJlbmNlczonLCBkZWR1cGxpY2F0ZWRPY2N1cnJlbmNlcy5sZW5ndGgpXG4gICAgICBcbiAgICAgIGNvbnN0IHsgZXJyb3I6IGluc2VydEVycm9yIH0gPSBhd2FpdCBzYlxuICAgICAgICAuZnJvbSgnYWN0aW9uX29jY3VycmVuY2VzJylcbiAgICAgICAgLnVwc2VydChkZWR1cGxpY2F0ZWRPY2N1cnJlbmNlcy5tYXAob2NjID0+ICh7XG4gICAgICAgICAgYWN0aW9uX2lkOiBvY2MuYWN0aW9uX2lkLFxuICAgICAgICAgIGFyZWFfaWQ6IG9jYy5hcmVhX2lkLFxuICAgICAgICAgIGRyZWFtX2lkOiBkcmVhbV9pZCxcbiAgICAgICAgICBvY2N1cnJlbmNlX25vOiBvY2Mub2NjdXJyZW5jZV9ubyxcbiAgICAgICAgICBwbGFubmVkX2R1ZV9vbjogb2NjLnBsYW5uZWRfZHVlX29uLFxuICAgICAgICAgIGR1ZV9vbjogb2NjLmR1ZV9vbixcbiAgICAgICAgICBkZWZlcl9jb3VudDogb2NjLmRlZmVyX2NvdW50LFxuICAgICAgICAgIHVzZXJfaWQ6IHVzZXIuaWRcbiAgICAgICAgfSkpLCB7XG4gICAgICAgICAgb25Db25mbGljdDogJ2FjdGlvbl9pZCxvY2N1cnJlbmNlX25vJyxcbiAgICAgICAgICBpZ25vcmVEdXBsaWNhdGVzOiBmYWxzZVxuICAgICAgICB9KVxuXG4gICAgICBpZiAoaW5zZXJ0RXJyb3IpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcignSW5zZXJ0IGVycm9yOicsIGluc2VydEVycm9yKVxuICAgICAgICByZXR1cm4gTmV4dFJlc3BvbnNlLmpzb24oXG4gICAgICAgICAgeyBlcnJvcjogJ0ZhaWxlZCB0byBpbnNlcnQgb2NjdXJyZW5jZXMnLCBkZXRhaWxzOiBpbnNlcnRFcnJvciB9LFxuICAgICAgICAgIHsgc3RhdHVzOiA1MDAgfVxuICAgICAgICApXG4gICAgICB9XG4gICAgICBcbiAgICAgIGNvbnNvbGUubG9nKCdTdWNjZXNzZnVsbHkgaW5zZXJ0ZWQgb2NjdXJyZW5jZXMnKVxuICAgIH0gZWxzZSB7XG4gICAgICBjb25zb2xlLmxvZygnTm8gb2NjdXJyZW5jZXMgdG8gaW5zZXJ0JylcbiAgICB9XG5cbiAgICAvLyBVcGRhdGUgZHJlYW0gd2l0aCBzY2hlZHVsaW5nIG1ldGFkYXRhIGlmIG5lZWRlZFxuICAgIGNvbnN0IGRyZWFtVXBkYXRlczogUGFydGlhbDxEcmVhbT4gPSB7fVxuICAgIGlmIChzY2hlZHVsaW5nUmVzdWx0LmF1dG9fY29tcGFjdGVkKSB7XG4gICAgICAvLyBDb3VsZCBhZGQgYSBmaWVsZCB0byB0cmFjayBhdXRvLWNvbXBhY3Rpb25cbiAgICAgIC8vIGRyZWFtVXBkYXRlcy5hdXRvX2NvbXBhY3RlZCA9IHRydWVcbiAgICB9XG4gICAgaWYgKHNjaGVkdWxpbmdSZXN1bHQudG9vX3RpZ2h0KSB7XG4gICAgICAvLyBDb3VsZCBhZGQgYSBmaWVsZCB0byB0cmFjayB0aWdodCBzY2hlZHVsaW5nXG4gICAgICAvLyBkcmVhbVVwZGF0ZXMudG9vX3RpZ2h0ID0gdHJ1ZVxuICAgIH1cblxuICAgIGlmIChPYmplY3Qua2V5cyhkcmVhbVVwZGF0ZXMpLmxlbmd0aCA+IDApIHtcbiAgICAgIGF3YWl0IHNiXG4gICAgICAgIC5mcm9tKCdkcmVhbXMnKVxuICAgICAgICAudXBkYXRlKGRyZWFtVXBkYXRlcylcbiAgICAgICAgLmVxKCdpZCcsIGRyZWFtX2lkKVxuICAgIH1cblxuICAgIHJldHVybiBOZXh0UmVzcG9uc2UuanNvbih7XG4gICAgICBzdWNjZXNzOiB0cnVlLFxuICAgICAgc2NoZWR1bGVkX2NvdW50OiBzY2hlZHVsaW5nUmVzdWx0Lm9jY3VycmVuY2VzLmxlbmd0aCxcbiAgICAgIHdhcm5pbmdzOiBzY2hlZHVsaW5nUmVzdWx0Lndhcm5pbmdzLFxuICAgICAgYXV0b19jb21wYWN0ZWQ6IHNjaGVkdWxpbmdSZXN1bHQuYXV0b19jb21wYWN0ZWQsXG4gICAgICB0b29fdGlnaHQ6IHNjaGVkdWxpbmdSZXN1bHQudG9vX3RpZ2h0LFxuICAgICAgcmVjb21tZW5kZWRfZW5kOiBzY2hlZHVsaW5nUmVzdWx0LnJlY29tbWVuZGVkX2VuZFxuICAgIH0pXG5cbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICBjb25zb2xlLmVycm9yKCdTY2hlZHVsaW5nIGVycm9yOicsIGVycm9yKVxuICAgIHJldHVybiBOZXh0UmVzcG9uc2UuanNvbihcbiAgICAgIHsgZXJyb3I6ICdJbnRlcm5hbCBzZXJ2ZXIgZXJyb3InIH0sXG4gICAgICB7IHN0YXR1czogNTAwIH1cbiAgICApXG4gIH1cbn1cbiJdLCJuYW1lcyI6WyJOZXh0UmVzcG9uc2UiLCJzdXBhYmFzZVNlcnZlciIsInN1cGFiYXNlU2VydmVyQXV0aCIsInNjaGVkdWxlRHJlYW1BY3Rpb25zIiwiZ2V0VXNlciIsInJlcSIsInRva2VuIiwiaGVhZGVycyIsImdldCIsInJlcGxhY2UiLCJzdXBhYmFzZSIsImRhdGEiLCJlcnJvciIsImF1dGgiLCJ1c2VyIiwiUE9TVCIsImpzb24iLCJzdGF0dXMiLCJkcmVhbV9pZCIsInNiIiwiZHJlYW0iLCJkcmVhbUVycm9yIiwiZnJvbSIsInNlbGVjdCIsImVxIiwic2luZ2xlIiwiY29uc29sZSIsImxvZyIsImlkIiwiYXJlYXMiLCJhcmVhc0Vycm9yIiwiaXMiLCJvcmRlciIsImRldGFpbHMiLCJtZXNzYWdlIiwibGVuZ3RoIiwibWFwIiwiYXJlYSIsImFsbEFjdGlvbnMiLCJhbGxBY3Rpb25zRXJyb3IiLCJpbiIsImFyZWFfaWQiLCJpc19hY3RpdmUiLCJkZWxldGVkX2F0IiwicG9zaXRpb24iLCJhY3Rpb25zIiwiYWN0aW9uc0Vycm9yIiwiZXhpc3RpbmdPY2N1cnJlbmNlcyIsIm9jY3VycmVuY2VzRXJyb3IiLCJhY3Rpb24iLCJjb250ZXh0IiwidXNlcl9pZCIsInRpbWV6b25lIiwiZHJlYW1EYXRhIiwiZXhpc3Rpbmdfb2NjdXJyZW5jZXMiLCJzY2hlZHVsaW5nUmVzdWx0Iiwic3VjY2VzcyIsIm9jY3VycmVuY2VzQ291bnQiLCJvY2N1cnJlbmNlcyIsImVycm9ycyIsIndhcm5pbmdzIiwiYWN0aW9uX2lkIiwib2NjdXJyZW5jZV9ubyIsInBsYW5uZWRfZHVlX29uIiwiZHVlX29uIiwidW5pcXVlT2NjdXJyZW5jZXMiLCJyZWR1Y2UiLCJhY2MiLCJvY2MiLCJrZXkiLCJoYXMiLCJzZXQiLCJNYXAiLCJkZWR1cGxpY2F0ZWRPY2N1cnJlbmNlcyIsIkFycmF5IiwidmFsdWVzIiwiaW5zZXJ0RXJyb3IiLCJ1cHNlcnQiLCJkZWZlcl9jb3VudCIsIm9uQ29uZmxpY3QiLCJpZ25vcmVEdXBsaWNhdGVzIiwiZHJlYW1VcGRhdGVzIiwiYXV0b19jb21wYWN0ZWQiLCJ0b29fdGlnaHQiLCJPYmplY3QiLCJrZXlzIiwidXBkYXRlIiwic2NoZWR1bGVkX2NvdW50IiwicmVjb21tZW5kZWRfZW5kIl0sImlnbm9yZUxpc3QiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./app/api/create/schedule-actions/route.ts\n");

/***/ }),

/***/ "(rsc)/./lib/scheduling/scheduler.ts":
/*!*************************************!*\
  !*** ./lib/scheduling/scheduler.ts ***!
  \*************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   scheduleDreamActions: () => (/* binding */ scheduleDreamActions)\n/* harmony export */ });\n// Configuration constants\nconst TARGET_PER_WEEK = 3;\nconst REST_DAYS = new Set([\n    0\n]) // Sunday = 0\n;\nconst GLOBAL_DAILY_CAP = 5;\nconst PER_DREAM_CAP_DEFAULT = 1;\nconst PER_DREAM_CAP_MAX = 3;\nconst MIN_GAP_DAYS_BETWEEN_SEEDS = 1;\nconst DEFAULT_DAILY_TIME_MINUTES = 30 // Default if no time commitment specified\n;\n/**\n * Main scheduling function that creates action occurrences for a dream\n */ async function scheduleDreamActions(context, dreamData) {\n    const { dream, areas, actions, existing_occurrences } = dreamData;\n    console.log('üéØ Starting scheduling for dream:', dream.title);\n    console.log('üìä Input data:', {\n        areasCount: areas.length,\n        actionsCount: actions.length,\n        existingOccurrencesCount: existing_occurrences.length\n    });\n    try {\n        // Step 1: Calculate scheduling window\n        const window = calculateSchedulingWindow(dream, actions);\n        console.log('üìÖ Scheduling window:', {\n            start: window.start_date.toISOString().split('T')[0],\n            end: window.end_date.toISOString().split('T')[0],\n            autoCompacted: window.auto_compacted\n        });\n        // Step 2: Build capacity tracker\n        const capacity = buildCapacityTracker(window.start_date, window.end_date, dream.time_commitment);\n        console.log('üìä Capacity tracker initialized:', {\n            totalDays: capacity.global_remaining.size,\n            sampleDay: Array.from(capacity.global_remaining.entries())[0]\n        });\n        // Step 3: Sort actions by position (area.position, action.position)\n        const sortedActions = sortActionsByPosition(actions, areas);\n        console.log('üìã Areas with positions:', areas.map((a)=>`${a.title} (area pos: ${a.position})`));\n        console.log('üìã Sorted actions:', sortedActions.map((a)=>{\n            const area = areas.find((area)=>area.id === a.area_id);\n            return `${a.title} (area pos: ${area?.position || 'unknown'}, action pos: ${a.position})`;\n        }));\n        // Step 4: Seed all actions (Step 1 of algorithm)\n        const seedResults = await seedAllActions(context, dream, sortedActions, areas, window, capacity, existing_occurrences);\n        console.log('üå± Seed results:', {\n            placementsCount: seedResults.placements.length,\n            tightPendingCount: seedResults.tight_pending.length\n        });\n        // Step 5: Expand repeats (Step 2 of algorithm)\n        const repeatResults = await expandRepeats(context, dream, sortedActions, window, capacity, seedResults.placements || []);\n        // Step 6: Global balancing (Step 3 of algorithm)\n        const balancedResults = await globalBalancing(context, dream, window, capacity, [\n            ...seedResults.placements || [],\n            ...repeatResults.placements || []\n        ], sortedActions);\n        // Step 7: Tight fallback escalation (Step 4 of algorithm)\n        const finalResults = await tightFallbackEscalation(context, dream, sortedActions, window, capacity, balancedResults.placements || [], seedResults.tight_pending || []);\n        // Step 8: Convert to ActionOccurrence format\n        const occurrences = (finalResults.placements || []).map((placement)=>({\n                id: '',\n                action_id: placement.action_id,\n                area_id: placement.area_id,\n                occurrence_no: placement.occurrence_no,\n                planned_due_on: placement.planned_due_on,\n                due_on: placement.due_on,\n                defer_count: 0,\n                note: undefined,\n                completed_at: undefined,\n                ai_rating: undefined,\n                ai_feedback: undefined,\n                created_at: new Date().toISOString(),\n                updated_at: new Date().toISOString()\n            }));\n        console.log('‚úÖ Scheduling completed:', {\n            totalOccurrences: occurrences.length,\n            autoCompacted: window.auto_compacted,\n            tooTight: finalResults.too_tight,\n            warnings: finalResults.warnings.length\n        });\n        return {\n            success: true,\n            occurrences,\n            errors: [],\n            warnings: finalResults.warnings,\n            auto_compacted: window.auto_compacted,\n            too_tight: finalResults.too_tight,\n            recommended_end: window.recommended_end\n        };\n    } catch (error) {\n        console.error('‚ùå Scheduling error:', error);\n        return {\n            success: false,\n            occurrences: [],\n            errors: [\n                error instanceof Error ? error.message : 'Unknown scheduling error'\n            ],\n            warnings: []\n        };\n    }\n}\n/**\n * Calculate the scheduling window for a dream\n */ function calculateSchedulingWindow(dream, actions) {\n    const startDate = new Date(dream.start_date);\n    const endDate = dream.end_date ? new Date(dream.end_date) : null;\n    // Count seedable actions (one-offs + first occurrence of each repeater)\n    const seedableActions = actions.filter((action)=>action.is_active && !action.deleted_at).length;\n    // Calculate recommended end date based on time commitment\n    const timeCommitment = dream.time_commitment;\n    const dailyTimeMinutes = timeCommitment ? timeCommitment.hours * 60 + timeCommitment.minutes : DEFAULT_DAILY_TIME_MINUTES;\n    // Calculate total time needed for all actions\n    let totalTimeNeeded = 0;\n    for (const action of actions){\n        if (action.is_active && !action.deleted_at && action.est_minutes) {\n            if (action.slice_count_target) {\n                // Finite series: total time = est_minutes * slice_count_target\n                totalTimeNeeded += action.est_minutes * action.slice_count_target;\n            } else if (action.repeat_every_days) {\n                // Habit: estimate based on window length and repeat frequency\n                const windowDays = Math.ceil((endDate?.getTime() || Date.now()) - startDate.getTime()) / (1000 * 60 * 60 * 24);\n                const workDays = Math.floor(windowDays * 6 / 7) // Rough estimate excluding Sundays\n                ;\n                const occurrences = Math.max(1, Math.floor(workDays / action.repeat_every_days));\n                totalTimeNeeded += action.est_minutes * occurrences;\n            } else {\n                // One-off action\n                totalTimeNeeded += action.est_minutes;\n            }\n        }\n    }\n    // Calculate weeks needed based on time commitment\n    const workDaysPerWeek = 6 // Excluding Sundays\n    ;\n    const weeklyTimeMinutes = dailyTimeMinutes * workDaysPerWeek;\n    const weeksNeeded = Math.max(1, Math.ceil(totalTimeNeeded / weeklyTimeMinutes));\n    const recommendedEnd = new Date(startDate);\n    recommendedEnd.setDate(startDate.getDate() + weeksNeeded * 7 - 1);\n    // Window end is the earlier of end_date or recommended_end\n    const windowEnd = endDate && endDate < recommendedEnd ? endDate : recommendedEnd;\n    const autoCompacted = !endDate || endDate > recommendedEnd;\n    console.log('‚è∞ Time-based scheduling calculation:', {\n        dailyTimeMinutes,\n        totalTimeNeeded,\n        weeklyTimeMinutes,\n        weeksNeeded,\n        recommendedEnd: recommendedEnd.toISOString().split('T')[0]\n    });\n    return {\n        start_date: startDate,\n        end_date: windowEnd,\n        recommended_end: recommendedEnd.toISOString().split('T')[0],\n        auto_compacted: autoCompacted\n    };\n}\n/**\n * Build capacity tracker for the scheduling window\n */ function buildCapacityTracker(startDate, endDate, timeCommitment) {\n    const globalRemaining = new Map();\n    const perDreamRemaining = new Map();\n    // Calculate daily time budget\n    const dailyTimeMinutes = timeCommitment ? timeCommitment.hours * 60 + timeCommitment.minutes : DEFAULT_DAILY_TIME_MINUTES;\n    // Calculate time-based capacity (estimate actions that can fit in daily time)\n    // Use a conservative estimate: assume average action takes 45 minutes\n    // This gives us a reasonable cap that respects time commitment\n    const estimatedTimePerAction = 45 // minutes\n    ;\n    const timeBasedDailyCap = Math.max(1, Math.floor(dailyTimeMinutes / estimatedTimePerAction));\n    // Use the smaller of time-based cap or global cap to respect both constraints\n    const effectiveDailyCap = Math.min(timeBasedDailyCap, GLOBAL_DAILY_CAP);\n    console.log('üìä Capacity calculation:', {\n        dailyTimeMinutes,\n        timeBasedDailyCap,\n        effectiveDailyCap,\n        globalCap: GLOBAL_DAILY_CAP\n    });\n    const currentDate = new Date(startDate);\n    while(currentDate <= endDate){\n        const dateStr = currentDate.toISOString().split('T')[0];\n        const dayOfWeek = currentDate.getDay();\n        // Check if it's a rest day\n        if (REST_DAYS.has(dayOfWeek)) {\n            globalRemaining.set(dateStr, 0);\n        } else {\n            globalRemaining.set(dateStr, effectiveDailyCap);\n        }\n        perDreamRemaining.set(dateStr, new Map());\n        currentDate.setDate(currentDate.getDate() + 1);\n    }\n    return {\n        global_remaining: globalRemaining,\n        per_dream_remaining: perDreamRemaining\n    };\n}\n/**\n * Sort actions by area position, then action position\n */ function sortActionsByPosition(actions, areas) {\n    const areaPositionMap = new Map(areas.map((area)=>[\n            area.id,\n            area.position\n        ]));\n    return actions.filter((action)=>action.is_active && !action.deleted_at).sort((a, b)=>{\n        const aAreaPos = areaPositionMap.get(a.area_id) || 0;\n        const bAreaPos = areaPositionMap.get(b.area_id) || 0;\n        if (aAreaPos !== bAreaPos) {\n            return aAreaPos - bAreaPos;\n        }\n        return a.position - b.position;\n    });\n}\n/**\n * Step 1: Seed all actions in order\n */ async function seedAllActions(context, dream, sortedActions, areas, window, capacity, existingOccurrences) {\n    const placements = [];\n    const tightPending = [];\n    // Compute daily time budget for oversized detection\n    const dailyTimeMinutes = dream.time_commitment ? dream.time_commitment.hours * 60 + dream.time_commitment.minutes : DEFAULT_DAILY_TIME_MINUTES;\n    // Get eligible workdays\n    const eligibleDays = getEligibleWorkdays(window.start_date, window.end_date);\n    console.log('üìÖ Eligible workdays:', {\n        totalDays: eligibleDays.length,\n        firstDay: eligibleDays[0]?.toISOString().split('T')[0],\n        lastDay: eligibleDays[eligibleDays.length - 1]?.toISOString().split('T')[0]\n    });\n    // Calculate total occurrences needed upfront\n    let totalOccurrences = 0;\n    const actionOccurrenceCounts = new Map();\n    for (const action of sortedActions){\n        let count = 1 // Default to 1 occurrence\n        ;\n        if (action.repeat_every_days) {\n            // For habits, only seed the FIRST occurrence. Ongoing repeats are handled in expandRepeats.\n            count = 1;\n        } else if (action.slice_count_target && action.slice_count_target > 1) {\n            count = action.slice_count_target;\n        }\n        actionOccurrenceCounts.set(action.id, count);\n        totalOccurrences += count;\n    }\n    console.log(`üìä Total occurrences needed: ${totalOccurrences} across ${eligibleDays.length} workdays`);\n    console.log(`üìä Average load: ${(totalOccurrences / eligibleDays.length).toFixed(2)} occurrences per day`);\n    // Calculate target day indices for even distribution\n    const targetDayIndices = [];\n    let occurrenceIndex = 0;\n    for (const action of sortedActions){\n        const count = actionOccurrenceCounts.get(action.id) || 1;\n        for(let i = 0; i < count; i++){\n            const targetIndex = Math.round((occurrenceIndex + 0.5) * (eligibleDays.length - 1) / (totalOccurrences - 1));\n            targetDayIndices.push(Math.max(0, Math.min(eligibleDays.length - 1, targetIndex)));\n            occurrenceIndex++;\n        }\n    }\n    console.log(`üéØ Target day indices: [${targetDayIndices.slice(0, 10).join(', ')}${targetDayIndices.length > 10 ? '...' : ''}]`);\n    let currentOccurrenceIndex = 0;\n    // Group actions by area to ensure we process all actions in an area before moving to the next\n    const actionsByArea = new Map();\n    for (const action of sortedActions){\n        const area = areas.find((area)=>area.id === action.area_id);\n        const areaPosition = area?.position || 0;\n        if (!actionsByArea.has(areaPosition)) {\n            actionsByArea.set(areaPosition, []);\n        }\n        actionsByArea.get(areaPosition).push(action);\n    }\n    // Process areas in order\n    const sortedAreaPositions = Array.from(actionsByArea.keys()).sort((a, b)=>a - b);\n    for (const areaPosition of sortedAreaPositions){\n        const areaActions = actionsByArea.get(areaPosition);\n        console.log(`üèóÔ∏è  Processing area ${areaPosition} with ${areaActions.length} actions`);\n        for (const action of areaActions){\n            // Check if this action has existing occurrences\n            const existingActionOccurrences = existingOccurrences.filter((occ)=>occ.action_id === action.id);\n            if (existingActionOccurrences.length > 0) {\n                // Add existing occurrences to placements for capacity tracking\n                for (const existingOcc of existingActionOccurrences){\n                    placements.push({\n                        action_id: action.id,\n                        dream_id: dream.id,\n                        area_id: action.area_id,\n                        occurrence_no: existingOcc.occurrence_no,\n                        planned_due_on: existingOcc.planned_due_on,\n                        due_on: existingOcc.due_on,\n                        is_repeat: false,\n                        is_fixed: false\n                    });\n                }\n                continue;\n            }\n            // Get the number of occurrences needed for this action\n            const occurrenceCount = actionOccurrenceCounts.get(action.id) || 1;\n            if (occurrenceCount > 1) {\n                console.log(`üìö Seeding ${occurrenceCount} occurrences for: \"${action.title}\"`);\n            } else {\n                console.log(`üéØ Seeding single occurrence for: \"${action.title}\"`);\n            }\n            // Schedule all occurrences for this action using pre-calculated target days\n            for(let i = 0; i < occurrenceCount; i++){\n                if (currentOccurrenceIndex >= targetDayIndices.length) {\n                    console.log(`  ‚ùå No more target days available for \"${action.title}\" occurrence ${i + 1}`);\n                    tightPending.push(action.id);\n                    break;\n                }\n                const targetDayIndex = targetDayIndices[currentOccurrenceIndex];\n                const targetDay = eligibleDays[targetDayIndex];\n                if (!targetDay) {\n                    console.log(`  ‚ùå Target day index ${targetDayIndex} is out of range for \"${action.title}\" occurrence ${i + 1}`);\n                    tightPending.push(action.id);\n                    break;\n                }\n                const dateStr = targetDay.toISOString().split('T')[0];\n                // Create placement for this occurrence\n                placements.push({\n                    action_id: action.id,\n                    dream_id: dream.id,\n                    area_id: action.area_id,\n                    occurrence_no: i + 1,\n                    planned_due_on: dateStr,\n                    due_on: dateStr,\n                    is_repeat: false,\n                    // Mark oversized actions as fixed so they are not moved by balancing\n                    is_fixed: (action.est_minutes || 0) > dailyTimeMinutes\n                });\n                // Update capacity (can go negative to track violations)\n                const currentGlobal = capacity.global_remaining.get(dateStr) || 0;\n                const currentPerDream = capacity.per_dream_remaining.get(dateStr)?.get(dream.id) || 0;\n                if (currentGlobal <= 0) {\n                    console.log(`  ‚ö†Ô∏è  Global capacity violation on ${dateStr}`);\n                }\n                if (currentPerDream <= 0) {\n                    console.log(`  ‚ö†Ô∏è  Per-dream capacity violation on ${dateStr}`);\n                }\n                capacity.global_remaining.set(dateStr, currentGlobal - 1);\n                if (!capacity.per_dream_remaining.get(dateStr).has(dream.id)) {\n                    capacity.per_dream_remaining.get(dateStr).set(dream.id, PER_DREAM_CAP_DEFAULT);\n                }\n                capacity.per_dream_remaining.get(dateStr).set(dream.id, currentPerDream - 1);\n                currentOccurrenceIndex++;\n            }\n        }\n    }\n    return {\n        placements,\n        tight_pending: tightPending\n    };\n}\n/**\n * Step 2: Expand repeats\n */ async function expandRepeats(context, dream, sortedActions, window, capacity, seedPlacements) {\n    const placements = [];\n    for (const action of sortedActions){\n        const seedPlacement = seedPlacements.find((p)=>p.action_id === action.id);\n        if (!seedPlacement) continue;\n        // Only handle ongoing habits (repeat_every_days) - finite series are handled in seeding\n        if (action.repeat_every_days) {\n            console.log(`üîÑ Creating ongoing repeats for habit: \"${action.title}\" (every ${action.repeat_every_days} days)`);\n            const seedDate = new Date(seedPlacement.due_on);\n            let currentDate = new Date(seedDate);\n            let occurrenceNo = 2;\n            // Add repeat occurrences\n            while(currentDate <= window.end_date){\n                currentDate.setDate(currentDate.getDate() + action.repeat_every_days);\n                if (currentDate > window.end_date) break;\n                // Skip rest days\n                const dayOfWeek = currentDate.getDay();\n                if (REST_DAYS.has(dayOfWeek)) {\n                    // Roll to next non-rest day\n                    currentDate.setDate(currentDate.getDate() + 1);\n                    if (currentDate > window.end_date) break;\n                }\n                const dateStr = currentDate.toISOString().split('T')[0];\n                // Check capacity (advisory - we'll schedule even if violated)\n                const globalRemaining = capacity.global_remaining.get(dateStr) || 0;\n                // Ensure per_dream_remaining has an entry for this date\n                if (!capacity.per_dream_remaining.has(dateStr)) {\n                    capacity.per_dream_remaining.set(dateStr, new Map());\n                }\n                const perDreamRemaining = capacity.per_dream_remaining.get(dateStr)?.get(dream.id) || 0;\n                placements.push({\n                    action_id: action.id,\n                    dream_id: dream.id,\n                    area_id: action.area_id,\n                    occurrence_no: occurrenceNo,\n                    planned_due_on: dateStr,\n                    due_on: dateStr,\n                    is_repeat: true,\n                    is_fixed: true // Repeats are fixed and can't be moved easily\n                });\n                // Update capacity (can go negative to track violations)\n                capacity.global_remaining.set(dateStr, globalRemaining - 1);\n                capacity.per_dream_remaining.get(dateStr).set(dream.id, perDreamRemaining - 1);\n                occurrenceNo++;\n            }\n        }\n    }\n    return {\n        placements\n    };\n}\n/**\n * Step 3: Global balancing to enforce time-based capacity limits\n */ async function globalBalancing(context, dream, window, capacity, allPlacements, actions) {\n    const warnings = [];\n    const placements = [\n        ...allPlacements\n    ];\n    // Get time commitment for capacity calculations\n    const timeCommitment = dream.time_commitment;\n    const dailyTimeMinutes = timeCommitment ? timeCommitment.hours * 60 + timeCommitment.minutes : DEFAULT_DAILY_TIME_MINUTES;\n    // Create action lookup map for time estimation\n    const actionMap = new Map(actions.map((action)=>[\n            action.id,\n            action\n        ]));\n    // Track moved placements to prevent infinite loops\n    const movedPlacements = new Set();\n    // Maximum number of iterations to prevent infinite loops\n    const MAX_ITERATIONS = 100;\n    let iteration = 0;\n    // Check for days that exceed time-based capacity\n    while(iteration < MAX_ITERATIONS){\n        iteration++;\n        let hasChanges = false;\n        const currentDate = new Date(window.start_date);\n        // Track target dates we've already moved to in this iteration to avoid clustering\n        const usedTargetDates = new Set();\n        while(currentDate <= window.end_date){\n            const dateStr = currentDate.toISOString().split('T')[0];\n            const dayPlacements = placements.filter((p)=>p.due_on === dateStr);\n            // Calculate total time for this day\n            let totalDayTime = 0;\n            for (const placement of dayPlacements){\n                const action = actionMap.get(placement.action_id);\n                if (action?.est_minutes) {\n                    totalDayTime += action.est_minutes;\n                }\n            }\n            // Check if this day exceeds the time budget\n            if (totalDayTime > dailyTimeMinutes) {\n                console.log(`‚è∞ Day ${dateStr} exceeds time budget: ${totalDayTime}min > ${dailyTimeMinutes}min`);\n                // Find non-repeat one-offs that can be moved (skip oversized actions marked fixed)\n                const moveablePlacements = dayPlacements.filter((p)=>!p.is_repeat && !p.is_fixed && !movedPlacements.has(p.action_id));\n                // Sort by move priority (longest actions first to maximize time savings)\n                moveablePlacements.sort((a, b)=>{\n                    const actionA = actionMap.get(a.action_id);\n                    const actionB = actionMap.get(b.action_id);\n                    const timeA = actionA?.est_minutes || 0;\n                    const timeB = actionB?.est_minutes || 0;\n                    return timeB - timeA // Sort by time descending\n                    ;\n                });\n                // Try to move actions until we're under the time budget\n                let remainingTime = totalDayTime;\n                for (const placement of moveablePlacements){\n                    if (remainingTime <= dailyTimeMinutes) break;\n                    const action = actionMap.get(placement.action_id);\n                    if (!action?.est_minutes) continue;\n                    const avoidDates = new Set([\n                        dateStr,\n                        ...Array.from(usedTargetDates)\n                    ]);\n                    const newDate = findNextAvailableDate(placement, new Date(dateStr), window.end_date, capacity, placements, actions, dailyTimeMinutes, avoidDates);\n                    if (newDate) {\n                        placement.due_on = newDate.toISOString().split('T')[0];\n                        placement.planned_due_on = newDate.toISOString().split('T')[0];\n                        remainingTime -= action.est_minutes;\n                        movedPlacements.add(placement.action_id);\n                        usedTargetDates.add(placement.due_on);\n                        hasChanges = true;\n                        console.log(`üìÖ Moved \"${action.title}\" (${action.est_minutes}min) from ${dateStr} to ${newDate.toISOString().split('T')[0]}`);\n                    } else {\n                        // If we can't find a better date, keep the original placement\n                        // This ensures we don't lose any scheduled actions\n                        warnings.push(`Could not balance time budget for ${dateStr} - keeping original placement`);\n                        break;\n                    }\n                }\n            }\n            currentDate.setDate(currentDate.getDate() + 1);\n        }\n        // If no changes were made in this iteration, we're done\n        if (!hasChanges) {\n            break;\n        }\n        // Clear moved placements for next iteration\n        movedPlacements.clear();\n    }\n    if (iteration >= MAX_ITERATIONS) {\n        warnings.push('Maximum balancing iterations reached - some days may still exceed time budget');\n    }\n    return {\n        placements,\n        warnings\n    };\n}\n/**\n * Step 4: Tight fallback escalation\n */ async function tightFallbackEscalation(context, dream, sortedActions, window, capacity, placements, tightPending) {\n    const warnings = [];\n    let tooTight = false;\n    if (tightPending.length === 0) {\n        return {\n            placements,\n            warnings\n        };\n    }\n    // Try escalating per-dream cap to 2/day\n    const escalatedCapacity = {\n        ...capacity\n    };\n    const currentDate = new Date(window.start_date);\n    while(currentDate <= window.end_date){\n        const dateStr = currentDate.toISOString().split('T')[0];\n        const perDreamMap = escalatedCapacity.per_dream_remaining.get(dateStr);\n        if (perDreamMap) {\n            perDreamMap.set(dream.id, 2);\n        }\n        currentDate.setDate(currentDate.getDate() + 1);\n    }\n    // Try to place tight pending actions\n    for (const actionId of tightPending){\n        // Get the actual action from sortedActions\n        const action = sortedActions.find((a)=>a.id === actionId);\n        if (!action) {\n            warnings.push(`Action ${actionId} not found in context`);\n            continue;\n        }\n        const placement = findFeasiblePlacement(action, dream.id, new Date(window.start_date), window.end_date, escalatedCapacity, getEligibleWorkdays(window.start_date, window.end_date));\n        if (placement) {\n            placements.push(placement);\n            warnings.push(`Escalated per-dream cap to 2/day for ${dream.title}`);\n        } else {\n            // Try 3/day as last resort\n            const maxCapacity = {\n                ...escalatedCapacity\n            };\n            const currentDate = new Date(window.start_date);\n            while(currentDate <= window.end_date){\n                const dateStr = currentDate.toISOString().split('T')[0];\n                const perDreamMap = maxCapacity.per_dream_remaining.get(dateStr);\n                if (perDreamMap) {\n                    perDreamMap.set(dream.id, PER_DREAM_CAP_MAX);\n                }\n                currentDate.setDate(currentDate.getDate() + 1);\n            }\n            const maxPlacement = findFeasiblePlacement(action, dream.id, new Date(window.start_date), window.end_date, maxCapacity, getEligibleWorkdays(window.start_date, window.end_date));\n            if (maxPlacement) {\n                placements.push(maxPlacement);\n                warnings.push(`Escalated per-dream cap to 3/day for ${dream.title}`);\n            } else {\n                tooTight = true;\n                warnings.push(`Cannot fit all actions for ${dream.title} within window and caps`);\n            }\n        }\n    }\n    return {\n        placements,\n        warnings,\n        too_tight: tooTight\n    };\n}\n/**\n * Helper function to get eligible workdays (excluding rest days)\n */ function getEligibleWorkdays(startDate, endDate) {\n    const workdays = [];\n    const currentDate = new Date(startDate);\n    while(currentDate <= endDate){\n        const dayOfWeek = currentDate.getDay();\n        if (!REST_DAYS.has(dayOfWeek)) {\n            workdays.push(new Date(currentDate));\n        }\n        currentDate.setDate(currentDate.getDate() + 1);\n    }\n    return workdays;\n}\n/**\n * Helper function to find feasible placement for an action\n */ function findFeasiblePlacement(action, dreamId, minDate, maxDate, capacity, eligibleDays) {\n    console.log(`üîç Finding placement for \"${action.title}\" (min: ${minDate.toISOString().split('T')[0]}, max: ${maxDate.toISOString().split('T')[0]})`);\n    // First pass: Try to find a placement that respects capacity constraints\n    for (const day of eligibleDays){\n        if (day < minDate) continue;\n        if (day > maxDate) break;\n        const dateStr = day.toISOString().split('T')[0];\n        const globalRemaining = capacity.global_remaining.get(dateStr) || 0;\n        const perDreamRemaining = capacity.per_dream_remaining.get(dateStr)?.get(dreamId) || 0;\n        console.log(`  üìÖ ${dateStr}: global=${globalRemaining}, perDream=${perDreamRemaining}`);\n        if (globalRemaining > 0 && perDreamRemaining > 0) {\n            console.log(`  ‚úÖ Found capacity-respecting placement on ${dateStr}`);\n            return {\n                action_id: action.id,\n                dream_id: dreamId,\n                area_id: action.area_id,\n                occurrence_no: 1,\n                planned_due_on: dateStr,\n                due_on: dateStr,\n                is_repeat: false,\n                is_fixed: false\n            };\n        }\n    }\n    // Second pass: If no capacity-respecting placement found, find the earliest possible date\n    // This ensures we ALWAYS schedule the action, even if it breaks capacity rules\n    for (const day of eligibleDays){\n        if (day < minDate) continue;\n        if (day > maxDate) break;\n        const dateStr = day.toISOString().split('T')[0];\n        console.log(`  ‚ö†Ô∏è  Using capacity-breaking placement on ${dateStr} (advisory constraint violated)`);\n        return {\n            action_id: action.id,\n            dream_id: dreamId,\n            area_id: action.area_id,\n            occurrence_no: 1,\n            planned_due_on: dateStr,\n            due_on: dateStr,\n            is_repeat: false,\n            is_fixed: false\n        };\n    }\n    console.log(`  ‚ùå No placement possible within date range for \"${action.title}\"`);\n    return null;\n}\n/**\n * Helper function to find next available date for balancing\n */ function findNextAvailableDate(placement, startDate, maxDate, capacity, allPlacements, actions, dailyTimeMinutes, avoidDates) {\n    const currentDate = new Date(startDate);\n    currentDate.setDate(currentDate.getDate() + 1); // Start from next day\n    // Create action lookup map for time estimation\n    const actionMap = new Map(actions.map((action)=>[\n            action.id,\n            action\n        ]));\n    const currentAction = actionMap.get(placement.action_id);\n    const currentActionTime = currentAction?.est_minutes || 0;\n    // First pass: Try to find a date that respects capacity and, when reasonable, time constraints\n    while(currentDate <= maxDate){\n        const dateStr = currentDate.toISOString().split('T')[0];\n        const dayOfWeek = currentDate.getDay();\n        // Skip rest days\n        if (REST_DAYS.has(dayOfWeek)) {\n            currentDate.setDate(currentDate.getDate() + 1);\n            continue;\n        }\n        const globalRemaining = capacity.global_remaining.get(dateStr) ?? 0;\n        const perDreamRemaining = capacity.per_dream_remaining.get(dateStr)?.get(placement.dream_id) ?? 0;\n        // Capacity is advisory: do not block placement solely due to slot counts\n        // (We still prefer lower-load days in fallback)\n        // Check time constraints if daily time budget is provided\n        // If the single action itself exceeds the daily budget, allow placement (advisory constraint)\n        if (dailyTimeMinutes && currentActionTime > 0 && currentActionTime <= dailyTimeMinutes) {\n            const dayPlacements = allPlacements.filter((p)=>p.due_on === dateStr);\n            let totalDayTime = 0;\n            for (const dayPlacement of dayPlacements){\n                const action = actionMap.get(dayPlacement.action_id);\n                if (action?.est_minutes) {\n                    totalDayTime += action.est_minutes;\n                }\n            }\n            // Check if adding this action would exceed the time budget\n            if (totalDayTime + currentActionTime > dailyTimeMinutes) {\n                currentDate.setDate(currentDate.getDate() + 1);\n                continue;\n            }\n        }\n        if (avoidDates && avoidDates.has(dateStr)) {\n            currentDate.setDate(currentDate.getDate() + 1);\n            continue;\n        }\n        return currentDate;\n    }\n    // Second pass: If no capacity/time-respecting date found, choose earliest among K lightest future days\n    // Priority 1: Minimize number of big actions (> dailyTimeMinutes) on that day\n    // Priority 2: Minimize total scheduled time on that day\n    let bestDate = null;\n    let bestBigCount = Number.POSITIVE_INFINITY;\n    let bestLoad = Number.POSITIVE_INFINITY;\n    const candidates = [];\n    const scanDate = new Date(startDate);\n    scanDate.setDate(scanDate.getDate() + 1);\n    while(scanDate <= maxDate){\n        const dayOfWeek = scanDate.getDay();\n        if (REST_DAYS.has(dayOfWeek)) {\n            scanDate.setDate(scanDate.getDate() + 1);\n            continue;\n        }\n        const dateStr = scanDate.toISOString().split('T')[0];\n        if (avoidDates && avoidDates.has(dateStr)) {\n            scanDate.setDate(scanDate.getDate() + 1);\n            continue;\n        }\n        const dayPlacements = allPlacements.filter((p)=>p.due_on === dateStr);\n        let totalDayTime = 0;\n        let bigCount = 0;\n        for (const dayPlacement of dayPlacements){\n            const action = actionMap.get(dayPlacement.action_id);\n            if (!action) continue;\n            const mins = action.est_minutes || 0;\n            totalDayTime += mins;\n            if (dailyTimeMinutes && mins > dailyTimeMinutes) bigCount++;\n        }\n        candidates.push({\n            date: new Date(scanDate),\n            big: bigCount,\n            load: totalDayTime\n        });\n        scanDate.setDate(scanDate.getDate() + 1);\n    }\n    if (candidates.length > 0) {\n        candidates.sort((a, b)=>{\n            if (a.big !== b.big) return a.big - b.big;\n            if (a.load !== b.load) return a.load - b.load;\n            return a.date.getTime() - b.date.getTime();\n        });\n        // Pick earliest among top-K lightest (K=7) to promote distribution\n        const K = Math.min(7, candidates.length);\n        const choice = candidates.slice(0, K).sort((a, b)=>a.date.getTime() - b.date.getTime())[0];\n        return choice.date;\n    }\n    return null;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QUMsRUFBRTtRQUM1RixPQUFPdUgsT0FBT0osSUFBSTtJQUNwQjtJQUVBLE9BQU87QUFDVCIsInNvdXJjZXMiOlsiL1VzZXJzL2FsZXgvcmVncmV0bGVzcy0zL2JhY2tlbmQvbGliL3NjaGVkdWxpbmcvc2NoZWR1bGVyLnRzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB0eXBlIHsgRHJlYW0sIEFyZWEsIEFjdGlvbiwgQWN0aW9uT2NjdXJyZW5jZSB9IGZyb20gJy4uLy4uL2RhdGFiYXNlL3R5cGVzJ1xuXG4vLyBDb25maWd1cmF0aW9uIGNvbnN0YW50c1xuY29uc3QgVEFSR0VUX1BFUl9XRUVLID0gM1xuY29uc3QgUkVTVF9EQVlTID0gbmV3IFNldChbMF0pIC8vIFN1bmRheSA9IDBcbmNvbnN0IEdMT0JBTF9EQUlMWV9DQVAgPSA1XG5jb25zdCBQRVJfRFJFQU1fQ0FQX0RFRkFVTFQgPSAxXG5jb25zdCBQRVJfRFJFQU1fQ0FQX01BWCA9IDNcbmNvbnN0IE1JTl9HQVBfREFZU19CRVRXRUVOX1NFRURTID0gMVxuY29uc3QgREVGQVVMVF9EQUlMWV9USU1FX01JTlVURVMgPSAzMCAvLyBEZWZhdWx0IGlmIG5vIHRpbWUgY29tbWl0bWVudCBzcGVjaWZpZWRcblxuLy8gVHlwZXMgZm9yIHNjaGVkdWxpbmdcbmludGVyZmFjZSBTY2hlZHVsaW5nQ29udGV4dCB7XG4gIHVzZXJfaWQ6IHN0cmluZ1xuICB0aW1lem9uZTogc3RyaW5nXG59XG5cbmludGVyZmFjZSBTY2hlZHVsaW5nUmVzdWx0IHtcbiAgc3VjY2VzczogYm9vbGVhblxuICBvY2N1cnJlbmNlczogQWN0aW9uT2NjdXJyZW5jZVtdXG4gIGVycm9yczogc3RyaW5nW11cbiAgd2FybmluZ3M6IHN0cmluZ1tdXG4gIGF1dG9fY29tcGFjdGVkPzogYm9vbGVhblxuICB0b29fdGlnaHQ/OiBib29sZWFuXG4gIHJlY29tbWVuZGVkX2VuZD86IHN0cmluZ1xufVxuXG5pbnRlcmZhY2UgQ2FwYWNpdHlUcmFja2VyIHtcbiAgZ2xvYmFsX3JlbWFpbmluZzogTWFwPHN0cmluZywgbnVtYmVyPiAvLyBkYXRlIC0+IHJlbWFpbmluZyBzbG90c1xuICBwZXJfZHJlYW1fcmVtYWluaW5nOiBNYXA8c3RyaW5nLCBNYXA8c3RyaW5nLCBudW1iZXI+PiAvLyBkYXRlIC0+IGRyZWFtX2lkIC0+IHJlbWFpbmluZyBzbG90c1xufVxuXG5pbnRlcmZhY2UgU2NoZWR1bGVkUGxhY2VtZW50IHtcbiAgYWN0aW9uX2lkOiBzdHJpbmdcbiAgZHJlYW1faWQ6IHN0cmluZ1xuICBhcmVhX2lkOiBzdHJpbmdcbiAgb2NjdXJyZW5jZV9ubzogbnVtYmVyXG4gIHBsYW5uZWRfZHVlX29uOiBzdHJpbmdcbiAgZHVlX29uOiBzdHJpbmdcbiAgaXNfcmVwZWF0OiBib29sZWFuXG4gIGlzX2ZpeGVkOiBib29sZWFuIC8vIHRydWUgZm9yIHJlcGVhdHMgdGhhdCBjYW4ndCBiZSBtb3ZlZFxufVxuXG5pbnRlcmZhY2UgRHJlYW1TY2hlZHVsaW5nRGF0YSB7XG4gIGRyZWFtOiBEcmVhbVxuICBhcmVhczogQXJlYVtdXG4gIGFjdGlvbnM6IEFjdGlvbltdXG4gIGV4aXN0aW5nX29jY3VycmVuY2VzOiBBY3Rpb25PY2N1cnJlbmNlW11cbn1cblxuLyoqXG4gKiBNYWluIHNjaGVkdWxpbmcgZnVuY3Rpb24gdGhhdCBjcmVhdGVzIGFjdGlvbiBvY2N1cnJlbmNlcyBmb3IgYSBkcmVhbVxuICovXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gc2NoZWR1bGVEcmVhbUFjdGlvbnMoXG4gIGNvbnRleHQ6IFNjaGVkdWxpbmdDb250ZXh0LFxuICBkcmVhbURhdGE6IERyZWFtU2NoZWR1bGluZ0RhdGFcbik6IFByb21pc2U8U2NoZWR1bGluZ1Jlc3VsdD4ge1xuICBjb25zdCB7IGRyZWFtLCBhcmVhcywgYWN0aW9ucywgZXhpc3Rpbmdfb2NjdXJyZW5jZXMgfSA9IGRyZWFtRGF0YVxuICBcbiAgY29uc29sZS5sb2coJ/Cfjq8gU3RhcnRpbmcgc2NoZWR1bGluZyBmb3IgZHJlYW06JywgZHJlYW0udGl0bGUpXG4gIGNvbnNvbGUubG9nKCfwn5OKIElucHV0IGRhdGE6Jywge1xuICAgIGFyZWFzQ291bnQ6IGFyZWFzLmxlbmd0aCxcbiAgICBhY3Rpb25zQ291bnQ6IGFjdGlvbnMubGVuZ3RoLFxuICAgIGV4aXN0aW5nT2NjdXJyZW5jZXNDb3VudDogZXhpc3Rpbmdfb2NjdXJyZW5jZXMubGVuZ3RoXG4gIH0pXG4gIFxuICB0cnkge1xuICAgIC8vIFN0ZXAgMTogQ2FsY3VsYXRlIHNjaGVkdWxpbmcgd2luZG93XG4gICAgY29uc3Qgd2luZG93ID0gY2FsY3VsYXRlU2NoZWR1bGluZ1dpbmRvdyhkcmVhbSwgYWN0aW9ucylcbiAgICBjb25zb2xlLmxvZygn8J+ThSBTY2hlZHVsaW5nIHdpbmRvdzonLCB7XG4gICAgICBzdGFydDogd2luZG93LnN0YXJ0X2RhdGUudG9JU09TdHJpbmcoKS5zcGxpdCgnVCcpWzBdLFxuICAgICAgZW5kOiB3aW5kb3cuZW5kX2RhdGUudG9JU09TdHJpbmcoKS5zcGxpdCgnVCcpWzBdLFxuICAgICAgYXV0b0NvbXBhY3RlZDogd2luZG93LmF1dG9fY29tcGFjdGVkXG4gICAgfSlcbiAgICBcbiAgICAvLyBTdGVwIDI6IEJ1aWxkIGNhcGFjaXR5IHRyYWNrZXJcbiAgICBjb25zdCBjYXBhY2l0eSA9IGJ1aWxkQ2FwYWNpdHlUcmFja2VyKHdpbmRvdy5zdGFydF9kYXRlLCB3aW5kb3cuZW5kX2RhdGUsIGRyZWFtLnRpbWVfY29tbWl0bWVudClcbiAgICBjb25zb2xlLmxvZygn8J+TiiBDYXBhY2l0eSB0cmFja2VyIGluaXRpYWxpemVkOicsIHtcbiAgICAgIHRvdGFsRGF5czogY2FwYWNpdHkuZ2xvYmFsX3JlbWFpbmluZy5zaXplLFxuICAgICAgc2FtcGxlRGF5OiBBcnJheS5mcm9tKGNhcGFjaXR5Lmdsb2JhbF9yZW1haW5pbmcuZW50cmllcygpKVswXVxuICAgIH0pXG4gICAgXG4gICAgLy8gU3RlcCAzOiBTb3J0IGFjdGlvbnMgYnkgcG9zaXRpb24gKGFyZWEucG9zaXRpb24sIGFjdGlvbi5wb3NpdGlvbilcbiAgICBjb25zdCBzb3J0ZWRBY3Rpb25zID0gc29ydEFjdGlvbnNCeVBvc2l0aW9uKGFjdGlvbnMsIGFyZWFzKVxuICAgIGNvbnNvbGUubG9nKCfwn5OLIEFyZWFzIHdpdGggcG9zaXRpb25zOicsIGFyZWFzLm1hcChhID0+IGAke2EudGl0bGV9IChhcmVhIHBvczogJHthLnBvc2l0aW9ufSlgKSlcbiAgICBjb25zb2xlLmxvZygn8J+TiyBTb3J0ZWQgYWN0aW9uczonLCBzb3J0ZWRBY3Rpb25zLm1hcChhID0+IHtcbiAgICAgIGNvbnN0IGFyZWEgPSBhcmVhcy5maW5kKGFyZWEgPT4gYXJlYS5pZCA9PT0gYS5hcmVhX2lkKVxuICAgICAgcmV0dXJuIGAke2EudGl0bGV9IChhcmVhIHBvczogJHthcmVhPy5wb3NpdGlvbiB8fCAndW5rbm93bid9LCBhY3Rpb24gcG9zOiAke2EucG9zaXRpb259KWBcbiAgICB9KSlcbiAgICBcbiAgICAvLyBTdGVwIDQ6IFNlZWQgYWxsIGFjdGlvbnMgKFN0ZXAgMSBvZiBhbGdvcml0aG0pXG4gICAgY29uc3Qgc2VlZFJlc3VsdHMgPSBhd2FpdCBzZWVkQWxsQWN0aW9ucyhcbiAgICAgIGNvbnRleHQsXG4gICAgICBkcmVhbSxcbiAgICAgIHNvcnRlZEFjdGlvbnMsXG4gICAgICBhcmVhcyxcbiAgICAgIHdpbmRvdyxcbiAgICAgIGNhcGFjaXR5LFxuICAgICAgZXhpc3Rpbmdfb2NjdXJyZW5jZXNcbiAgICApXG4gICAgXG4gICAgY29uc29sZS5sb2coJ/CfjLEgU2VlZCByZXN1bHRzOicsIHtcbiAgICAgIHBsYWNlbWVudHNDb3VudDogc2VlZFJlc3VsdHMucGxhY2VtZW50cy5sZW5ndGgsXG4gICAgICB0aWdodFBlbmRpbmdDb3VudDogc2VlZFJlc3VsdHMudGlnaHRfcGVuZGluZy5sZW5ndGhcbiAgICB9KVxuICAgIFxuICAgIC8vIFN0ZXAgNTogRXhwYW5kIHJlcGVhdHMgKFN0ZXAgMiBvZiBhbGdvcml0aG0pXG4gICAgY29uc3QgcmVwZWF0UmVzdWx0cyA9IGF3YWl0IGV4cGFuZFJlcGVhdHMoXG4gICAgICBjb250ZXh0LFxuICAgICAgZHJlYW0sXG4gICAgICBzb3J0ZWRBY3Rpb25zLFxuICAgICAgd2luZG93LFxuICAgICAgY2FwYWNpdHksXG4gICAgICBzZWVkUmVzdWx0cy5wbGFjZW1lbnRzIHx8IFtdXG4gICAgKVxuICAgIFxuICAgIC8vIFN0ZXAgNjogR2xvYmFsIGJhbGFuY2luZyAoU3RlcCAzIG9mIGFsZ29yaXRobSlcbiAgICBjb25zdCBiYWxhbmNlZFJlc3VsdHMgPSBhd2FpdCBnbG9iYWxCYWxhbmNpbmcoXG4gICAgICBjb250ZXh0LFxuICAgICAgZHJlYW0sXG4gICAgICB3aW5kb3csXG4gICAgICBjYXBhY2l0eSxcbiAgICAgIFsuLi4oc2VlZFJlc3VsdHMucGxhY2VtZW50cyB8fCBbXSksIC4uLihyZXBlYXRSZXN1bHRzLnBsYWNlbWVudHMgfHwgW10pXSxcbiAgICAgIHNvcnRlZEFjdGlvbnNcbiAgICApXG4gICAgXG4gICAgLy8gU3RlcCA3OiBUaWdodCBmYWxsYmFjayBlc2NhbGF0aW9uIChTdGVwIDQgb2YgYWxnb3JpdGhtKVxuICAgIGNvbnN0IGZpbmFsUmVzdWx0cyA9IGF3YWl0IHRpZ2h0RmFsbGJhY2tFc2NhbGF0aW9uKFxuICAgICAgY29udGV4dCxcbiAgICAgIGRyZWFtLFxuICAgICAgc29ydGVkQWN0aW9ucyxcbiAgICAgIHdpbmRvdyxcbiAgICAgIGNhcGFjaXR5LFxuICAgICAgYmFsYW5jZWRSZXN1bHRzLnBsYWNlbWVudHMgfHwgW10sXG4gICAgICBzZWVkUmVzdWx0cy50aWdodF9wZW5kaW5nIHx8IFtdXG4gICAgKVxuICAgIFxuICAgIC8vIFN0ZXAgODogQ29udmVydCB0byBBY3Rpb25PY2N1cnJlbmNlIGZvcm1hdFxuICAgIGNvbnN0IG9jY3VycmVuY2VzID0gKGZpbmFsUmVzdWx0cy5wbGFjZW1lbnRzIHx8IFtdKS5tYXAocGxhY2VtZW50ID0+ICh7XG4gICAgICBpZDogJycsIC8vIFdpbGwgYmUgZ2VuZXJhdGVkIGJ5IGRhdGFiYXNlXG4gICAgICBhY3Rpb25faWQ6IHBsYWNlbWVudC5hY3Rpb25faWQsXG4gICAgICBhcmVhX2lkOiBwbGFjZW1lbnQuYXJlYV9pZCxcbiAgICAgIG9jY3VycmVuY2Vfbm86IHBsYWNlbWVudC5vY2N1cnJlbmNlX25vLFxuICAgICAgcGxhbm5lZF9kdWVfb246IHBsYWNlbWVudC5wbGFubmVkX2R1ZV9vbixcbiAgICAgIGR1ZV9vbjogcGxhY2VtZW50LmR1ZV9vbixcbiAgICAgIGRlZmVyX2NvdW50OiAwLFxuICAgICAgbm90ZTogdW5kZWZpbmVkLFxuICAgICAgY29tcGxldGVkX2F0OiB1bmRlZmluZWQsXG4gICAgICBhaV9yYXRpbmc6IHVuZGVmaW5lZCxcbiAgICAgIGFpX2ZlZWRiYWNrOiB1bmRlZmluZWQsXG4gICAgICBjcmVhdGVkX2F0OiBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKCksXG4gICAgICB1cGRhdGVkX2F0OiBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKClcbiAgICB9KSlcbiAgICBcbiAgICBjb25zb2xlLmxvZygn4pyFIFNjaGVkdWxpbmcgY29tcGxldGVkOicsIHtcbiAgICAgIHRvdGFsT2NjdXJyZW5jZXM6IG9jY3VycmVuY2VzLmxlbmd0aCxcbiAgICAgIGF1dG9Db21wYWN0ZWQ6IHdpbmRvdy5hdXRvX2NvbXBhY3RlZCxcbiAgICAgIHRvb1RpZ2h0OiBmaW5hbFJlc3VsdHMudG9vX3RpZ2h0LFxuICAgICAgd2FybmluZ3M6IGZpbmFsUmVzdWx0cy53YXJuaW5ncy5sZW5ndGhcbiAgICB9KVxuICAgIFxuICAgIHJldHVybiB7XG4gICAgICBzdWNjZXNzOiB0cnVlLFxuICAgICAgb2NjdXJyZW5jZXMsXG4gICAgICBlcnJvcnM6IFtdLFxuICAgICAgd2FybmluZ3M6IGZpbmFsUmVzdWx0cy53YXJuaW5ncyxcbiAgICAgIGF1dG9fY29tcGFjdGVkOiB3aW5kb3cuYXV0b19jb21wYWN0ZWQsXG4gICAgICB0b29fdGlnaHQ6IGZpbmFsUmVzdWx0cy50b29fdGlnaHQsXG4gICAgICByZWNvbW1lbmRlZF9lbmQ6IHdpbmRvdy5yZWNvbW1lbmRlZF9lbmRcbiAgICB9XG4gICAgXG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgY29uc29sZS5lcnJvcign4p2MIFNjaGVkdWxpbmcgZXJyb3I6JywgZXJyb3IpXG4gICAgcmV0dXJuIHtcbiAgICAgIHN1Y2Nlc3M6IGZhbHNlLFxuICAgICAgb2NjdXJyZW5jZXM6IFtdLFxuICAgICAgZXJyb3JzOiBbZXJyb3IgaW5zdGFuY2VvZiBFcnJvciA/IGVycm9yLm1lc3NhZ2UgOiAnVW5rbm93biBzY2hlZHVsaW5nIGVycm9yJ10sXG4gICAgICB3YXJuaW5nczogW11cbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBDYWxjdWxhdGUgdGhlIHNjaGVkdWxpbmcgd2luZG93IGZvciBhIGRyZWFtXG4gKi9cbmZ1bmN0aW9uIGNhbGN1bGF0ZVNjaGVkdWxpbmdXaW5kb3coZHJlYW06IERyZWFtLCBhY3Rpb25zOiBBY3Rpb25bXSkge1xuICBjb25zdCBzdGFydERhdGUgPSBuZXcgRGF0ZShkcmVhbS5zdGFydF9kYXRlKVxuICBjb25zdCBlbmREYXRlID0gZHJlYW0uZW5kX2RhdGUgPyBuZXcgRGF0ZShkcmVhbS5lbmRfZGF0ZSkgOiBudWxsXG4gIFxuICAvLyBDb3VudCBzZWVkYWJsZSBhY3Rpb25zIChvbmUtb2ZmcyArIGZpcnN0IG9jY3VycmVuY2Ugb2YgZWFjaCByZXBlYXRlcilcbiAgY29uc3Qgc2VlZGFibGVBY3Rpb25zID0gYWN0aW9ucy5maWx0ZXIoYWN0aW9uID0+IFxuICAgIGFjdGlvbi5pc19hY3RpdmUgJiYgIWFjdGlvbi5kZWxldGVkX2F0XG4gICkubGVuZ3RoXG4gIFxuICAvLyBDYWxjdWxhdGUgcmVjb21tZW5kZWQgZW5kIGRhdGUgYmFzZWQgb24gdGltZSBjb21taXRtZW50XG4gIGNvbnN0IHRpbWVDb21taXRtZW50ID0gZHJlYW0udGltZV9jb21taXRtZW50XG4gIGNvbnN0IGRhaWx5VGltZU1pbnV0ZXMgPSB0aW1lQ29tbWl0bWVudCBcbiAgICA/IHRpbWVDb21taXRtZW50LmhvdXJzICogNjAgKyB0aW1lQ29tbWl0bWVudC5taW51dGVzIFxuICAgIDogREVGQVVMVF9EQUlMWV9USU1FX01JTlVURVNcbiAgXG4gIC8vIENhbGN1bGF0ZSB0b3RhbCB0aW1lIG5lZWRlZCBmb3IgYWxsIGFjdGlvbnNcbiAgbGV0IHRvdGFsVGltZU5lZWRlZCA9IDBcbiAgZm9yIChjb25zdCBhY3Rpb24gb2YgYWN0aW9ucykge1xuICAgIGlmIChhY3Rpb24uaXNfYWN0aXZlICYmICFhY3Rpb24uZGVsZXRlZF9hdCAmJiBhY3Rpb24uZXN0X21pbnV0ZXMpIHtcbiAgICAgIGlmIChhY3Rpb24uc2xpY2VfY291bnRfdGFyZ2V0KSB7XG4gICAgICAgIC8vIEZpbml0ZSBzZXJpZXM6IHRvdGFsIHRpbWUgPSBlc3RfbWludXRlcyAqIHNsaWNlX2NvdW50X3RhcmdldFxuICAgICAgICB0b3RhbFRpbWVOZWVkZWQgKz0gYWN0aW9uLmVzdF9taW51dGVzICogYWN0aW9uLnNsaWNlX2NvdW50X3RhcmdldFxuICAgICAgfSBlbHNlIGlmIChhY3Rpb24ucmVwZWF0X2V2ZXJ5X2RheXMpIHtcbiAgICAgICAgLy8gSGFiaXQ6IGVzdGltYXRlIGJhc2VkIG9uIHdpbmRvdyBsZW5ndGggYW5kIHJlcGVhdCBmcmVxdWVuY3lcbiAgICAgICAgY29uc3Qgd2luZG93RGF5cyA9IE1hdGguY2VpbCgoZW5kRGF0ZT8uZ2V0VGltZSgpIHx8IERhdGUubm93KCkpIC0gc3RhcnREYXRlLmdldFRpbWUoKSkgLyAoMTAwMCAqIDYwICogNjAgKiAyNClcbiAgICAgICAgY29uc3Qgd29ya0RheXMgPSBNYXRoLmZsb29yKHdpbmRvd0RheXMgKiA2IC8gNykgLy8gUm91Z2ggZXN0aW1hdGUgZXhjbHVkaW5nIFN1bmRheXNcbiAgICAgICAgY29uc3Qgb2NjdXJyZW5jZXMgPSBNYXRoLm1heCgxLCBNYXRoLmZsb29yKHdvcmtEYXlzIC8gYWN0aW9uLnJlcGVhdF9ldmVyeV9kYXlzKSlcbiAgICAgICAgdG90YWxUaW1lTmVlZGVkICs9IGFjdGlvbi5lc3RfbWludXRlcyAqIG9jY3VycmVuY2VzXG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBPbmUtb2ZmIGFjdGlvblxuICAgICAgICB0b3RhbFRpbWVOZWVkZWQgKz0gYWN0aW9uLmVzdF9taW51dGVzXG4gICAgICB9XG4gICAgfVxuICB9XG4gIFxuICAvLyBDYWxjdWxhdGUgd2Vla3MgbmVlZGVkIGJhc2VkIG9uIHRpbWUgY29tbWl0bWVudFxuICBjb25zdCB3b3JrRGF5c1BlcldlZWsgPSA2IC8vIEV4Y2x1ZGluZyBTdW5kYXlzXG4gIGNvbnN0IHdlZWtseVRpbWVNaW51dGVzID0gZGFpbHlUaW1lTWludXRlcyAqIHdvcmtEYXlzUGVyV2Vla1xuICBjb25zdCB3ZWVrc05lZWRlZCA9IE1hdGgubWF4KDEsIE1hdGguY2VpbCh0b3RhbFRpbWVOZWVkZWQgLyB3ZWVrbHlUaW1lTWludXRlcykpXG4gIFxuICBjb25zdCByZWNvbW1lbmRlZEVuZCA9IG5ldyBEYXRlKHN0YXJ0RGF0ZSlcbiAgcmVjb21tZW5kZWRFbmQuc2V0RGF0ZShzdGFydERhdGUuZ2V0RGF0ZSgpICsgKHdlZWtzTmVlZGVkICogNykgLSAxKVxuICBcbiAgLy8gV2luZG93IGVuZCBpcyB0aGUgZWFybGllciBvZiBlbmRfZGF0ZSBvciByZWNvbW1lbmRlZF9lbmRcbiAgY29uc3Qgd2luZG93RW5kID0gZW5kRGF0ZSAmJiBlbmREYXRlIDwgcmVjb21tZW5kZWRFbmQgPyBlbmREYXRlIDogcmVjb21tZW5kZWRFbmRcbiAgY29uc3QgYXV0b0NvbXBhY3RlZCA9ICFlbmREYXRlIHx8IGVuZERhdGUgPiByZWNvbW1lbmRlZEVuZFxuICBcbiAgY29uc29sZS5sb2coJ+KPsCBUaW1lLWJhc2VkIHNjaGVkdWxpbmcgY2FsY3VsYXRpb246Jywge1xuICAgIGRhaWx5VGltZU1pbnV0ZXMsXG4gICAgdG90YWxUaW1lTmVlZGVkLFxuICAgIHdlZWtseVRpbWVNaW51dGVzLFxuICAgIHdlZWtzTmVlZGVkLFxuICAgIHJlY29tbWVuZGVkRW5kOiByZWNvbW1lbmRlZEVuZC50b0lTT1N0cmluZygpLnNwbGl0KCdUJylbMF1cbiAgfSlcbiAgXG4gIHJldHVybiB7XG4gICAgc3RhcnRfZGF0ZTogc3RhcnREYXRlLFxuICAgIGVuZF9kYXRlOiB3aW5kb3dFbmQsXG4gICAgcmVjb21tZW5kZWRfZW5kOiByZWNvbW1lbmRlZEVuZC50b0lTT1N0cmluZygpLnNwbGl0KCdUJylbMF0sXG4gICAgYXV0b19jb21wYWN0ZWQ6IGF1dG9Db21wYWN0ZWRcbiAgfVxufVxuXG4vKipcbiAqIEJ1aWxkIGNhcGFjaXR5IHRyYWNrZXIgZm9yIHRoZSBzY2hlZHVsaW5nIHdpbmRvd1xuICovXG5mdW5jdGlvbiBidWlsZENhcGFjaXR5VHJhY2tlcihzdGFydERhdGU6IERhdGUsIGVuZERhdGU6IERhdGUsIHRpbWVDb21taXRtZW50PzogeyBob3VyczogbnVtYmVyOyBtaW51dGVzOiBudW1iZXIgfSk6IENhcGFjaXR5VHJhY2tlciB7XG4gIGNvbnN0IGdsb2JhbFJlbWFpbmluZyA9IG5ldyBNYXA8c3RyaW5nLCBudW1iZXI+KClcbiAgY29uc3QgcGVyRHJlYW1SZW1haW5pbmcgPSBuZXcgTWFwPHN0cmluZywgTWFwPHN0cmluZywgbnVtYmVyPj4oKVxuICBcbiAgLy8gQ2FsY3VsYXRlIGRhaWx5IHRpbWUgYnVkZ2V0XG4gIGNvbnN0IGRhaWx5VGltZU1pbnV0ZXMgPSB0aW1lQ29tbWl0bWVudCBcbiAgICA/IHRpbWVDb21taXRtZW50LmhvdXJzICogNjAgKyB0aW1lQ29tbWl0bWVudC5taW51dGVzIFxuICAgIDogREVGQVVMVF9EQUlMWV9USU1FX01JTlVURVNcbiAgXG4gIC8vIENhbGN1bGF0ZSB0aW1lLWJhc2VkIGNhcGFjaXR5IChlc3RpbWF0ZSBhY3Rpb25zIHRoYXQgY2FuIGZpdCBpbiBkYWlseSB0aW1lKVxuICAvLyBVc2UgYSBjb25zZXJ2YXRpdmUgZXN0aW1hdGU6IGFzc3VtZSBhdmVyYWdlIGFjdGlvbiB0YWtlcyA0NSBtaW51dGVzXG4gIC8vIFRoaXMgZ2l2ZXMgdXMgYSByZWFzb25hYmxlIGNhcCB0aGF0IHJlc3BlY3RzIHRpbWUgY29tbWl0bWVudFxuICBjb25zdCBlc3RpbWF0ZWRUaW1lUGVyQWN0aW9uID0gNDUgLy8gbWludXRlc1xuICBjb25zdCB0aW1lQmFzZWREYWlseUNhcCA9IE1hdGgubWF4KDEsIE1hdGguZmxvb3IoZGFpbHlUaW1lTWludXRlcyAvIGVzdGltYXRlZFRpbWVQZXJBY3Rpb24pKVxuICBcbiAgLy8gVXNlIHRoZSBzbWFsbGVyIG9mIHRpbWUtYmFzZWQgY2FwIG9yIGdsb2JhbCBjYXAgdG8gcmVzcGVjdCBib3RoIGNvbnN0cmFpbnRzXG4gIGNvbnN0IGVmZmVjdGl2ZURhaWx5Q2FwID0gTWF0aC5taW4odGltZUJhc2VkRGFpbHlDYXAsIEdMT0JBTF9EQUlMWV9DQVApXG4gIFxuICBjb25zb2xlLmxvZygn8J+TiiBDYXBhY2l0eSBjYWxjdWxhdGlvbjonLCB7XG4gICAgZGFpbHlUaW1lTWludXRlcyxcbiAgICB0aW1lQmFzZWREYWlseUNhcCxcbiAgICBlZmZlY3RpdmVEYWlseUNhcCxcbiAgICBnbG9iYWxDYXA6IEdMT0JBTF9EQUlMWV9DQVBcbiAgfSlcbiAgXG4gIGNvbnN0IGN1cnJlbnREYXRlID0gbmV3IERhdGUoc3RhcnREYXRlKVxuICB3aGlsZSAoY3VycmVudERhdGUgPD0gZW5kRGF0ZSkge1xuICAgIGNvbnN0IGRhdGVTdHIgPSBjdXJyZW50RGF0ZS50b0lTT1N0cmluZygpLnNwbGl0KCdUJylbMF1cbiAgICBjb25zdCBkYXlPZldlZWsgPSBjdXJyZW50RGF0ZS5nZXREYXkoKVxuICAgIFxuICAgIC8vIENoZWNrIGlmIGl0J3MgYSByZXN0IGRheVxuICAgIGlmIChSRVNUX0RBWVMuaGFzKGRheU9mV2VlaykpIHtcbiAgICAgIGdsb2JhbFJlbWFpbmluZy5zZXQoZGF0ZVN0ciwgMClcbiAgICB9IGVsc2Uge1xuICAgICAgZ2xvYmFsUmVtYWluaW5nLnNldChkYXRlU3RyLCBlZmZlY3RpdmVEYWlseUNhcClcbiAgICB9XG4gICAgXG4gICAgcGVyRHJlYW1SZW1haW5pbmcuc2V0KGRhdGVTdHIsIG5ldyBNYXAoKSlcbiAgICBcbiAgICBjdXJyZW50RGF0ZS5zZXREYXRlKGN1cnJlbnREYXRlLmdldERhdGUoKSArIDEpXG4gIH1cbiAgXG4gIHJldHVybiB7XG4gICAgZ2xvYmFsX3JlbWFpbmluZzogZ2xvYmFsUmVtYWluaW5nLFxuICAgIHBlcl9kcmVhbV9yZW1haW5pbmc6IHBlckRyZWFtUmVtYWluaW5nXG4gIH1cbn1cblxuLyoqXG4gKiBTb3J0IGFjdGlvbnMgYnkgYXJlYSBwb3NpdGlvbiwgdGhlbiBhY3Rpb24gcG9zaXRpb25cbiAqL1xuZnVuY3Rpb24gc29ydEFjdGlvbnNCeVBvc2l0aW9uKGFjdGlvbnM6IEFjdGlvbltdLCBhcmVhczogQXJlYVtdKTogQWN0aW9uW10ge1xuICBjb25zdCBhcmVhUG9zaXRpb25NYXAgPSBuZXcgTWFwKGFyZWFzLm1hcChhcmVhID0+IFthcmVhLmlkLCBhcmVhLnBvc2l0aW9uXSkpXG4gIFxuICByZXR1cm4gYWN0aW9uc1xuICAgIC5maWx0ZXIoYWN0aW9uID0+IGFjdGlvbi5pc19hY3RpdmUgJiYgIWFjdGlvbi5kZWxldGVkX2F0KVxuICAgIC5zb3J0KChhLCBiKSA9PiB7XG4gICAgICBjb25zdCBhQXJlYVBvcyA9IGFyZWFQb3NpdGlvbk1hcC5nZXQoYS5hcmVhX2lkKSB8fCAwXG4gICAgICBjb25zdCBiQXJlYVBvcyA9IGFyZWFQb3NpdGlvbk1hcC5nZXQoYi5hcmVhX2lkKSB8fCAwXG4gICAgICBcbiAgICAgIGlmIChhQXJlYVBvcyAhPT0gYkFyZWFQb3MpIHtcbiAgICAgICAgcmV0dXJuIGFBcmVhUG9zIC0gYkFyZWFQb3NcbiAgICAgIH1cbiAgICAgIFxuICAgICAgcmV0dXJuIGEucG9zaXRpb24gLSBiLnBvc2l0aW9uXG4gICAgfSlcbn1cblxuLyoqXG4gKiBTdGVwIDE6IFNlZWQgYWxsIGFjdGlvbnMgaW4gb3JkZXJcbiAqL1xuYXN5bmMgZnVuY3Rpb24gc2VlZEFsbEFjdGlvbnMoXG4gIGNvbnRleHQ6IFNjaGVkdWxpbmdDb250ZXh0LFxuICBkcmVhbTogRHJlYW0sXG4gIHNvcnRlZEFjdGlvbnM6IEFjdGlvbltdLFxuICBhcmVhczogQXJlYVtdLFxuICB3aW5kb3c6IHsgc3RhcnRfZGF0ZTogRGF0ZTsgZW5kX2RhdGU6IERhdGU7IGF1dG9fY29tcGFjdGVkOiBib29sZWFuIH0sXG4gIGNhcGFjaXR5OiBDYXBhY2l0eVRyYWNrZXIsXG4gIGV4aXN0aW5nT2NjdXJyZW5jZXM6IEFjdGlvbk9jY3VycmVuY2VbXVxuKTogUHJvbWlzZTx7IHBsYWNlbWVudHM6IFNjaGVkdWxlZFBsYWNlbWVudFtdOyB0aWdodF9wZW5kaW5nOiBzdHJpbmdbXSB9PiB7XG4gIGNvbnN0IHBsYWNlbWVudHM6IFNjaGVkdWxlZFBsYWNlbWVudFtdID0gW11cbiAgY29uc3QgdGlnaHRQZW5kaW5nOiBzdHJpbmdbXSA9IFtdXG4gIFxuICAvLyBDb21wdXRlIGRhaWx5IHRpbWUgYnVkZ2V0IGZvciBvdmVyc2l6ZWQgZGV0ZWN0aW9uXG4gIGNvbnN0IGRhaWx5VGltZU1pbnV0ZXMgPSBkcmVhbS50aW1lX2NvbW1pdG1lbnQgXG4gICAgPyBkcmVhbS50aW1lX2NvbW1pdG1lbnQuaG91cnMgKiA2MCArIGRyZWFtLnRpbWVfY29tbWl0bWVudC5taW51dGVzIFxuICAgIDogREVGQVVMVF9EQUlMWV9USU1FX01JTlVURVNcbiAgXG4gIC8vIEdldCBlbGlnaWJsZSB3b3JrZGF5c1xuICBjb25zdCBlbGlnaWJsZURheXMgPSBnZXRFbGlnaWJsZVdvcmtkYXlzKHdpbmRvdy5zdGFydF9kYXRlLCB3aW5kb3cuZW5kX2RhdGUpXG4gIFxuICBjb25zb2xlLmxvZygn8J+ThSBFbGlnaWJsZSB3b3JrZGF5czonLCB7XG4gICAgdG90YWxEYXlzOiBlbGlnaWJsZURheXMubGVuZ3RoLFxuICAgIGZpcnN0RGF5OiBlbGlnaWJsZURheXNbMF0/LnRvSVNPU3RyaW5nKCkuc3BsaXQoJ1QnKVswXSxcbiAgICBsYXN0RGF5OiBlbGlnaWJsZURheXNbZWxpZ2libGVEYXlzLmxlbmd0aCAtIDFdPy50b0lTT1N0cmluZygpLnNwbGl0KCdUJylbMF1cbiAgfSlcbiAgXG4gIC8vIENhbGN1bGF0ZSB0b3RhbCBvY2N1cnJlbmNlcyBuZWVkZWQgdXBmcm9udFxuICBsZXQgdG90YWxPY2N1cnJlbmNlcyA9IDBcbiAgY29uc3QgYWN0aW9uT2NjdXJyZW5jZUNvdW50cyA9IG5ldyBNYXA8c3RyaW5nLCBudW1iZXI+KClcbiAgXG4gIGZvciAoY29uc3QgYWN0aW9uIG9mIHNvcnRlZEFjdGlvbnMpIHtcbiAgICBsZXQgY291bnQgPSAxIC8vIERlZmF1bHQgdG8gMSBvY2N1cnJlbmNlXG4gICAgaWYgKGFjdGlvbi5yZXBlYXRfZXZlcnlfZGF5cykge1xuICAgICAgLy8gRm9yIGhhYml0cywgb25seSBzZWVkIHRoZSBGSVJTVCBvY2N1cnJlbmNlLiBPbmdvaW5nIHJlcGVhdHMgYXJlIGhhbmRsZWQgaW4gZXhwYW5kUmVwZWF0cy5cbiAgICAgIGNvdW50ID0gMVxuICAgIH0gZWxzZSBpZiAoYWN0aW9uLnNsaWNlX2NvdW50X3RhcmdldCAmJiBhY3Rpb24uc2xpY2VfY291bnRfdGFyZ2V0ID4gMSkge1xuICAgICAgY291bnQgPSBhY3Rpb24uc2xpY2VfY291bnRfdGFyZ2V0XG4gICAgfVxuICAgIGFjdGlvbk9jY3VycmVuY2VDb3VudHMuc2V0KGFjdGlvbi5pZCwgY291bnQpXG4gICAgdG90YWxPY2N1cnJlbmNlcyArPSBjb3VudFxuICB9XG4gIFxuICBjb25zb2xlLmxvZyhg8J+TiiBUb3RhbCBvY2N1cnJlbmNlcyBuZWVkZWQ6ICR7dG90YWxPY2N1cnJlbmNlc30gYWNyb3NzICR7ZWxpZ2libGVEYXlzLmxlbmd0aH0gd29ya2RheXNgKVxuICBjb25zb2xlLmxvZyhg8J+TiiBBdmVyYWdlIGxvYWQ6ICR7KHRvdGFsT2NjdXJyZW5jZXMgLyBlbGlnaWJsZURheXMubGVuZ3RoKS50b0ZpeGVkKDIpfSBvY2N1cnJlbmNlcyBwZXIgZGF5YClcbiAgXG4gIC8vIENhbGN1bGF0ZSB0YXJnZXQgZGF5IGluZGljZXMgZm9yIGV2ZW4gZGlzdHJpYnV0aW9uXG4gIGNvbnN0IHRhcmdldERheUluZGljZXM6IG51bWJlcltdID0gW11cbiAgbGV0IG9jY3VycmVuY2VJbmRleCA9IDBcbiAgXG4gIGZvciAoY29uc3QgYWN0aW9uIG9mIHNvcnRlZEFjdGlvbnMpIHtcbiAgICBjb25zdCBjb3VudCA9IGFjdGlvbk9jY3VycmVuY2VDb3VudHMuZ2V0KGFjdGlvbi5pZCkgfHwgMVxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY291bnQ7IGkrKykge1xuICAgICAgY29uc3QgdGFyZ2V0SW5kZXggPSBNYXRoLnJvdW5kKChvY2N1cnJlbmNlSW5kZXggKyAwLjUpICogKGVsaWdpYmxlRGF5cy5sZW5ndGggLSAxKSAvICh0b3RhbE9jY3VycmVuY2VzIC0gMSkpXG4gICAgICB0YXJnZXREYXlJbmRpY2VzLnB1c2goTWF0aC5tYXgoMCwgTWF0aC5taW4oZWxpZ2libGVEYXlzLmxlbmd0aCAtIDEsIHRhcmdldEluZGV4KSkpXG4gICAgICBvY2N1cnJlbmNlSW5kZXgrK1xuICAgIH1cbiAgfVxuICBcbiAgY29uc29sZS5sb2coYPCfjq8gVGFyZ2V0IGRheSBpbmRpY2VzOiBbJHt0YXJnZXREYXlJbmRpY2VzLnNsaWNlKDAsIDEwKS5qb2luKCcsICcpfSR7dGFyZ2V0RGF5SW5kaWNlcy5sZW5ndGggPiAxMCA/ICcuLi4nIDogJyd9XWApXG4gIFxuICBsZXQgY3VycmVudE9jY3VycmVuY2VJbmRleCA9IDBcbiAgXG4gIC8vIEdyb3VwIGFjdGlvbnMgYnkgYXJlYSB0byBlbnN1cmUgd2UgcHJvY2VzcyBhbGwgYWN0aW9ucyBpbiBhbiBhcmVhIGJlZm9yZSBtb3ZpbmcgdG8gdGhlIG5leHRcbiAgY29uc3QgYWN0aW9uc0J5QXJlYSA9IG5ldyBNYXA8bnVtYmVyLCBBY3Rpb25bXT4oKVxuICBmb3IgKGNvbnN0IGFjdGlvbiBvZiBzb3J0ZWRBY3Rpb25zKSB7XG4gICAgY29uc3QgYXJlYSA9IGFyZWFzLmZpbmQoYXJlYSA9PiBhcmVhLmlkID09PSBhY3Rpb24uYXJlYV9pZClcbiAgICBjb25zdCBhcmVhUG9zaXRpb24gPSBhcmVhPy5wb3NpdGlvbiB8fCAwXG4gICAgaWYgKCFhY3Rpb25zQnlBcmVhLmhhcyhhcmVhUG9zaXRpb24pKSB7XG4gICAgICBhY3Rpb25zQnlBcmVhLnNldChhcmVhUG9zaXRpb24sIFtdKVxuICAgIH1cbiAgICBhY3Rpb25zQnlBcmVhLmdldChhcmVhUG9zaXRpb24pIS5wdXNoKGFjdGlvbilcbiAgfVxuICBcbiAgLy8gUHJvY2VzcyBhcmVhcyBpbiBvcmRlclxuICBjb25zdCBzb3J0ZWRBcmVhUG9zaXRpb25zID0gQXJyYXkuZnJvbShhY3Rpb25zQnlBcmVhLmtleXMoKSkuc29ydCgoYSwgYikgPT4gYSAtIGIpXG4gIFxuICBmb3IgKGNvbnN0IGFyZWFQb3NpdGlvbiBvZiBzb3J0ZWRBcmVhUG9zaXRpb25zKSB7XG4gICAgY29uc3QgYXJlYUFjdGlvbnMgPSBhY3Rpb25zQnlBcmVhLmdldChhcmVhUG9zaXRpb24pIVxuICAgIGNvbnNvbGUubG9nKGDwn4+X77iPICBQcm9jZXNzaW5nIGFyZWEgJHthcmVhUG9zaXRpb259IHdpdGggJHthcmVhQWN0aW9ucy5sZW5ndGh9IGFjdGlvbnNgKVxuICAgIFxuICAgIGZvciAoY29uc3QgYWN0aW9uIG9mIGFyZWFBY3Rpb25zKSB7XG4gICAgXG4gICAgLy8gQ2hlY2sgaWYgdGhpcyBhY3Rpb24gaGFzIGV4aXN0aW5nIG9jY3VycmVuY2VzXG4gICAgY29uc3QgZXhpc3RpbmdBY3Rpb25PY2N1cnJlbmNlcyA9IGV4aXN0aW5nT2NjdXJyZW5jZXMuZmlsdGVyKG9jYyA9PiBvY2MuYWN0aW9uX2lkID09PSBhY3Rpb24uaWQpXG4gICAgXG4gICAgaWYgKGV4aXN0aW5nQWN0aW9uT2NjdXJyZW5jZXMubGVuZ3RoID4gMCkge1xuICAgICAgLy8gQWRkIGV4aXN0aW5nIG9jY3VycmVuY2VzIHRvIHBsYWNlbWVudHMgZm9yIGNhcGFjaXR5IHRyYWNraW5nXG4gICAgICBmb3IgKGNvbnN0IGV4aXN0aW5nT2NjIG9mIGV4aXN0aW5nQWN0aW9uT2NjdXJyZW5jZXMpIHtcbiAgICAgICAgcGxhY2VtZW50cy5wdXNoKHtcbiAgICAgICAgICBhY3Rpb25faWQ6IGFjdGlvbi5pZCxcbiAgICAgICAgICBkcmVhbV9pZDogZHJlYW0uaWQsXG4gICAgICAgICAgYXJlYV9pZDogYWN0aW9uLmFyZWFfaWQsXG4gICAgICAgICAgb2NjdXJyZW5jZV9ubzogZXhpc3RpbmdPY2Mub2NjdXJyZW5jZV9ubyxcbiAgICAgICAgICBwbGFubmVkX2R1ZV9vbjogZXhpc3RpbmdPY2MucGxhbm5lZF9kdWVfb24sXG4gICAgICAgICAgZHVlX29uOiBleGlzdGluZ09jYy5kdWVfb24sXG4gICAgICAgICAgaXNfcmVwZWF0OiBmYWxzZSxcbiAgICAgICAgICBpc19maXhlZDogZmFsc2VcbiAgICAgICAgfSlcbiAgICAgIH1cbiAgICAgIGNvbnRpbnVlXG4gICAgfVxuICAgIFxuICAgIC8vIEdldCB0aGUgbnVtYmVyIG9mIG9jY3VycmVuY2VzIG5lZWRlZCBmb3IgdGhpcyBhY3Rpb25cbiAgICBjb25zdCBvY2N1cnJlbmNlQ291bnQgPSBhY3Rpb25PY2N1cnJlbmNlQ291bnRzLmdldChhY3Rpb24uaWQpIHx8IDFcbiAgICBcbiAgICBpZiAob2NjdXJyZW5jZUNvdW50ID4gMSkge1xuICAgICAgY29uc29sZS5sb2coYPCfk5ogU2VlZGluZyAke29jY3VycmVuY2VDb3VudH0gb2NjdXJyZW5jZXMgZm9yOiBcIiR7YWN0aW9uLnRpdGxlfVwiYClcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc29sZS5sb2coYPCfjq8gU2VlZGluZyBzaW5nbGUgb2NjdXJyZW5jZSBmb3I6IFwiJHthY3Rpb24udGl0bGV9XCJgKVxuICAgIH1cbiAgICBcbiAgICAvLyBTY2hlZHVsZSBhbGwgb2NjdXJyZW5jZXMgZm9yIHRoaXMgYWN0aW9uIHVzaW5nIHByZS1jYWxjdWxhdGVkIHRhcmdldCBkYXlzXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBvY2N1cnJlbmNlQ291bnQ7IGkrKykge1xuICAgICAgaWYgKGN1cnJlbnRPY2N1cnJlbmNlSW5kZXggPj0gdGFyZ2V0RGF5SW5kaWNlcy5sZW5ndGgpIHtcbiAgICAgICAgY29uc29sZS5sb2coYCAg4p2MIE5vIG1vcmUgdGFyZ2V0IGRheXMgYXZhaWxhYmxlIGZvciBcIiR7YWN0aW9uLnRpdGxlfVwiIG9jY3VycmVuY2UgJHtpICsgMX1gKVxuICAgICAgICB0aWdodFBlbmRpbmcucHVzaChhY3Rpb24uaWQpXG4gICAgICAgIGJyZWFrXG4gICAgICB9XG4gICAgICBcbiAgICAgIGNvbnN0IHRhcmdldERheUluZGV4ID0gdGFyZ2V0RGF5SW5kaWNlc1tjdXJyZW50T2NjdXJyZW5jZUluZGV4XVxuICAgICAgY29uc3QgdGFyZ2V0RGF5ID0gZWxpZ2libGVEYXlzW3RhcmdldERheUluZGV4XVxuICAgICAgXG4gICAgICBpZiAoIXRhcmdldERheSkge1xuICAgICAgICBjb25zb2xlLmxvZyhgICDinYwgVGFyZ2V0IGRheSBpbmRleCAke3RhcmdldERheUluZGV4fSBpcyBvdXQgb2YgcmFuZ2UgZm9yIFwiJHthY3Rpb24udGl0bGV9XCIgb2NjdXJyZW5jZSAke2kgKyAxfWApXG4gICAgICAgIHRpZ2h0UGVuZGluZy5wdXNoKGFjdGlvbi5pZClcbiAgICAgICAgYnJlYWtcbiAgICAgIH1cbiAgICAgIFxuICAgICAgY29uc3QgZGF0ZVN0ciA9IHRhcmdldERheS50b0lTT1N0cmluZygpLnNwbGl0KCdUJylbMF1cbiAgICAgIFxuICAgICAgLy8gQ3JlYXRlIHBsYWNlbWVudCBmb3IgdGhpcyBvY2N1cnJlbmNlXG4gICAgICBwbGFjZW1lbnRzLnB1c2goe1xuICAgICAgICBhY3Rpb25faWQ6IGFjdGlvbi5pZCxcbiAgICAgICAgZHJlYW1faWQ6IGRyZWFtLmlkLFxuICAgICAgICBhcmVhX2lkOiBhY3Rpb24uYXJlYV9pZCxcbiAgICAgICAgb2NjdXJyZW5jZV9ubzogaSArIDEsXG4gICAgICAgIHBsYW5uZWRfZHVlX29uOiBkYXRlU3RyLFxuICAgICAgICBkdWVfb246IGRhdGVTdHIsXG4gICAgICAgIGlzX3JlcGVhdDogZmFsc2UsXG4gICAgICAgIC8vIE1hcmsgb3ZlcnNpemVkIGFjdGlvbnMgYXMgZml4ZWQgc28gdGhleSBhcmUgbm90IG1vdmVkIGJ5IGJhbGFuY2luZ1xuICAgICAgICBpc19maXhlZDogKGFjdGlvbi5lc3RfbWludXRlcyB8fCAwKSA+IGRhaWx5VGltZU1pbnV0ZXNcbiAgICAgIH0pXG4gICAgICBcbiAgICAgIC8vIFVwZGF0ZSBjYXBhY2l0eSAoY2FuIGdvIG5lZ2F0aXZlIHRvIHRyYWNrIHZpb2xhdGlvbnMpXG4gICAgICBjb25zdCBjdXJyZW50R2xvYmFsID0gY2FwYWNpdHkuZ2xvYmFsX3JlbWFpbmluZy5nZXQoZGF0ZVN0cikgfHwgMFxuICAgICAgY29uc3QgY3VycmVudFBlckRyZWFtID0gY2FwYWNpdHkucGVyX2RyZWFtX3JlbWFpbmluZy5nZXQoZGF0ZVN0cik/LmdldChkcmVhbS5pZCkgfHwgMFxuICAgICAgXG4gICAgICBpZiAoY3VycmVudEdsb2JhbCA8PSAwKSB7XG4gICAgICAgIGNvbnNvbGUubG9nKGAgIOKaoO+4jyAgR2xvYmFsIGNhcGFjaXR5IHZpb2xhdGlvbiBvbiAke2RhdGVTdHJ9YClcbiAgICAgIH1cbiAgICAgIGlmIChjdXJyZW50UGVyRHJlYW0gPD0gMCkge1xuICAgICAgICBjb25zb2xlLmxvZyhgICDimqDvuI8gIFBlci1kcmVhbSBjYXBhY2l0eSB2aW9sYXRpb24gb24gJHtkYXRlU3RyfWApXG4gICAgICB9XG4gICAgICBcbiAgICAgIGNhcGFjaXR5Lmdsb2JhbF9yZW1haW5pbmcuc2V0KGRhdGVTdHIsIGN1cnJlbnRHbG9iYWwgLSAxKVxuICAgICAgXG4gICAgICBpZiAoIWNhcGFjaXR5LnBlcl9kcmVhbV9yZW1haW5pbmcuZ2V0KGRhdGVTdHIpIS5oYXMoZHJlYW0uaWQpKSB7XG4gICAgICAgIGNhcGFjaXR5LnBlcl9kcmVhbV9yZW1haW5pbmcuZ2V0KGRhdGVTdHIpIS5zZXQoZHJlYW0uaWQsIFBFUl9EUkVBTV9DQVBfREVGQVVMVClcbiAgICAgIH1cbiAgICAgIGNhcGFjaXR5LnBlcl9kcmVhbV9yZW1haW5pbmcuZ2V0KGRhdGVTdHIpIS5zZXQoZHJlYW0uaWQsIGN1cnJlbnRQZXJEcmVhbSAtIDEpXG4gICAgICBcbiAgICAgIGN1cnJlbnRPY2N1cnJlbmNlSW5kZXgrK1xuICAgIH1cbiAgICB9XG4gIH1cbiAgXG4gIHJldHVybiB7IHBsYWNlbWVudHMsIHRpZ2h0X3BlbmRpbmc6IHRpZ2h0UGVuZGluZyB9XG59XG5cbi8qKlxuICogU3RlcCAyOiBFeHBhbmQgcmVwZWF0c1xuICovXG5hc3luYyBmdW5jdGlvbiBleHBhbmRSZXBlYXRzKFxuICBjb250ZXh0OiBTY2hlZHVsaW5nQ29udGV4dCxcbiAgZHJlYW06IERyZWFtLFxuICBzb3J0ZWRBY3Rpb25zOiBBY3Rpb25bXSxcbiAgd2luZG93OiB7IHN0YXJ0X2RhdGU6IERhdGU7IGVuZF9kYXRlOiBEYXRlIH0sXG4gIGNhcGFjaXR5OiBDYXBhY2l0eVRyYWNrZXIsXG4gIHNlZWRQbGFjZW1lbnRzOiBTY2hlZHVsZWRQbGFjZW1lbnRbXVxuKTogUHJvbWlzZTx7IHBsYWNlbWVudHM6IFNjaGVkdWxlZFBsYWNlbWVudFtdIH0+IHtcbiAgY29uc3QgcGxhY2VtZW50czogU2NoZWR1bGVkUGxhY2VtZW50W10gPSBbXVxuICBcbiAgZm9yIChjb25zdCBhY3Rpb24gb2Ygc29ydGVkQWN0aW9ucykge1xuICAgIGNvbnN0IHNlZWRQbGFjZW1lbnQgPSBzZWVkUGxhY2VtZW50cy5maW5kKHAgPT4gcC5hY3Rpb25faWQgPT09IGFjdGlvbi5pZClcbiAgICBpZiAoIXNlZWRQbGFjZW1lbnQpIGNvbnRpbnVlXG4gICAgXG4gICAgLy8gT25seSBoYW5kbGUgb25nb2luZyBoYWJpdHMgKHJlcGVhdF9ldmVyeV9kYXlzKSAtIGZpbml0ZSBzZXJpZXMgYXJlIGhhbmRsZWQgaW4gc2VlZGluZ1xuICAgIGlmIChhY3Rpb24ucmVwZWF0X2V2ZXJ5X2RheXMpIHtcbiAgICAgIGNvbnNvbGUubG9nKGDwn5SEIENyZWF0aW5nIG9uZ29pbmcgcmVwZWF0cyBmb3IgaGFiaXQ6IFwiJHthY3Rpb24udGl0bGV9XCIgKGV2ZXJ5ICR7YWN0aW9uLnJlcGVhdF9ldmVyeV9kYXlzfSBkYXlzKWApXG4gICAgICBcbiAgICAgIGNvbnN0IHNlZWREYXRlID0gbmV3IERhdGUoc2VlZFBsYWNlbWVudC5kdWVfb24pXG4gICAgICBsZXQgY3VycmVudERhdGUgPSBuZXcgRGF0ZShzZWVkRGF0ZSlcbiAgICAgIGxldCBvY2N1cnJlbmNlTm8gPSAyXG4gICAgICBcbiAgICAgIC8vIEFkZCByZXBlYXQgb2NjdXJyZW5jZXNcbiAgICAgIHdoaWxlIChjdXJyZW50RGF0ZSA8PSB3aW5kb3cuZW5kX2RhdGUpIHtcbiAgICAgICAgY3VycmVudERhdGUuc2V0RGF0ZShjdXJyZW50RGF0ZS5nZXREYXRlKCkgKyBhY3Rpb24ucmVwZWF0X2V2ZXJ5X2RheXMpXG4gICAgICAgIFxuICAgICAgICBpZiAoY3VycmVudERhdGUgPiB3aW5kb3cuZW5kX2RhdGUpIGJyZWFrXG4gICAgICAgIFxuICAgICAgICAvLyBTa2lwIHJlc3QgZGF5c1xuICAgICAgICBjb25zdCBkYXlPZldlZWsgPSBjdXJyZW50RGF0ZS5nZXREYXkoKVxuICAgICAgICBpZiAoUkVTVF9EQVlTLmhhcyhkYXlPZldlZWspKSB7XG4gICAgICAgICAgLy8gUm9sbCB0byBuZXh0IG5vbi1yZXN0IGRheVxuICAgICAgICAgIGN1cnJlbnREYXRlLnNldERhdGUoY3VycmVudERhdGUuZ2V0RGF0ZSgpICsgMSlcbiAgICAgICAgICBpZiAoY3VycmVudERhdGUgPiB3aW5kb3cuZW5kX2RhdGUpIGJyZWFrXG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIGNvbnN0IGRhdGVTdHIgPSBjdXJyZW50RGF0ZS50b0lTT1N0cmluZygpLnNwbGl0KCdUJylbMF1cbiAgICAgICAgXG4gICAgICAgIC8vIENoZWNrIGNhcGFjaXR5IChhZHZpc29yeSAtIHdlJ2xsIHNjaGVkdWxlIGV2ZW4gaWYgdmlvbGF0ZWQpXG4gICAgICAgIGNvbnN0IGdsb2JhbFJlbWFpbmluZyA9IGNhcGFjaXR5Lmdsb2JhbF9yZW1haW5pbmcuZ2V0KGRhdGVTdHIpIHx8IDBcbiAgICAgICAgXG4gICAgICAgIC8vIEVuc3VyZSBwZXJfZHJlYW1fcmVtYWluaW5nIGhhcyBhbiBlbnRyeSBmb3IgdGhpcyBkYXRlXG4gICAgICAgIGlmICghY2FwYWNpdHkucGVyX2RyZWFtX3JlbWFpbmluZy5oYXMoZGF0ZVN0cikpIHtcbiAgICAgICAgICBjYXBhY2l0eS5wZXJfZHJlYW1fcmVtYWluaW5nLnNldChkYXRlU3RyLCBuZXcgTWFwKCkpXG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcGVyRHJlYW1SZW1haW5pbmcgPSBjYXBhY2l0eS5wZXJfZHJlYW1fcmVtYWluaW5nLmdldChkYXRlU3RyKT8uZ2V0KGRyZWFtLmlkKSB8fCAwXG4gICAgICAgIFxuICAgICAgICBwbGFjZW1lbnRzLnB1c2goe1xuICAgICAgICAgIGFjdGlvbl9pZDogYWN0aW9uLmlkLFxuICAgICAgICAgIGRyZWFtX2lkOiBkcmVhbS5pZCxcbiAgICAgICAgICBhcmVhX2lkOiBhY3Rpb24uYXJlYV9pZCxcbiAgICAgICAgICBvY2N1cnJlbmNlX25vOiBvY2N1cnJlbmNlTm8sXG4gICAgICAgICAgcGxhbm5lZF9kdWVfb246IGRhdGVTdHIsXG4gICAgICAgICAgZHVlX29uOiBkYXRlU3RyLFxuICAgICAgICAgIGlzX3JlcGVhdDogdHJ1ZSxcbiAgICAgICAgICBpc19maXhlZDogdHJ1ZSAvLyBSZXBlYXRzIGFyZSBmaXhlZCBhbmQgY2FuJ3QgYmUgbW92ZWQgZWFzaWx5XG4gICAgICAgIH0pXG4gICAgICAgIFxuICAgICAgICAvLyBVcGRhdGUgY2FwYWNpdHkgKGNhbiBnbyBuZWdhdGl2ZSB0byB0cmFjayB2aW9sYXRpb25zKVxuICAgICAgICBjYXBhY2l0eS5nbG9iYWxfcmVtYWluaW5nLnNldChkYXRlU3RyLCBnbG9iYWxSZW1haW5pbmcgLSAxKVxuICAgICAgICBjYXBhY2l0eS5wZXJfZHJlYW1fcmVtYWluaW5nLmdldChkYXRlU3RyKSEuc2V0KGRyZWFtLmlkLCBwZXJEcmVhbVJlbWFpbmluZyAtIDEpXG4gICAgICAgIFxuICAgICAgICBvY2N1cnJlbmNlTm8rK1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBcbiAgcmV0dXJuIHsgcGxhY2VtZW50cyB9XG59XG5cbi8qKlxuICogU3RlcCAzOiBHbG9iYWwgYmFsYW5jaW5nIHRvIGVuZm9yY2UgdGltZS1iYXNlZCBjYXBhY2l0eSBsaW1pdHNcbiAqL1xuYXN5bmMgZnVuY3Rpb24gZ2xvYmFsQmFsYW5jaW5nKFxuICBjb250ZXh0OiBTY2hlZHVsaW5nQ29udGV4dCxcbiAgZHJlYW06IERyZWFtLFxuICB3aW5kb3c6IHsgc3RhcnRfZGF0ZTogRGF0ZTsgZW5kX2RhdGU6IERhdGUgfSxcbiAgY2FwYWNpdHk6IENhcGFjaXR5VHJhY2tlcixcbiAgYWxsUGxhY2VtZW50czogU2NoZWR1bGVkUGxhY2VtZW50W10sXG4gIGFjdGlvbnM6IEFjdGlvbltdXG4pOiBQcm9taXNlPHsgcGxhY2VtZW50czogU2NoZWR1bGVkUGxhY2VtZW50W107IHdhcm5pbmdzOiBzdHJpbmdbXSB9PiB7XG4gIGNvbnN0IHdhcm5pbmdzOiBzdHJpbmdbXSA9IFtdXG4gIGNvbnN0IHBsYWNlbWVudHMgPSBbLi4uYWxsUGxhY2VtZW50c11cbiAgXG4gIC8vIEdldCB0aW1lIGNvbW1pdG1lbnQgZm9yIGNhcGFjaXR5IGNhbGN1bGF0aW9uc1xuICBjb25zdCB0aW1lQ29tbWl0bWVudCA9IGRyZWFtLnRpbWVfY29tbWl0bWVudFxuICBjb25zdCBkYWlseVRpbWVNaW51dGVzID0gdGltZUNvbW1pdG1lbnQgXG4gICAgPyB0aW1lQ29tbWl0bWVudC5ob3VycyAqIDYwICsgdGltZUNvbW1pdG1lbnQubWludXRlcyBcbiAgICA6IERFRkFVTFRfREFJTFlfVElNRV9NSU5VVEVTXG4gIFxuICAvLyBDcmVhdGUgYWN0aW9uIGxvb2t1cCBtYXAgZm9yIHRpbWUgZXN0aW1hdGlvblxuICBjb25zdCBhY3Rpb25NYXAgPSBuZXcgTWFwKGFjdGlvbnMubWFwKGFjdGlvbiA9PiBbYWN0aW9uLmlkLCBhY3Rpb25dKSlcbiAgXG4gIC8vIFRyYWNrIG1vdmVkIHBsYWNlbWVudHMgdG8gcHJldmVudCBpbmZpbml0ZSBsb29wc1xuICBjb25zdCBtb3ZlZFBsYWNlbWVudHMgPSBuZXcgU2V0PHN0cmluZz4oKVxuICBcbiAgLy8gTWF4aW11bSBudW1iZXIgb2YgaXRlcmF0aW9ucyB0byBwcmV2ZW50IGluZmluaXRlIGxvb3BzXG4gIGNvbnN0IE1BWF9JVEVSQVRJT05TID0gMTAwXG4gIGxldCBpdGVyYXRpb24gPSAwXG4gIFxuICAvLyBDaGVjayBmb3IgZGF5cyB0aGF0IGV4Y2VlZCB0aW1lLWJhc2VkIGNhcGFjaXR5XG4gIHdoaWxlIChpdGVyYXRpb24gPCBNQVhfSVRFUkFUSU9OUykge1xuICAgIGl0ZXJhdGlvbisrXG4gICAgbGV0IGhhc0NoYW5nZXMgPSBmYWxzZVxuICAgIGNvbnN0IGN1cnJlbnREYXRlID0gbmV3IERhdGUod2luZG93LnN0YXJ0X2RhdGUpXG4gICAgLy8gVHJhY2sgdGFyZ2V0IGRhdGVzIHdlJ3ZlIGFscmVhZHkgbW92ZWQgdG8gaW4gdGhpcyBpdGVyYXRpb24gdG8gYXZvaWQgY2x1c3RlcmluZ1xuICAgIGNvbnN0IHVzZWRUYXJnZXREYXRlcyA9IG5ldyBTZXQ8c3RyaW5nPigpXG4gICAgXG4gICAgd2hpbGUgKGN1cnJlbnREYXRlIDw9IHdpbmRvdy5lbmRfZGF0ZSkge1xuICAgICAgY29uc3QgZGF0ZVN0ciA9IGN1cnJlbnREYXRlLnRvSVNPU3RyaW5nKCkuc3BsaXQoJ1QnKVswXVxuICAgICAgY29uc3QgZGF5UGxhY2VtZW50cyA9IHBsYWNlbWVudHMuZmlsdGVyKHAgPT4gcC5kdWVfb24gPT09IGRhdGVTdHIpXG4gICAgICBcbiAgICAgIC8vIENhbGN1bGF0ZSB0b3RhbCB0aW1lIGZvciB0aGlzIGRheVxuICAgICAgbGV0IHRvdGFsRGF5VGltZSA9IDBcbiAgICAgIGZvciAoY29uc3QgcGxhY2VtZW50IG9mIGRheVBsYWNlbWVudHMpIHtcbiAgICAgICAgY29uc3QgYWN0aW9uID0gYWN0aW9uTWFwLmdldChwbGFjZW1lbnQuYWN0aW9uX2lkKVxuICAgICAgICBpZiAoYWN0aW9uPy5lc3RfbWludXRlcykge1xuICAgICAgICAgIHRvdGFsRGF5VGltZSArPSBhY3Rpb24uZXN0X21pbnV0ZXNcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgXG4gICAgICAvLyBDaGVjayBpZiB0aGlzIGRheSBleGNlZWRzIHRoZSB0aW1lIGJ1ZGdldFxuICAgICAgICAgIGlmICh0b3RhbERheVRpbWUgPiBkYWlseVRpbWVNaW51dGVzKSB7XG4gICAgICAgIGNvbnNvbGUubG9nKGDij7AgRGF5ICR7ZGF0ZVN0cn0gZXhjZWVkcyB0aW1lIGJ1ZGdldDogJHt0b3RhbERheVRpbWV9bWluID4gJHtkYWlseVRpbWVNaW51dGVzfW1pbmApXG4gICAgICAgIFxuICAgICAgICAgICAgLy8gRmluZCBub24tcmVwZWF0IG9uZS1vZmZzIHRoYXQgY2FuIGJlIG1vdmVkIChza2lwIG92ZXJzaXplZCBhY3Rpb25zIG1hcmtlZCBmaXhlZClcbiAgICAgICAgIGNvbnN0IG1vdmVhYmxlUGxhY2VtZW50cyA9IGRheVBsYWNlbWVudHMuZmlsdGVyKHAgPT4gXG4gICAgICAgICAgICAgICFwLmlzX3JlcGVhdCAmJiAhcC5pc19maXhlZCAmJiAhbW92ZWRQbGFjZW1lbnRzLmhhcyhwLmFjdGlvbl9pZClcbiAgICAgICAgIClcbiAgICAgICAgXG4gICAgICAgIC8vIFNvcnQgYnkgbW92ZSBwcmlvcml0eSAobG9uZ2VzdCBhY3Rpb25zIGZpcnN0IHRvIG1heGltaXplIHRpbWUgc2F2aW5ncylcbiAgICAgICAgbW92ZWFibGVQbGFjZW1lbnRzLnNvcnQoKGEsIGIpID0+IHtcbiAgICAgICAgICBjb25zdCBhY3Rpb25BID0gYWN0aW9uTWFwLmdldChhLmFjdGlvbl9pZClcbiAgICAgICAgICBjb25zdCBhY3Rpb25CID0gYWN0aW9uTWFwLmdldChiLmFjdGlvbl9pZClcbiAgICAgICAgICBjb25zdCB0aW1lQSA9IGFjdGlvbkE/LmVzdF9taW51dGVzIHx8IDBcbiAgICAgICAgICBjb25zdCB0aW1lQiA9IGFjdGlvbkI/LmVzdF9taW51dGVzIHx8IDBcbiAgICAgICAgICByZXR1cm4gdGltZUIgLSB0aW1lQSAvLyBTb3J0IGJ5IHRpbWUgZGVzY2VuZGluZ1xuICAgICAgICB9KVxuICAgICAgICBcbiAgICAgICAgLy8gVHJ5IHRvIG1vdmUgYWN0aW9ucyB1bnRpbCB3ZSdyZSB1bmRlciB0aGUgdGltZSBidWRnZXRcbiAgICAgICAgbGV0IHJlbWFpbmluZ1RpbWUgPSB0b3RhbERheVRpbWVcbiAgICAgICAgZm9yIChjb25zdCBwbGFjZW1lbnQgb2YgbW92ZWFibGVQbGFjZW1lbnRzKSB7XG4gICAgICAgICAgaWYgKHJlbWFpbmluZ1RpbWUgPD0gZGFpbHlUaW1lTWludXRlcykgYnJlYWtcbiAgICAgICAgICBcbiAgICAgICAgICBjb25zdCBhY3Rpb24gPSBhY3Rpb25NYXAuZ2V0KHBsYWNlbWVudC5hY3Rpb25faWQpXG4gICAgICAgICAgaWYgKCFhY3Rpb24/LmVzdF9taW51dGVzKSBjb250aW51ZVxuICAgICAgICAgIFxuICAgICAgICAgICAgICBjb25zdCBhdm9pZERhdGVzID0gbmV3IFNldDxzdHJpbmc+KFtcbiAgICAgICAgICAgICAgICBkYXRlU3RyLFxuICAgICAgICAgICAgICAgIC4uLkFycmF5LmZyb20odXNlZFRhcmdldERhdGVzKVxuICAgICAgICAgICAgICBdKVxuICAgICAgICAgICAgICAgY29uc3QgbmV3RGF0ZSA9IGZpbmROZXh0QXZhaWxhYmxlRGF0ZShcbiAgICAgICAgICAgIHBsYWNlbWVudCxcbiAgICAgICAgICAgIG5ldyBEYXRlKGRhdGVTdHIpLFxuICAgICAgICAgICAgd2luZG93LmVuZF9kYXRlLFxuICAgICAgICAgICAgY2FwYWNpdHksXG4gICAgICAgICAgICBwbGFjZW1lbnRzLFxuICAgICAgICAgICAgYWN0aW9ucyxcbiAgICAgICAgICAgICAgICAgZGFpbHlUaW1lTWludXRlcyxcbiAgICAgICAgICAgICAgICAgYXZvaWREYXRlc1xuICAgICAgICAgIClcbiAgICAgICAgICBcbiAgICAgICAgICBpZiAobmV3RGF0ZSkge1xuICAgICAgICAgICAgcGxhY2VtZW50LmR1ZV9vbiA9IG5ld0RhdGUudG9JU09TdHJpbmcoKS5zcGxpdCgnVCcpWzBdXG4gICAgICAgICAgICBwbGFjZW1lbnQucGxhbm5lZF9kdWVfb24gPSBuZXdEYXRlLnRvSVNPU3RyaW5nKCkuc3BsaXQoJ1QnKVswXVxuICAgICAgICAgICAgcmVtYWluaW5nVGltZSAtPSBhY3Rpb24uZXN0X21pbnV0ZXNcbiAgICAgICAgICAgIG1vdmVkUGxhY2VtZW50cy5hZGQocGxhY2VtZW50LmFjdGlvbl9pZClcbiAgICAgICAgICAgICAgICB1c2VkVGFyZ2V0RGF0ZXMuYWRkKHBsYWNlbWVudC5kdWVfb24pXG4gICAgICAgICAgICBoYXNDaGFuZ2VzID0gdHJ1ZVxuICAgICAgICAgICAgY29uc29sZS5sb2coYPCfk4UgTW92ZWQgXCIke2FjdGlvbi50aXRsZX1cIiAoJHthY3Rpb24uZXN0X21pbnV0ZXN9bWluKSBmcm9tICR7ZGF0ZVN0cn0gdG8gJHtuZXdEYXRlLnRvSVNPU3RyaW5nKCkuc3BsaXQoJ1QnKVswXX1gKVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBJZiB3ZSBjYW4ndCBmaW5kIGEgYmV0dGVyIGRhdGUsIGtlZXAgdGhlIG9yaWdpbmFsIHBsYWNlbWVudFxuICAgICAgICAgICAgLy8gVGhpcyBlbnN1cmVzIHdlIGRvbid0IGxvc2UgYW55IHNjaGVkdWxlZCBhY3Rpb25zXG4gICAgICAgICAgICB3YXJuaW5ncy5wdXNoKGBDb3VsZCBub3QgYmFsYW5jZSB0aW1lIGJ1ZGdldCBmb3IgJHtkYXRlU3RyfSAtIGtlZXBpbmcgb3JpZ2luYWwgcGxhY2VtZW50YClcbiAgICAgICAgICAgIGJyZWFrXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBcbiAgICAgIGN1cnJlbnREYXRlLnNldERhdGUoY3VycmVudERhdGUuZ2V0RGF0ZSgpICsgMSlcbiAgICB9XG4gICAgXG4gICAgLy8gSWYgbm8gY2hhbmdlcyB3ZXJlIG1hZGUgaW4gdGhpcyBpdGVyYXRpb24sIHdlJ3JlIGRvbmVcbiAgICBpZiAoIWhhc0NoYW5nZXMpIHtcbiAgICAgIGJyZWFrXG4gICAgfVxuICAgIFxuICAgIC8vIENsZWFyIG1vdmVkIHBsYWNlbWVudHMgZm9yIG5leHQgaXRlcmF0aW9uXG4gICAgbW92ZWRQbGFjZW1lbnRzLmNsZWFyKClcbiAgfVxuICBcbiAgaWYgKGl0ZXJhdGlvbiA+PSBNQVhfSVRFUkFUSU9OUykge1xuICAgIHdhcm5pbmdzLnB1c2goJ01heGltdW0gYmFsYW5jaW5nIGl0ZXJhdGlvbnMgcmVhY2hlZCAtIHNvbWUgZGF5cyBtYXkgc3RpbGwgZXhjZWVkIHRpbWUgYnVkZ2V0JylcbiAgfVxuICBcbiAgcmV0dXJuIHsgcGxhY2VtZW50cywgd2FybmluZ3MgfVxufVxuXG4vKipcbiAqIFN0ZXAgNDogVGlnaHQgZmFsbGJhY2sgZXNjYWxhdGlvblxuICovXG5hc3luYyBmdW5jdGlvbiB0aWdodEZhbGxiYWNrRXNjYWxhdGlvbihcbiAgY29udGV4dDogU2NoZWR1bGluZ0NvbnRleHQsXG4gIGRyZWFtOiBEcmVhbSxcbiAgc29ydGVkQWN0aW9uczogQWN0aW9uW10sXG4gIHdpbmRvdzogeyBzdGFydF9kYXRlOiBEYXRlOyBlbmRfZGF0ZTogRGF0ZSB9LFxuICBjYXBhY2l0eTogQ2FwYWNpdHlUcmFja2VyLFxuICBwbGFjZW1lbnRzOiBTY2hlZHVsZWRQbGFjZW1lbnRbXSxcbiAgdGlnaHRQZW5kaW5nOiBzdHJpbmdbXVxuKTogUHJvbWlzZTx7IHBsYWNlbWVudHM6IFNjaGVkdWxlZFBsYWNlbWVudFtdOyB3YXJuaW5nczogc3RyaW5nW107IHRvb190aWdodD86IGJvb2xlYW4gfT4ge1xuICBjb25zdCB3YXJuaW5nczogc3RyaW5nW10gPSBbXVxuICBsZXQgdG9vVGlnaHQgPSBmYWxzZVxuICBcbiAgaWYgKHRpZ2h0UGVuZGluZy5sZW5ndGggPT09IDApIHtcbiAgICByZXR1cm4geyBwbGFjZW1lbnRzLCB3YXJuaW5ncyB9XG4gIH1cbiAgXG4gIC8vIFRyeSBlc2NhbGF0aW5nIHBlci1kcmVhbSBjYXAgdG8gMi9kYXlcbiAgY29uc3QgZXNjYWxhdGVkQ2FwYWNpdHkgPSB7IC4uLmNhcGFjaXR5IH1cbiAgY29uc3QgY3VycmVudERhdGUgPSBuZXcgRGF0ZSh3aW5kb3cuc3RhcnRfZGF0ZSlcbiAgd2hpbGUgKGN1cnJlbnREYXRlIDw9IHdpbmRvdy5lbmRfZGF0ZSkge1xuICAgIGNvbnN0IGRhdGVTdHIgPSBjdXJyZW50RGF0ZS50b0lTT1N0cmluZygpLnNwbGl0KCdUJylbMF1cbiAgICBjb25zdCBwZXJEcmVhbU1hcCA9IGVzY2FsYXRlZENhcGFjaXR5LnBlcl9kcmVhbV9yZW1haW5pbmcuZ2V0KGRhdGVTdHIpXG4gICAgaWYgKHBlckRyZWFtTWFwKSB7XG4gICAgICBwZXJEcmVhbU1hcC5zZXQoZHJlYW0uaWQsIDIpXG4gICAgfVxuICAgIGN1cnJlbnREYXRlLnNldERhdGUoY3VycmVudERhdGUuZ2V0RGF0ZSgpICsgMSlcbiAgfVxuICBcbiAgLy8gVHJ5IHRvIHBsYWNlIHRpZ2h0IHBlbmRpbmcgYWN0aW9uc1xuICBmb3IgKGNvbnN0IGFjdGlvbklkIG9mIHRpZ2h0UGVuZGluZykge1xuICAgIC8vIEdldCB0aGUgYWN0dWFsIGFjdGlvbiBmcm9tIHNvcnRlZEFjdGlvbnNcbiAgICBjb25zdCBhY3Rpb24gPSBzb3J0ZWRBY3Rpb25zLmZpbmQoYSA9PiBhLmlkID09PSBhY3Rpb25JZClcbiAgICBpZiAoIWFjdGlvbikge1xuICAgICAgd2FybmluZ3MucHVzaChgQWN0aW9uICR7YWN0aW9uSWR9IG5vdCBmb3VuZCBpbiBjb250ZXh0YClcbiAgICAgIGNvbnRpbnVlXG4gICAgfVxuICAgIFxuICAgIGNvbnN0IHBsYWNlbWVudCA9IGZpbmRGZWFzaWJsZVBsYWNlbWVudChcbiAgICAgIGFjdGlvbixcbiAgICAgIGRyZWFtLmlkLFxuICAgICAgbmV3IERhdGUod2luZG93LnN0YXJ0X2RhdGUpLFxuICAgICAgd2luZG93LmVuZF9kYXRlLFxuICAgICAgZXNjYWxhdGVkQ2FwYWNpdHksXG4gICAgICBnZXRFbGlnaWJsZVdvcmtkYXlzKHdpbmRvdy5zdGFydF9kYXRlLCB3aW5kb3cuZW5kX2RhdGUpXG4gICAgKVxuICAgIFxuICAgIGlmIChwbGFjZW1lbnQpIHtcbiAgICAgIHBsYWNlbWVudHMucHVzaChwbGFjZW1lbnQpXG4gICAgICB3YXJuaW5ncy5wdXNoKGBFc2NhbGF0ZWQgcGVyLWRyZWFtIGNhcCB0byAyL2RheSBmb3IgJHtkcmVhbS50aXRsZX1gKVxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBUcnkgMy9kYXkgYXMgbGFzdCByZXNvcnRcbiAgICAgIGNvbnN0IG1heENhcGFjaXR5ID0geyAuLi5lc2NhbGF0ZWRDYXBhY2l0eSB9XG4gICAgICBjb25zdCBjdXJyZW50RGF0ZSA9IG5ldyBEYXRlKHdpbmRvdy5zdGFydF9kYXRlKVxuICAgICAgd2hpbGUgKGN1cnJlbnREYXRlIDw9IHdpbmRvdy5lbmRfZGF0ZSkge1xuICAgICAgICBjb25zdCBkYXRlU3RyID0gY3VycmVudERhdGUudG9JU09TdHJpbmcoKS5zcGxpdCgnVCcpWzBdXG4gICAgICAgIGNvbnN0IHBlckRyZWFtTWFwID0gbWF4Q2FwYWNpdHkucGVyX2RyZWFtX3JlbWFpbmluZy5nZXQoZGF0ZVN0cilcbiAgICAgICAgaWYgKHBlckRyZWFtTWFwKSB7XG4gICAgICAgICAgcGVyRHJlYW1NYXAuc2V0KGRyZWFtLmlkLCBQRVJfRFJFQU1fQ0FQX01BWClcbiAgICAgICAgfVxuICAgICAgICBjdXJyZW50RGF0ZS5zZXREYXRlKGN1cnJlbnREYXRlLmdldERhdGUoKSArIDEpXG4gICAgICB9XG4gICAgICBcbiAgICAgIGNvbnN0IG1heFBsYWNlbWVudCA9IGZpbmRGZWFzaWJsZVBsYWNlbWVudChcbiAgICAgICAgYWN0aW9uLFxuICAgICAgICBkcmVhbS5pZCxcbiAgICAgICAgbmV3IERhdGUod2luZG93LnN0YXJ0X2RhdGUpLFxuICAgICAgICB3aW5kb3cuZW5kX2RhdGUsXG4gICAgICAgIG1heENhcGFjaXR5LFxuICAgICAgICBnZXRFbGlnaWJsZVdvcmtkYXlzKHdpbmRvdy5zdGFydF9kYXRlLCB3aW5kb3cuZW5kX2RhdGUpXG4gICAgICApXG4gICAgICBcbiAgICAgIGlmIChtYXhQbGFjZW1lbnQpIHtcbiAgICAgICAgcGxhY2VtZW50cy5wdXNoKG1heFBsYWNlbWVudClcbiAgICAgICAgd2FybmluZ3MucHVzaChgRXNjYWxhdGVkIHBlci1kcmVhbSBjYXAgdG8gMy9kYXkgZm9yICR7ZHJlYW0udGl0bGV9YClcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRvb1RpZ2h0ID0gdHJ1ZVxuICAgICAgICB3YXJuaW5ncy5wdXNoKGBDYW5ub3QgZml0IGFsbCBhY3Rpb25zIGZvciAke2RyZWFtLnRpdGxlfSB3aXRoaW4gd2luZG93IGFuZCBjYXBzYClcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgXG4gIHJldHVybiB7IHBsYWNlbWVudHMsIHdhcm5pbmdzLCB0b29fdGlnaHQ6IHRvb1RpZ2h0IH1cbn1cblxuLyoqXG4gKiBIZWxwZXIgZnVuY3Rpb24gdG8gZ2V0IGVsaWdpYmxlIHdvcmtkYXlzIChleGNsdWRpbmcgcmVzdCBkYXlzKVxuICovXG5mdW5jdGlvbiBnZXRFbGlnaWJsZVdvcmtkYXlzKHN0YXJ0RGF0ZTogRGF0ZSwgZW5kRGF0ZTogRGF0ZSk6IERhdGVbXSB7XG4gIGNvbnN0IHdvcmtkYXlzOiBEYXRlW10gPSBbXVxuICBjb25zdCBjdXJyZW50RGF0ZSA9IG5ldyBEYXRlKHN0YXJ0RGF0ZSlcbiAgXG4gIHdoaWxlIChjdXJyZW50RGF0ZSA8PSBlbmREYXRlKSB7XG4gICAgY29uc3QgZGF5T2ZXZWVrID0gY3VycmVudERhdGUuZ2V0RGF5KClcbiAgICBpZiAoIVJFU1RfREFZUy5oYXMoZGF5T2ZXZWVrKSkge1xuICAgICAgd29ya2RheXMucHVzaChuZXcgRGF0ZShjdXJyZW50RGF0ZSkpXG4gICAgfVxuICAgIGN1cnJlbnREYXRlLnNldERhdGUoY3VycmVudERhdGUuZ2V0RGF0ZSgpICsgMSlcbiAgfVxuICBcbiAgcmV0dXJuIHdvcmtkYXlzXG59XG5cbi8qKlxuICogSGVscGVyIGZ1bmN0aW9uIHRvIGZpbmQgZmVhc2libGUgcGxhY2VtZW50IGZvciBhbiBhY3Rpb25cbiAqL1xuZnVuY3Rpb24gZmluZEZlYXNpYmxlUGxhY2VtZW50KFxuICBhY3Rpb246IEFjdGlvbixcbiAgZHJlYW1JZDogc3RyaW5nLFxuICBtaW5EYXRlOiBEYXRlLFxuICBtYXhEYXRlOiBEYXRlLFxuICBjYXBhY2l0eTogQ2FwYWNpdHlUcmFja2VyLFxuICBlbGlnaWJsZURheXM6IERhdGVbXVxuKTogU2NoZWR1bGVkUGxhY2VtZW50IHwgbnVsbCB7XG4gIGNvbnNvbGUubG9nKGDwn5SNIEZpbmRpbmcgcGxhY2VtZW50IGZvciBcIiR7YWN0aW9uLnRpdGxlfVwiIChtaW46ICR7bWluRGF0ZS50b0lTT1N0cmluZygpLnNwbGl0KCdUJylbMF19LCBtYXg6ICR7bWF4RGF0ZS50b0lTT1N0cmluZygpLnNwbGl0KCdUJylbMF19KWApXG4gIFxuICAvLyBGaXJzdCBwYXNzOiBUcnkgdG8gZmluZCBhIHBsYWNlbWVudCB0aGF0IHJlc3BlY3RzIGNhcGFjaXR5IGNvbnN0cmFpbnRzXG4gIGZvciAoY29uc3QgZGF5IG9mIGVsaWdpYmxlRGF5cykge1xuICAgIGlmIChkYXkgPCBtaW5EYXRlKSBjb250aW51ZVxuICAgIGlmIChkYXkgPiBtYXhEYXRlKSBicmVha1xuICAgIFxuICAgIGNvbnN0IGRhdGVTdHIgPSBkYXkudG9JU09TdHJpbmcoKS5zcGxpdCgnVCcpWzBdXG4gICAgY29uc3QgZ2xvYmFsUmVtYWluaW5nID0gY2FwYWNpdHkuZ2xvYmFsX3JlbWFpbmluZy5nZXQoZGF0ZVN0cikgfHwgMFxuICAgIGNvbnN0IHBlckRyZWFtUmVtYWluaW5nID0gY2FwYWNpdHkucGVyX2RyZWFtX3JlbWFpbmluZy5nZXQoZGF0ZVN0cik/LmdldChkcmVhbUlkKSB8fCAwXG4gICAgXG4gICAgY29uc29sZS5sb2coYCAg8J+ThSAke2RhdGVTdHJ9OiBnbG9iYWw9JHtnbG9iYWxSZW1haW5pbmd9LCBwZXJEcmVhbT0ke3BlckRyZWFtUmVtYWluaW5nfWApXG4gICAgXG4gICAgaWYgKGdsb2JhbFJlbWFpbmluZyA+IDAgJiYgcGVyRHJlYW1SZW1haW5pbmcgPiAwKSB7XG4gICAgICBjb25zb2xlLmxvZyhgICDinIUgRm91bmQgY2FwYWNpdHktcmVzcGVjdGluZyBwbGFjZW1lbnQgb24gJHtkYXRlU3RyfWApXG4gICAgICByZXR1cm4ge1xuICAgICAgICBhY3Rpb25faWQ6IGFjdGlvbi5pZCxcbiAgICAgICAgZHJlYW1faWQ6IGRyZWFtSWQsXG4gICAgICAgIGFyZWFfaWQ6IGFjdGlvbi5hcmVhX2lkLFxuICAgICAgICBvY2N1cnJlbmNlX25vOiAxLFxuICAgICAgICBwbGFubmVkX2R1ZV9vbjogZGF0ZVN0cixcbiAgICAgICAgZHVlX29uOiBkYXRlU3RyLFxuICAgICAgICBpc19yZXBlYXQ6IGZhbHNlLFxuICAgICAgICBpc19maXhlZDogZmFsc2VcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgXG4gIC8vIFNlY29uZCBwYXNzOiBJZiBubyBjYXBhY2l0eS1yZXNwZWN0aW5nIHBsYWNlbWVudCBmb3VuZCwgZmluZCB0aGUgZWFybGllc3QgcG9zc2libGUgZGF0ZVxuICAvLyBUaGlzIGVuc3VyZXMgd2UgQUxXQVlTIHNjaGVkdWxlIHRoZSBhY3Rpb24sIGV2ZW4gaWYgaXQgYnJlYWtzIGNhcGFjaXR5IHJ1bGVzXG4gIGZvciAoY29uc3QgZGF5IG9mIGVsaWdpYmxlRGF5cykge1xuICAgIGlmIChkYXkgPCBtaW5EYXRlKSBjb250aW51ZVxuICAgIGlmIChkYXkgPiBtYXhEYXRlKSBicmVha1xuICAgIFxuICAgIGNvbnN0IGRhdGVTdHIgPSBkYXkudG9JU09TdHJpbmcoKS5zcGxpdCgnVCcpWzBdXG4gICAgY29uc29sZS5sb2coYCAg4pqg77iPICBVc2luZyBjYXBhY2l0eS1icmVha2luZyBwbGFjZW1lbnQgb24gJHtkYXRlU3RyfSAoYWR2aXNvcnkgY29uc3RyYWludCB2aW9sYXRlZClgKVxuICAgIFxuICAgIHJldHVybiB7XG4gICAgICBhY3Rpb25faWQ6IGFjdGlvbi5pZCxcbiAgICAgIGRyZWFtX2lkOiBkcmVhbUlkLFxuICAgICAgYXJlYV9pZDogYWN0aW9uLmFyZWFfaWQsXG4gICAgICBvY2N1cnJlbmNlX25vOiAxLFxuICAgICAgcGxhbm5lZF9kdWVfb246IGRhdGVTdHIsXG4gICAgICBkdWVfb246IGRhdGVTdHIsXG4gICAgICBpc19yZXBlYXQ6IGZhbHNlLFxuICAgICAgaXNfZml4ZWQ6IGZhbHNlXG4gICAgfVxuICB9XG4gIFxuICBjb25zb2xlLmxvZyhgICDinYwgTm8gcGxhY2VtZW50IHBvc3NpYmxlIHdpdGhpbiBkYXRlIHJhbmdlIGZvciBcIiR7YWN0aW9uLnRpdGxlfVwiYClcbiAgcmV0dXJuIG51bGxcbn1cblxuLyoqXG4gKiBIZWxwZXIgZnVuY3Rpb24gdG8gZmluZCBuZXh0IGF2YWlsYWJsZSBkYXRlIGZvciBiYWxhbmNpbmdcbiAqL1xuZnVuY3Rpb24gZmluZE5leHRBdmFpbGFibGVEYXRlKFxuICBwbGFjZW1lbnQ6IFNjaGVkdWxlZFBsYWNlbWVudCxcbiAgc3RhcnREYXRlOiBEYXRlLFxuICBtYXhEYXRlOiBEYXRlLFxuICBjYXBhY2l0eTogQ2FwYWNpdHlUcmFja2VyLFxuICBhbGxQbGFjZW1lbnRzOiBTY2hlZHVsZWRQbGFjZW1lbnRbXSxcbiAgYWN0aW9uczogQWN0aW9uW10sXG4gIGRhaWx5VGltZU1pbnV0ZXM/OiBudW1iZXIsXG4gIGF2b2lkRGF0ZXM/OiBTZXQ8c3RyaW5nPlxuKTogRGF0ZSB8IG51bGwge1xuICBjb25zdCBjdXJyZW50RGF0ZSA9IG5ldyBEYXRlKHN0YXJ0RGF0ZSlcbiAgY3VycmVudERhdGUuc2V0RGF0ZShjdXJyZW50RGF0ZS5nZXREYXRlKCkgKyAxKSAvLyBTdGFydCBmcm9tIG5leHQgZGF5XG4gIFxuICAvLyBDcmVhdGUgYWN0aW9uIGxvb2t1cCBtYXAgZm9yIHRpbWUgZXN0aW1hdGlvblxuICBjb25zdCBhY3Rpb25NYXAgPSBuZXcgTWFwKGFjdGlvbnMubWFwKGFjdGlvbiA9PiBbYWN0aW9uLmlkLCBhY3Rpb25dKSlcbiAgY29uc3QgY3VycmVudEFjdGlvbiA9IGFjdGlvbk1hcC5nZXQocGxhY2VtZW50LmFjdGlvbl9pZClcbiAgY29uc3QgY3VycmVudEFjdGlvblRpbWUgPSBjdXJyZW50QWN0aW9uPy5lc3RfbWludXRlcyB8fCAwXG4gIFxuICAvLyBGaXJzdCBwYXNzOiBUcnkgdG8gZmluZCBhIGRhdGUgdGhhdCByZXNwZWN0cyBjYXBhY2l0eSBhbmQsIHdoZW4gcmVhc29uYWJsZSwgdGltZSBjb25zdHJhaW50c1xuICB3aGlsZSAoY3VycmVudERhdGUgPD0gbWF4RGF0ZSkge1xuICAgIGNvbnN0IGRhdGVTdHIgPSBjdXJyZW50RGF0ZS50b0lTT1N0cmluZygpLnNwbGl0KCdUJylbMF1cbiAgICBjb25zdCBkYXlPZldlZWsgPSBjdXJyZW50RGF0ZS5nZXREYXkoKVxuICAgIFxuICAgIC8vIFNraXAgcmVzdCBkYXlzXG4gICAgaWYgKFJFU1RfREFZUy5oYXMoZGF5T2ZXZWVrKSkge1xuICAgICAgY3VycmVudERhdGUuc2V0RGF0ZShjdXJyZW50RGF0ZS5nZXREYXRlKCkgKyAxKVxuICAgICAgY29udGludWVcbiAgICB9XG4gICAgXG4gICAgY29uc3QgZ2xvYmFsUmVtYWluaW5nID0gY2FwYWNpdHkuZ2xvYmFsX3JlbWFpbmluZy5nZXQoZGF0ZVN0cikgPz8gMFxuICAgIGNvbnN0IHBlckRyZWFtUmVtYWluaW5nID0gY2FwYWNpdHkucGVyX2RyZWFtX3JlbWFpbmluZy5nZXQoZGF0ZVN0cik/LmdldChwbGFjZW1lbnQuZHJlYW1faWQpID8/IDBcbiAgICBcbiAgICAvLyBDYXBhY2l0eSBpcyBhZHZpc29yeTogZG8gbm90IGJsb2NrIHBsYWNlbWVudCBzb2xlbHkgZHVlIHRvIHNsb3QgY291bnRzXG4gICAgLy8gKFdlIHN0aWxsIHByZWZlciBsb3dlci1sb2FkIGRheXMgaW4gZmFsbGJhY2spXG4gICAgXG4gICAgLy8gQ2hlY2sgdGltZSBjb25zdHJhaW50cyBpZiBkYWlseSB0aW1lIGJ1ZGdldCBpcyBwcm92aWRlZFxuICAgIC8vIElmIHRoZSBzaW5nbGUgYWN0aW9uIGl0c2VsZiBleGNlZWRzIHRoZSBkYWlseSBidWRnZXQsIGFsbG93IHBsYWNlbWVudCAoYWR2aXNvcnkgY29uc3RyYWludClcbiAgICBpZiAoZGFpbHlUaW1lTWludXRlcyAmJiBjdXJyZW50QWN0aW9uVGltZSA+IDAgJiYgY3VycmVudEFjdGlvblRpbWUgPD0gZGFpbHlUaW1lTWludXRlcykge1xuICAgICAgY29uc3QgZGF5UGxhY2VtZW50cyA9IGFsbFBsYWNlbWVudHMuZmlsdGVyKHAgPT4gcC5kdWVfb24gPT09IGRhdGVTdHIpXG4gICAgICBsZXQgdG90YWxEYXlUaW1lID0gMFxuICAgICAgZm9yIChjb25zdCBkYXlQbGFjZW1lbnQgb2YgZGF5UGxhY2VtZW50cykge1xuICAgICAgICBjb25zdCBhY3Rpb24gPSBhY3Rpb25NYXAuZ2V0KGRheVBsYWNlbWVudC5hY3Rpb25faWQpXG4gICAgICAgIGlmIChhY3Rpb24/LmVzdF9taW51dGVzKSB7XG4gICAgICAgICAgdG90YWxEYXlUaW1lICs9IGFjdGlvbi5lc3RfbWludXRlc1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBcbiAgICAgIC8vIENoZWNrIGlmIGFkZGluZyB0aGlzIGFjdGlvbiB3b3VsZCBleGNlZWQgdGhlIHRpbWUgYnVkZ2V0XG4gICAgICBpZiAodG90YWxEYXlUaW1lICsgY3VycmVudEFjdGlvblRpbWUgPiBkYWlseVRpbWVNaW51dGVzKSB7XG4gICAgICAgIGN1cnJlbnREYXRlLnNldERhdGUoY3VycmVudERhdGUuZ2V0RGF0ZSgpICsgMSlcbiAgICAgICAgY29udGludWVcbiAgICAgIH1cbiAgICB9XG4gICAgXG4gICAgaWYgKGF2b2lkRGF0ZXMgJiYgYXZvaWREYXRlcy5oYXMoZGF0ZVN0cikpIHtcbiAgICAgIGN1cnJlbnREYXRlLnNldERhdGUoY3VycmVudERhdGUuZ2V0RGF0ZSgpICsgMSlcbiAgICAgIGNvbnRpbnVlXG4gICAgfVxuICAgIFxuICAgIHJldHVybiBjdXJyZW50RGF0ZVxuICB9XG4gIFxuICAvLyBTZWNvbmQgcGFzczogSWYgbm8gY2FwYWNpdHkvdGltZS1yZXNwZWN0aW5nIGRhdGUgZm91bmQsIGNob29zZSBlYXJsaWVzdCBhbW9uZyBLIGxpZ2h0ZXN0IGZ1dHVyZSBkYXlzXG4gIC8vIFByaW9yaXR5IDE6IE1pbmltaXplIG51bWJlciBvZiBiaWcgYWN0aW9ucyAoPiBkYWlseVRpbWVNaW51dGVzKSBvbiB0aGF0IGRheVxuICAvLyBQcmlvcml0eSAyOiBNaW5pbWl6ZSB0b3RhbCBzY2hlZHVsZWQgdGltZSBvbiB0aGF0IGRheVxuICBsZXQgYmVzdERhdGU6IERhdGUgfCBudWxsID0gbnVsbFxuICBsZXQgYmVzdEJpZ0NvdW50ID0gTnVtYmVyLlBPU0lUSVZFX0lORklOSVRZXG4gIGxldCBiZXN0TG9hZCA9IE51bWJlci5QT1NJVElWRV9JTkZJTklUWVxuICBjb25zdCBjYW5kaWRhdGVzOiB7IGRhdGU6IERhdGU7IGJpZzogbnVtYmVyOyBsb2FkOiBudW1iZXIgfVtdID0gW11cbiAgXG4gIGNvbnN0IHNjYW5EYXRlID0gbmV3IERhdGUoc3RhcnREYXRlKVxuICBzY2FuRGF0ZS5zZXREYXRlKHNjYW5EYXRlLmdldERhdGUoKSArIDEpXG4gIFxuICB3aGlsZSAoc2NhbkRhdGUgPD0gbWF4RGF0ZSkge1xuICAgIGNvbnN0IGRheU9mV2VlayA9IHNjYW5EYXRlLmdldERheSgpXG4gICAgaWYgKFJFU1RfREFZUy5oYXMoZGF5T2ZXZWVrKSkge1xuICAgICAgc2NhbkRhdGUuc2V0RGF0ZShzY2FuRGF0ZS5nZXREYXRlKCkgKyAxKVxuICAgICAgY29udGludWVcbiAgICB9XG4gICAgY29uc3QgZGF0ZVN0ciA9IHNjYW5EYXRlLnRvSVNPU3RyaW5nKCkuc3BsaXQoJ1QnKVswXVxuICAgIGlmIChhdm9pZERhdGVzICYmIGF2b2lkRGF0ZXMuaGFzKGRhdGVTdHIpKSB7XG4gICAgICBzY2FuRGF0ZS5zZXREYXRlKHNjYW5EYXRlLmdldERhdGUoKSArIDEpXG4gICAgICBjb250aW51ZVxuICAgIH1cbiAgICBjb25zdCBkYXlQbGFjZW1lbnRzID0gYWxsUGxhY2VtZW50cy5maWx0ZXIocCA9PiBwLmR1ZV9vbiA9PT0gZGF0ZVN0cilcbiAgICBsZXQgdG90YWxEYXlUaW1lID0gMFxuICAgIGxldCBiaWdDb3VudCA9IDBcbiAgICBmb3IgKGNvbnN0IGRheVBsYWNlbWVudCBvZiBkYXlQbGFjZW1lbnRzKSB7XG4gICAgICBjb25zdCBhY3Rpb24gPSBhY3Rpb25NYXAuZ2V0KGRheVBsYWNlbWVudC5hY3Rpb25faWQpXG4gICAgICBpZiAoIWFjdGlvbikgY29udGludWVcbiAgICAgIGNvbnN0IG1pbnMgPSBhY3Rpb24uZXN0X21pbnV0ZXMgfHwgMFxuICAgICAgdG90YWxEYXlUaW1lICs9IG1pbnNcbiAgICAgIGlmIChkYWlseVRpbWVNaW51dGVzICYmIG1pbnMgPiBkYWlseVRpbWVNaW51dGVzKSBiaWdDb3VudCsrXG4gICAgfVxuICAgIGNhbmRpZGF0ZXMucHVzaCh7IGRhdGU6IG5ldyBEYXRlKHNjYW5EYXRlKSwgYmlnOiBiaWdDb3VudCwgbG9hZDogdG90YWxEYXlUaW1lIH0pXG4gICAgc2NhbkRhdGUuc2V0RGF0ZShzY2FuRGF0ZS5nZXREYXRlKCkgKyAxKVxuICB9XG4gIFxuICBpZiAoY2FuZGlkYXRlcy5sZW5ndGggPiAwKSB7XG4gICAgY2FuZGlkYXRlcy5zb3J0KChhLCBiKSA9PiB7XG4gICAgICBpZiAoYS5iaWcgIT09IGIuYmlnKSByZXR1cm4gYS5iaWcgLSBiLmJpZ1xuICAgICAgaWYgKGEubG9hZCAhPT0gYi5sb2FkKSByZXR1cm4gYS5sb2FkIC0gYi5sb2FkXG4gICAgICByZXR1cm4gYS5kYXRlLmdldFRpbWUoKSAtIGIuZGF0ZS5nZXRUaW1lKClcbiAgICB9KVxuICAgIC8vIFBpY2sgZWFybGllc3QgYW1vbmcgdG9wLUsgbGlnaHRlc3QgKEs9NykgdG8gcHJvbW90ZSBkaXN0cmlidXRpb25cbiAgICBjb25zdCBLID0gTWF0aC5taW4oNywgY2FuZGlkYXRlcy5sZW5ndGgpXG4gICAgY29uc3QgY2hvaWNlID0gY2FuZGlkYXRlcy5zbGljZSgwLCBLKS5zb3J0KChhLCBiKSA9PiBhLmRhdGUuZ2V0VGltZSgpIC0gYi5kYXRlLmdldFRpbWUoKSlbMF1cbiAgICByZXR1cm4gY2hvaWNlLmRhdGVcbiAgfVxuICBcbiAgcmV0dXJuIG51bGxcbn1cbiJdLCJuYW1lcyI6WyJUQVJHRVRfUEVSX1dFRUsiLCJSRVNUX0RBWVMiLCJTZXQiLCJHTE9CQUxfREFJTFlfQ0FQIiwiUEVSX0RSRUFNX0NBUF9ERUZBVUxUIiwiUEVSX0RSRUFNX0NBUF9NQVgiLCJNSU5fR0FQX0RBWVNfQkVUV0VFTl9TRUVEUyIsIkRFRkFVTFRfREFJTFlfVElNRV9NSU5VVEVTIiwic2NoZWR1bGVEcmVhbUFjdGlvbnMiLCJjb250ZXh0IiwiZHJlYW1EYXRhIiwiZHJlYW0iLCJhcmVhcyIsImFjdGlvbnMiLCJleGlzdGluZ19vY2N1cnJlbmNlcyIsImNvbnNvbGUiLCJsb2ciLCJ0aXRsZSIsImFyZWFzQ291bnQiLCJsZW5ndGgiLCJhY3Rpb25zQ291bnQiLCJleGlzdGluZ09jY3VycmVuY2VzQ291bnQiLCJ3aW5kb3ciLCJjYWxjdWxhdGVTY2hlZHVsaW5nV2luZG93Iiwic3RhcnQiLCJzdGFydF9kYXRlIiwidG9JU09TdHJpbmciLCJzcGxpdCIsImVuZCIsImVuZF9kYXRlIiwiYXV0b0NvbXBhY3RlZCIsImF1dG9fY29tcGFjdGVkIiwiY2FwYWNpdHkiLCJidWlsZENhcGFjaXR5VHJhY2tlciIsInRpbWVfY29tbWl0bWVudCIsInRvdGFsRGF5cyIsImdsb2JhbF9yZW1haW5pbmciLCJzaXplIiwic2FtcGxlRGF5IiwiQXJyYXkiLCJmcm9tIiwiZW50cmllcyIsInNvcnRlZEFjdGlvbnMiLCJzb3J0QWN0aW9uc0J5UG9zaXRpb24iLCJtYXAiLCJhIiwicG9zaXRpb24iLCJhcmVhIiwiZmluZCIsImlkIiwiYXJlYV9pZCIsInNlZWRSZXN1bHRzIiwic2VlZEFsbEFjdGlvbnMiLCJwbGFjZW1lbnRzQ291bnQiLCJwbGFjZW1lbnRzIiwidGlnaHRQZW5kaW5nQ291bnQiLCJ0aWdodF9wZW5kaW5nIiwicmVwZWF0UmVzdWx0cyIsImV4cGFuZFJlcGVhdHMiLCJiYWxhbmNlZFJlc3VsdHMiLCJnbG9iYWxCYWxhbmNpbmciLCJmaW5hbFJlc3VsdHMiLCJ0aWdodEZhbGxiYWNrRXNjYWxhdGlvbiIsIm9jY3VycmVuY2VzIiwicGxhY2VtZW50IiwiYWN0aW9uX2lkIiwib2NjdXJyZW5jZV9ubyIsInBsYW5uZWRfZHVlX29uIiwiZHVlX29uIiwiZGVmZXJfY291bnQiLCJub3RlIiwidW5kZWZpbmVkIiwiY29tcGxldGVkX2F0IiwiYWlfcmF0aW5nIiwiYWlfZmVlZGJhY2siLCJjcmVhdGVkX2F0IiwiRGF0ZSIsInVwZGF0ZWRfYXQiLCJ0b3RhbE9jY3VycmVuY2VzIiwidG9vVGlnaHQiLCJ0b29fdGlnaHQiLCJ3YXJuaW5ncyIsInN1Y2Nlc3MiLCJlcnJvcnMiLCJyZWNvbW1lbmRlZF9lbmQiLCJlcnJvciIsIkVycm9yIiwibWVzc2FnZSIsInN0YXJ0RGF0ZSIsImVuZERhdGUiLCJzZWVkYWJsZUFjdGlvbnMiLCJmaWx0ZXIiLCJhY3Rpb24iLCJpc19hY3RpdmUiLCJkZWxldGVkX2F0IiwidGltZUNvbW1pdG1lbnQiLCJkYWlseVRpbWVNaW51dGVzIiwiaG91cnMiLCJtaW51dGVzIiwidG90YWxUaW1lTmVlZGVkIiwiZXN0X21pbnV0ZXMiLCJzbGljZV9jb3VudF90YXJnZXQiLCJyZXBlYXRfZXZlcnlfZGF5cyIsIndpbmRvd0RheXMiLCJNYXRoIiwiY2VpbCIsImdldFRpbWUiLCJub3ciLCJ3b3JrRGF5cyIsImZsb29yIiwibWF4Iiwid29ya0RheXNQZXJXZWVrIiwid2Vla2x5VGltZU1pbnV0ZXMiLCJ3ZWVrc05lZWRlZCIsInJlY29tbWVuZGVkRW5kIiwic2V0RGF0ZSIsImdldERhdGUiLCJ3aW5kb3dFbmQiLCJnbG9iYWxSZW1haW5pbmciLCJNYXAiLCJwZXJEcmVhbVJlbWFpbmluZyIsImVzdGltYXRlZFRpbWVQZXJBY3Rpb24iLCJ0aW1lQmFzZWREYWlseUNhcCIsImVmZmVjdGl2ZURhaWx5Q2FwIiwibWluIiwiZ2xvYmFsQ2FwIiwiY3VycmVudERhdGUiLCJkYXRlU3RyIiwiZGF5T2ZXZWVrIiwiZ2V0RGF5IiwiaGFzIiwic2V0IiwicGVyX2RyZWFtX3JlbWFpbmluZyIsImFyZWFQb3NpdGlvbk1hcCIsInNvcnQiLCJiIiwiYUFyZWFQb3MiLCJnZXQiLCJiQXJlYVBvcyIsImV4aXN0aW5nT2NjdXJyZW5jZXMiLCJ0aWdodFBlbmRpbmciLCJlbGlnaWJsZURheXMiLCJnZXRFbGlnaWJsZVdvcmtkYXlzIiwiZmlyc3REYXkiLCJsYXN0RGF5IiwiYWN0aW9uT2NjdXJyZW5jZUNvdW50cyIsImNvdW50IiwidG9GaXhlZCIsInRhcmdldERheUluZGljZXMiLCJvY2N1cnJlbmNlSW5kZXgiLCJpIiwidGFyZ2V0SW5kZXgiLCJyb3VuZCIsInB1c2giLCJzbGljZSIsImpvaW4iLCJjdXJyZW50T2NjdXJyZW5jZUluZGV4IiwiYWN0aW9uc0J5QXJlYSIsImFyZWFQb3NpdGlvbiIsInNvcnRlZEFyZWFQb3NpdGlvbnMiLCJrZXlzIiwiYXJlYUFjdGlvbnMiLCJleGlzdGluZ0FjdGlvbk9jY3VycmVuY2VzIiwib2NjIiwiZXhpc3RpbmdPY2MiLCJkcmVhbV9pZCIsImlzX3JlcGVhdCIsImlzX2ZpeGVkIiwib2NjdXJyZW5jZUNvdW50IiwidGFyZ2V0RGF5SW5kZXgiLCJ0YXJnZXREYXkiLCJjdXJyZW50R2xvYmFsIiwiY3VycmVudFBlckRyZWFtIiwic2VlZFBsYWNlbWVudHMiLCJzZWVkUGxhY2VtZW50IiwicCIsInNlZWREYXRlIiwib2NjdXJyZW5jZU5vIiwiYWxsUGxhY2VtZW50cyIsImFjdGlvbk1hcCIsIm1vdmVkUGxhY2VtZW50cyIsIk1BWF9JVEVSQVRJT05TIiwiaXRlcmF0aW9uIiwiaGFzQ2hhbmdlcyIsInVzZWRUYXJnZXREYXRlcyIsImRheVBsYWNlbWVudHMiLCJ0b3RhbERheVRpbWUiLCJtb3ZlYWJsZVBsYWNlbWVudHMiLCJhY3Rpb25BIiwiYWN0aW9uQiIsInRpbWVBIiwidGltZUIiLCJyZW1haW5pbmdUaW1lIiwiYXZvaWREYXRlcyIsIm5ld0RhdGUiLCJmaW5kTmV4dEF2YWlsYWJsZURhdGUiLCJhZGQiLCJjbGVhciIsImVzY2FsYXRlZENhcGFjaXR5IiwicGVyRHJlYW1NYXAiLCJhY3Rpb25JZCIsImZpbmRGZWFzaWJsZVBsYWNlbWVudCIsIm1heENhcGFjaXR5IiwibWF4UGxhY2VtZW50Iiwid29ya2RheXMiLCJkcmVhbUlkIiwibWluRGF0ZSIsIm1heERhdGUiLCJkYXkiLCJjdXJyZW50QWN0aW9uIiwiY3VycmVudEFjdGlvblRpbWUiLCJkYXlQbGFjZW1lbnQiLCJiZXN0RGF0ZSIsImJlc3RCaWdDb3VudCIsIk51bWJlciIsIlBPU0lUSVZFX0lORklOSVRZIiwiYmVzdExvYWQiLCJjYW5kaWRhdGVzIiwic2NhbkRhdGUiLCJiaWdDb3VudCIsIm1pbnMiLCJkYXRlIiwiYmlnIiwibG9hZCIsIksiLCJjaG9pY2UiXSwiaWdub3JlTGlzdCI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./lib/scheduling/scheduler.ts\n");

/***/ }),

/***/ "(rsc)/./lib/supabaseServer.ts":
/*!*******************************!*\
  !*** ./lib/supabaseServer.ts ***!
  \*******************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   supabaseServer: () => (/* binding */ supabaseServer),\n/* harmony export */   supabaseServerAuth: () => (/* binding */ supabaseServerAuth)\n/* harmony export */ });\n/* harmony import */ var _supabase_supabase_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @supabase/supabase-js */ \"(rsc)/./node_modules/@supabase/supabase-js/dist/module/index.js\");\n\n// Service role client (bypasses RLS) - use sparingly for admin operations\nfunction supabaseServer() {\n    return (0,_supabase_supabase_js__WEBPACK_IMPORTED_MODULE_0__.createClient)(process.env.SUPABASE_URL, process.env.SUPABASE_SERVICE_ROLE_KEY, {\n        auth: {\n            persistSession: false,\n            autoRefreshToken: false\n        }\n    });\n}\n// Authenticated client (respects RLS) - use for user operations\nfunction supabaseServerAuth(userToken) {\n    return (0,_supabase_supabase_js__WEBPACK_IMPORTED_MODULE_0__.createClient)(process.env.SUPABASE_URL, process.env.SUPABASE_ANON_KEY, {\n        global: {\n            headers: {\n                Authorization: `Bearer ${userToken}`\n            }\n        },\n        auth: {\n            persistSession: false,\n            autoRefreshToken: false\n        }\n    });\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9saWIvc3VwYWJhc2VTZXJ2ZXIudHMiLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQXFEO0FBRXJELDBFQUEwRTtBQUNuRSxTQUFTQztJQUNkLE9BQU9ELG1FQUFZQSxDQUNqQkUsUUFBUUMsR0FBRyxDQUFDQyxZQUFZLEVBQ3hCRixRQUFRQyxHQUFHLENBQUNFLHlCQUF5QixFQUNyQztRQUFFQyxNQUFNO1lBQUVDLGdCQUFnQjtZQUFPQyxrQkFBa0I7UUFBTTtJQUFFO0FBRS9EO0FBRUEsZ0VBQWdFO0FBQ3pELFNBQVNDLG1CQUFtQkMsU0FBaUI7SUFDbEQsT0FBT1YsbUVBQVlBLENBQ2pCRSxRQUFRQyxHQUFHLENBQUNDLFlBQVksRUFDeEJGLFFBQVFDLEdBQUcsQ0FBQ1EsaUJBQWlCLEVBQzdCO1FBQ0VDLFFBQVE7WUFDTkMsU0FBUztnQkFDUEMsZUFBZSxDQUFDLE9BQU8sRUFBRUosV0FBVztZQUN0QztRQUNGO1FBQ0FKLE1BQU07WUFBRUMsZ0JBQWdCO1lBQU9DLGtCQUFrQjtRQUFNO0lBQ3pEO0FBRUoiLCJzb3VyY2VzIjpbIi9Vc2Vycy9hbGV4L3JlZ3JldGxlc3MtMy9iYWNrZW5kL2xpYi9zdXBhYmFzZVNlcnZlci50cyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBjcmVhdGVDbGllbnQgfSBmcm9tICdAc3VwYWJhc2Uvc3VwYWJhc2UtanMnO1xuXG4vLyBTZXJ2aWNlIHJvbGUgY2xpZW50IChieXBhc3NlcyBSTFMpIC0gdXNlIHNwYXJpbmdseSBmb3IgYWRtaW4gb3BlcmF0aW9uc1xuZXhwb3J0IGZ1bmN0aW9uIHN1cGFiYXNlU2VydmVyKCkge1xuICByZXR1cm4gY3JlYXRlQ2xpZW50KFxuICAgIHByb2Nlc3MuZW52LlNVUEFCQVNFX1VSTCEsXG4gICAgcHJvY2Vzcy5lbnYuU1VQQUJBU0VfU0VSVklDRV9ST0xFX0tFWSEsXG4gICAgeyBhdXRoOiB7IHBlcnNpc3RTZXNzaW9uOiBmYWxzZSwgYXV0b1JlZnJlc2hUb2tlbjogZmFsc2UgfSB9XG4gICk7XG59XG5cbi8vIEF1dGhlbnRpY2F0ZWQgY2xpZW50IChyZXNwZWN0cyBSTFMpIC0gdXNlIGZvciB1c2VyIG9wZXJhdGlvbnNcbmV4cG9ydCBmdW5jdGlvbiBzdXBhYmFzZVNlcnZlckF1dGgodXNlclRva2VuOiBzdHJpbmcpIHtcbiAgcmV0dXJuIGNyZWF0ZUNsaWVudChcbiAgICBwcm9jZXNzLmVudi5TVVBBQkFTRV9VUkwhLFxuICAgIHByb2Nlc3MuZW52LlNVUEFCQVNFX0FOT05fS0VZISxcbiAgICB7XG4gICAgICBnbG9iYWw6IHtcbiAgICAgICAgaGVhZGVyczoge1xuICAgICAgICAgIEF1dGhvcml6YXRpb246IGBCZWFyZXIgJHt1c2VyVG9rZW59YFxuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgYXV0aDogeyBwZXJzaXN0U2Vzc2lvbjogZmFsc2UsIGF1dG9SZWZyZXNoVG9rZW46IGZhbHNlIH1cbiAgICB9XG4gICk7XG59XG5cblxuIl0sIm5hbWVzIjpbImNyZWF0ZUNsaWVudCIsInN1cGFiYXNlU2VydmVyIiwicHJvY2VzcyIsImVudiIsIlNVUEFCQVNFX1VSTCIsIlNVUEFCQVNFX1NFUlZJQ0VfUk9MRV9LRVkiLCJhdXRoIiwicGVyc2lzdFNlc3Npb24iLCJhdXRvUmVmcmVzaFRva2VuIiwic3VwYWJhc2VTZXJ2ZXJBdXRoIiwidXNlclRva2VuIiwiU1VQQUJBU0VfQU5PTl9LRVkiLCJnbG9iYWwiLCJoZWFkZXJzIiwiQXV0aG9yaXphdGlvbiJdLCJpZ25vcmVMaXN0IjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./lib/supabaseServer.ts\n");

/***/ }),

/***/ "(rsc)/./node_modules/next/dist/build/webpack/loaders/next-app-loader/index.js?name=app%2Fapi%2Fcreate%2Fschedule-actions%2Froute&page=%2Fapi%2Fcreate%2Fschedule-actions%2Froute&appPaths=&pagePath=private-next-app-dir%2Fapi%2Fcreate%2Fschedule-actions%2Froute.ts&appDir=%2FUsers%2Falex%2Fregretless-3%2Fbackend%2Fapp&pageExtensions=tsx&pageExtensions=ts&pageExtensions=jsx&pageExtensions=js&rootDir=%2FUsers%2Falex%2Fregretless-3%2Fbackend&isDev=true&tsconfigPath=tsconfig.json&basePath=&assetPrefix=&nextConfigOutput=&preferredRegion=&middlewareConfig=e30%3D&isGlobalNotFoundEnabled=!":
/*!**********************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/next/dist/build/webpack/loaders/next-app-loader/index.js?name=app%2Fapi%2Fcreate%2Fschedule-actions%2Froute&page=%2Fapi%2Fcreate%2Fschedule-actions%2Froute&appPaths=&pagePath=private-next-app-dir%2Fapi%2Fcreate%2Fschedule-actions%2Froute.ts&appDir=%2FUsers%2Falex%2Fregretless-3%2Fbackend%2Fapp&pageExtensions=tsx&pageExtensions=ts&pageExtensions=jsx&pageExtensions=js&rootDir=%2FUsers%2Falex%2Fregretless-3%2Fbackend&isDev=true&tsconfigPath=tsconfig.json&basePath=&assetPrefix=&nextConfigOutput=&preferredRegion=&middlewareConfig=e30%3D&isGlobalNotFoundEnabled=! ***!
  \**********************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   handler: () => (/* binding */ handler),\n/* harmony export */   patchFetch: () => (/* binding */ patchFetch),\n/* harmony export */   routeModule: () => (/* binding */ routeModule),\n/* harmony export */   serverHooks: () => (/* binding */ serverHooks),\n/* harmony export */   workAsyncStorage: () => (/* binding */ workAsyncStorage),\n/* harmony export */   workUnitAsyncStorage: () => (/* binding */ workUnitAsyncStorage)\n/* harmony export */ });\n/* harmony import */ var next_dist_server_route_modules_app_route_module_compiled__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! next/dist/server/route-modules/app-route/module.compiled */ \"(rsc)/./node_modules/next/dist/server/route-modules/app-route/module.compiled.js\");\n/* harmony import */ var next_dist_server_route_modules_app_route_module_compiled__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(next_dist_server_route_modules_app_route_module_compiled__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var next_dist_server_route_kind__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! next/dist/server/route-kind */ \"(rsc)/./node_modules/next/dist/server/route-kind.js\");\n/* harmony import */ var next_dist_server_lib_patch_fetch__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! next/dist/server/lib/patch-fetch */ \"(rsc)/./node_modules/next/dist/server/lib/patch-fetch.js\");\n/* harmony import */ var next_dist_server_lib_patch_fetch__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(next_dist_server_lib_patch_fetch__WEBPACK_IMPORTED_MODULE_2__);\n/* harmony import */ var next_dist_server_request_meta__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! next/dist/server/request-meta */ \"(rsc)/./node_modules/next/dist/server/request-meta.js\");\n/* harmony import */ var next_dist_server_request_meta__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(next_dist_server_request_meta__WEBPACK_IMPORTED_MODULE_3__);\n/* harmony import */ var next_dist_server_lib_trace_tracer__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! next/dist/server/lib/trace/tracer */ \"(rsc)/./node_modules/next/dist/server/lib/trace/tracer.js\");\n/* harmony import */ var next_dist_server_lib_trace_tracer__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(next_dist_server_lib_trace_tracer__WEBPACK_IMPORTED_MODULE_4__);\n/* harmony import */ var next_dist_shared_lib_router_utils_app_paths__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! next/dist/shared/lib/router/utils/app-paths */ \"next/dist/shared/lib/router/utils/app-paths\");\n/* harmony import */ var next_dist_shared_lib_router_utils_app_paths__WEBPACK_IMPORTED_MODULE_5___default = /*#__PURE__*/__webpack_require__.n(next_dist_shared_lib_router_utils_app_paths__WEBPACK_IMPORTED_MODULE_5__);\n/* harmony import */ var next_dist_server_base_http_node__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! next/dist/server/base-http/node */ \"(rsc)/./node_modules/next/dist/server/base-http/node.js\");\n/* harmony import */ var next_dist_server_base_http_node__WEBPACK_IMPORTED_MODULE_6___default = /*#__PURE__*/__webpack_require__.n(next_dist_server_base_http_node__WEBPACK_IMPORTED_MODULE_6__);\n/* harmony import */ var next_dist_server_web_spec_extension_adapters_next_request__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! next/dist/server/web/spec-extension/adapters/next-request */ \"(rsc)/./node_modules/next/dist/server/web/spec-extension/adapters/next-request.js\");\n/* harmony import */ var next_dist_server_web_spec_extension_adapters_next_request__WEBPACK_IMPORTED_MODULE_7___default = /*#__PURE__*/__webpack_require__.n(next_dist_server_web_spec_extension_adapters_next_request__WEBPACK_IMPORTED_MODULE_7__);\n/* harmony import */ var next_dist_server_lib_trace_constants__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! next/dist/server/lib/trace/constants */ \"(rsc)/./node_modules/next/dist/server/lib/trace/constants.js\");\n/* harmony import */ var next_dist_server_lib_trace_constants__WEBPACK_IMPORTED_MODULE_8___default = /*#__PURE__*/__webpack_require__.n(next_dist_server_lib_trace_constants__WEBPACK_IMPORTED_MODULE_8__);\n/* harmony import */ var next_dist_server_instrumentation_utils__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! next/dist/server/instrumentation/utils */ \"(rsc)/./node_modules/next/dist/server/instrumentation/utils.js\");\n/* harmony import */ var next_dist_server_send_response__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! next/dist/server/send-response */ \"(rsc)/./node_modules/next/dist/server/send-response.js\");\n/* harmony import */ var next_dist_server_web_utils__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! next/dist/server/web/utils */ \"(rsc)/./node_modules/next/dist/server/web/utils.js\");\n/* harmony import */ var next_dist_server_web_utils__WEBPACK_IMPORTED_MODULE_11___default = /*#__PURE__*/__webpack_require__.n(next_dist_server_web_utils__WEBPACK_IMPORTED_MODULE_11__);\n/* harmony import */ var next_dist_server_lib_cache_control__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! next/dist/server/lib/cache-control */ \"(rsc)/./node_modules/next/dist/server/lib/cache-control.js\");\n/* harmony import */ var next_dist_lib_constants__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! next/dist/lib/constants */ \"(rsc)/./node_modules/next/dist/lib/constants.js\");\n/* harmony import */ var next_dist_lib_constants__WEBPACK_IMPORTED_MODULE_13___default = /*#__PURE__*/__webpack_require__.n(next_dist_lib_constants__WEBPACK_IMPORTED_MODULE_13__);\n/* harmony import */ var next_dist_shared_lib_no_fallback_error_external__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! next/dist/shared/lib/no-fallback-error.external */ \"next/dist/shared/lib/no-fallback-error.external\");\n/* harmony import */ var next_dist_shared_lib_no_fallback_error_external__WEBPACK_IMPORTED_MODULE_14___default = /*#__PURE__*/__webpack_require__.n(next_dist_shared_lib_no_fallback_error_external__WEBPACK_IMPORTED_MODULE_14__);\n/* harmony import */ var next_dist_server_response_cache__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! next/dist/server/response-cache */ \"(rsc)/./node_modules/next/dist/server/response-cache/index.js\");\n/* harmony import */ var next_dist_server_response_cache__WEBPACK_IMPORTED_MODULE_15___default = /*#__PURE__*/__webpack_require__.n(next_dist_server_response_cache__WEBPACK_IMPORTED_MODULE_15__);\n/* harmony import */ var _Users_alex_regretless_3_backend_app_api_create_schedule_actions_route_ts__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! ./app/api/create/schedule-actions/route.ts */ \"(rsc)/./app/api/create/schedule-actions/route.ts\");\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n// We inject the nextConfigOutput here so that we can use them in the route\n// module.\nconst nextConfigOutput = \"\"\nconst routeModule = new next_dist_server_route_modules_app_route_module_compiled__WEBPACK_IMPORTED_MODULE_0__.AppRouteRouteModule({\n    definition: {\n        kind: next_dist_server_route_kind__WEBPACK_IMPORTED_MODULE_1__.RouteKind.APP_ROUTE,\n        page: \"/api/create/schedule-actions/route\",\n        pathname: \"/api/create/schedule-actions\",\n        filename: \"route\",\n        bundlePath: \"app/api/create/schedule-actions/route\"\n    },\n    distDir: \".next\" || 0,\n    relativeProjectDir:  false || '',\n    resolvedPagePath: \"/Users/alex/regretless-3/backend/app/api/create/schedule-actions/route.ts\",\n    nextConfigOutput,\n    userland: _Users_alex_regretless_3_backend_app_api_create_schedule_actions_route_ts__WEBPACK_IMPORTED_MODULE_16__\n});\n// Pull out the exports that we need to expose from the module. This should\n// be eliminated when we've moved the other routes to the new format. These\n// are used to hook into the route.\nconst { workAsyncStorage, workUnitAsyncStorage, serverHooks } = routeModule;\nfunction patchFetch() {\n    return (0,next_dist_server_lib_patch_fetch__WEBPACK_IMPORTED_MODULE_2__.patchFetch)({\n        workAsyncStorage,\n        workUnitAsyncStorage\n    });\n}\n\nasync function handler(req, res, ctx) {\n    var _nextConfig_experimental;\n    let srcPage = \"/api/create/schedule-actions/route\";\n    // turbopack doesn't normalize `/index` in the page name\n    // so we need to to process dynamic routes properly\n    // TODO: fix turbopack providing differing value from webpack\n    if (false) {} else if (srcPage === '/index') {\n        // we always normalize /index specifically\n        srcPage = '/';\n    }\n    const multiZoneDraftMode = false;\n    const prepareResult = await routeModule.prepare(req, res, {\n        srcPage,\n        multiZoneDraftMode\n    });\n    if (!prepareResult) {\n        res.statusCode = 400;\n        res.end('Bad Request');\n        ctx.waitUntil == null ? void 0 : ctx.waitUntil.call(ctx, Promise.resolve());\n        return null;\n    }\n    const { buildId, params, nextConfig, isDraftMode, prerenderManifest, routerServerContext, isOnDemandRevalidate, revalidateOnlyGenerated, resolvedPathname } = prepareResult;\n    const normalizedSrcPage = (0,next_dist_shared_lib_router_utils_app_paths__WEBPACK_IMPORTED_MODULE_5__.normalizeAppPath)(srcPage);\n    let isIsr = Boolean(prerenderManifest.dynamicRoutes[normalizedSrcPage] || prerenderManifest.routes[resolvedPathname]);\n    if (isIsr && !isDraftMode) {\n        const isPrerendered = Boolean(prerenderManifest.routes[resolvedPathname]);\n        const prerenderInfo = prerenderManifest.dynamicRoutes[normalizedSrcPage];\n        if (prerenderInfo) {\n            if (prerenderInfo.fallback === false && !isPrerendered) {\n                throw new next_dist_shared_lib_no_fallback_error_external__WEBPACK_IMPORTED_MODULE_14__.NoFallbackError();\n            }\n        }\n    }\n    let cacheKey = null;\n    if (isIsr && !routeModule.isDev && !isDraftMode) {\n        cacheKey = resolvedPathname;\n        // ensure /index and / is normalized to one key\n        cacheKey = cacheKey === '/index' ? '/' : cacheKey;\n    }\n    const supportsDynamicResponse = // If we're in development, we always support dynamic HTML\n    routeModule.isDev === true || // If this is not SSG or does not have static paths, then it supports\n    // dynamic HTML.\n    !isIsr;\n    // This is a revalidation request if the request is for a static\n    // page and it is not being resumed from a postponed render and\n    // it is not a dynamic RSC request then it is a revalidation\n    // request.\n    const isRevalidate = isIsr && !supportsDynamicResponse;\n    const method = req.method || 'GET';\n    const tracer = (0,next_dist_server_lib_trace_tracer__WEBPACK_IMPORTED_MODULE_4__.getTracer)();\n    const activeSpan = tracer.getActiveScopeSpan();\n    const context = {\n        params,\n        prerenderManifest,\n        renderOpts: {\n            experimental: {\n                cacheComponents: Boolean(nextConfig.experimental.cacheComponents),\n                authInterrupts: Boolean(nextConfig.experimental.authInterrupts)\n            },\n            supportsDynamicResponse,\n            incrementalCache: (0,next_dist_server_request_meta__WEBPACK_IMPORTED_MODULE_3__.getRequestMeta)(req, 'incrementalCache'),\n            cacheLifeProfiles: (_nextConfig_experimental = nextConfig.experimental) == null ? void 0 : _nextConfig_experimental.cacheLife,\n            isRevalidate,\n            waitUntil: ctx.waitUntil,\n            onClose: (cb)=>{\n                res.on('close', cb);\n            },\n            onAfterTaskError: undefined,\n            onInstrumentationRequestError: (error, _request, errorContext)=>routeModule.onRequestError(req, error, errorContext, routerServerContext)\n        },\n        sharedContext: {\n            buildId\n        }\n    };\n    const nodeNextReq = new next_dist_server_base_http_node__WEBPACK_IMPORTED_MODULE_6__.NodeNextRequest(req);\n    const nodeNextRes = new next_dist_server_base_http_node__WEBPACK_IMPORTED_MODULE_6__.NodeNextResponse(res);\n    const nextReq = next_dist_server_web_spec_extension_adapters_next_request__WEBPACK_IMPORTED_MODULE_7__.NextRequestAdapter.fromNodeNextRequest(nodeNextReq, (0,next_dist_server_web_spec_extension_adapters_next_request__WEBPACK_IMPORTED_MODULE_7__.signalFromNodeResponse)(res));\n    try {\n        const invokeRouteModule = async (span)=>{\n            return routeModule.handle(nextReq, context).finally(()=>{\n                if (!span) return;\n                span.setAttributes({\n                    'http.status_code': res.statusCode,\n                    'next.rsc': false\n                });\n                const rootSpanAttributes = tracer.getRootSpanAttributes();\n                // We were unable to get attributes, probably OTEL is not enabled\n                if (!rootSpanAttributes) {\n                    return;\n                }\n                if (rootSpanAttributes.get('next.span_type') !== next_dist_server_lib_trace_constants__WEBPACK_IMPORTED_MODULE_8__.BaseServerSpan.handleRequest) {\n                    console.warn(`Unexpected root span type '${rootSpanAttributes.get('next.span_type')}'. Please report this Next.js issue https://github.com/vercel/next.js`);\n                    return;\n                }\n                const route = rootSpanAttributes.get('next.route');\n                if (route) {\n                    const name = `${method} ${route}`;\n                    span.setAttributes({\n                        'next.route': route,\n                        'http.route': route,\n                        'next.span_name': name\n                    });\n                    span.updateName(name);\n                } else {\n                    span.updateName(`${method} ${req.url}`);\n                }\n            });\n        };\n        const handleResponse = async (currentSpan)=>{\n            var _cacheEntry_value;\n            const responseGenerator = async ({ previousCacheEntry })=>{\n                try {\n                    if (!(0,next_dist_server_request_meta__WEBPACK_IMPORTED_MODULE_3__.getRequestMeta)(req, 'minimalMode') && isOnDemandRevalidate && revalidateOnlyGenerated && !previousCacheEntry) {\n                        res.statusCode = 404;\n                        // on-demand revalidate always sets this header\n                        res.setHeader('x-nextjs-cache', 'REVALIDATED');\n                        res.end('This page could not be found');\n                        return null;\n                    }\n                    const response = await invokeRouteModule(currentSpan);\n                    req.fetchMetrics = context.renderOpts.fetchMetrics;\n                    let pendingWaitUntil = context.renderOpts.pendingWaitUntil;\n                    // Attempt using provided waitUntil if available\n                    // if it's not we fallback to sendResponse's handling\n                    if (pendingWaitUntil) {\n                        if (ctx.waitUntil) {\n                            ctx.waitUntil(pendingWaitUntil);\n                            pendingWaitUntil = undefined;\n                        }\n                    }\n                    const cacheTags = context.renderOpts.collectedTags;\n                    // If the request is for a static response, we can cache it so long\n                    // as it's not edge.\n                    if (isIsr) {\n                        const blob = await response.blob();\n                        // Copy the headers from the response.\n                        const headers = (0,next_dist_server_web_utils__WEBPACK_IMPORTED_MODULE_11__.toNodeOutgoingHttpHeaders)(response.headers);\n                        if (cacheTags) {\n                            headers[next_dist_lib_constants__WEBPACK_IMPORTED_MODULE_13__.NEXT_CACHE_TAGS_HEADER] = cacheTags;\n                        }\n                        if (!headers['content-type'] && blob.type) {\n                            headers['content-type'] = blob.type;\n                        }\n                        const revalidate = typeof context.renderOpts.collectedRevalidate === 'undefined' || context.renderOpts.collectedRevalidate >= next_dist_lib_constants__WEBPACK_IMPORTED_MODULE_13__.INFINITE_CACHE ? false : context.renderOpts.collectedRevalidate;\n                        const expire = typeof context.renderOpts.collectedExpire === 'undefined' || context.renderOpts.collectedExpire >= next_dist_lib_constants__WEBPACK_IMPORTED_MODULE_13__.INFINITE_CACHE ? undefined : context.renderOpts.collectedExpire;\n                        // Create the cache entry for the response.\n                        const cacheEntry = {\n                            value: {\n                                kind: next_dist_server_response_cache__WEBPACK_IMPORTED_MODULE_15__.CachedRouteKind.APP_ROUTE,\n                                status: response.status,\n                                body: Buffer.from(await blob.arrayBuffer()),\n                                headers\n                            },\n                            cacheControl: {\n                                revalidate,\n                                expire\n                            }\n                        };\n                        return cacheEntry;\n                    } else {\n                        // send response without caching if not ISR\n                        await (0,next_dist_server_send_response__WEBPACK_IMPORTED_MODULE_10__.sendResponse)(nodeNextReq, nodeNextRes, response, context.renderOpts.pendingWaitUntil);\n                        return null;\n                    }\n                } catch (err) {\n                    // if this is a background revalidate we need to report\n                    // the request error here as it won't be bubbled\n                    if (previousCacheEntry == null ? void 0 : previousCacheEntry.isStale) {\n                        await routeModule.onRequestError(req, err, {\n                            routerKind: 'App Router',\n                            routePath: srcPage,\n                            routeType: 'route',\n                            revalidateReason: (0,next_dist_server_instrumentation_utils__WEBPACK_IMPORTED_MODULE_9__.getRevalidateReason)({\n                                isRevalidate,\n                                isOnDemandRevalidate\n                            })\n                        }, routerServerContext);\n                    }\n                    throw err;\n                }\n            };\n            const cacheEntry = await routeModule.handleResponse({\n                req,\n                nextConfig,\n                cacheKey,\n                routeKind: next_dist_server_route_kind__WEBPACK_IMPORTED_MODULE_1__.RouteKind.APP_ROUTE,\n                isFallback: false,\n                prerenderManifest,\n                isRoutePPREnabled: false,\n                isOnDemandRevalidate,\n                revalidateOnlyGenerated,\n                responseGenerator,\n                waitUntil: ctx.waitUntil\n            });\n            // we don't create a cacheEntry for ISR\n            if (!isIsr) {\n                return null;\n            }\n            if ((cacheEntry == null ? void 0 : (_cacheEntry_value = cacheEntry.value) == null ? void 0 : _cacheEntry_value.kind) !== next_dist_server_response_cache__WEBPACK_IMPORTED_MODULE_15__.CachedRouteKind.APP_ROUTE) {\n                var _cacheEntry_value1;\n                throw Object.defineProperty(new Error(`Invariant: app-route received invalid cache entry ${cacheEntry == null ? void 0 : (_cacheEntry_value1 = cacheEntry.value) == null ? void 0 : _cacheEntry_value1.kind}`), \"__NEXT_ERROR_CODE\", {\n                    value: \"E701\",\n                    enumerable: false,\n                    configurable: true\n                });\n            }\n            if (!(0,next_dist_server_request_meta__WEBPACK_IMPORTED_MODULE_3__.getRequestMeta)(req, 'minimalMode')) {\n                res.setHeader('x-nextjs-cache', isOnDemandRevalidate ? 'REVALIDATED' : cacheEntry.isMiss ? 'MISS' : cacheEntry.isStale ? 'STALE' : 'HIT');\n            }\n            // Draft mode should never be cached\n            if (isDraftMode) {\n                res.setHeader('Cache-Control', 'private, no-cache, no-store, max-age=0, must-revalidate');\n            }\n            const headers = (0,next_dist_server_web_utils__WEBPACK_IMPORTED_MODULE_11__.fromNodeOutgoingHttpHeaders)(cacheEntry.value.headers);\n            if (!((0,next_dist_server_request_meta__WEBPACK_IMPORTED_MODULE_3__.getRequestMeta)(req, 'minimalMode') && isIsr)) {\n                headers.delete(next_dist_lib_constants__WEBPACK_IMPORTED_MODULE_13__.NEXT_CACHE_TAGS_HEADER);\n            }\n            // If cache control is already set on the response we don't\n            // override it to allow users to customize it via next.config\n            if (cacheEntry.cacheControl && !res.getHeader('Cache-Control') && !headers.get('Cache-Control')) {\n                headers.set('Cache-Control', (0,next_dist_server_lib_cache_control__WEBPACK_IMPORTED_MODULE_12__.getCacheControlHeader)(cacheEntry.cacheControl));\n            }\n            await (0,next_dist_server_send_response__WEBPACK_IMPORTED_MODULE_10__.sendResponse)(nodeNextReq, nodeNextRes, new Response(cacheEntry.value.body, {\n                headers,\n                status: cacheEntry.value.status || 200\n            }));\n            return null;\n        };\n        // TODO: activeSpan code path is for when wrapped by\n        // next-server can be removed when this is no longer used\n        if (activeSpan) {\n            await handleResponse(activeSpan);\n        } else {\n            await tracer.withPropagatedContext(req.headers, ()=>tracer.trace(next_dist_server_lib_trace_constants__WEBPACK_IMPORTED_MODULE_8__.BaseServerSpan.handleRequest, {\n                    spanName: `${method} ${req.url}`,\n                    kind: next_dist_server_lib_trace_tracer__WEBPACK_IMPORTED_MODULE_4__.SpanKind.SERVER,\n                    attributes: {\n                        'http.method': method,\n                        'http.target': req.url\n                    }\n                }, handleResponse));\n        }\n    } catch (err) {\n        // if we aren't wrapped by base-server handle here\n        if (!activeSpan && !(err instanceof next_dist_shared_lib_no_fallback_error_external__WEBPACK_IMPORTED_MODULE_14__.NoFallbackError)) {\n            await routeModule.onRequestError(req, err, {\n                routerKind: 'App Router',\n                routePath: normalizedSrcPage,\n                routeType: 'route',\n                revalidateReason: (0,next_dist_server_instrumentation_utils__WEBPACK_IMPORTED_MODULE_9__.getRevalidateReason)({\n                    isRevalidate,\n                    isOnDemandRevalidate\n                })\n            });\n        }\n        // rethrow so that we can handle serving error page\n        // If this is during static generation, throw the error again.\n        if (isIsr) throw err;\n        // Otherwise, send a 500 response.\n        await (0,next_dist_server_send_response__WEBPACK_IMPORTED_MODULE_10__.sendResponse)(nodeNextReq, nodeNextRes, new Response(null, {\n            status: 500\n        }));\n        return null;\n    }\n}\n\n//# sourceMappingURL=app-route.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2J1aWxkL3dlYnBhY2svbG9hZGVycy9uZXh0LWFwcC1sb2FkZXIvaW5kZXguanM/bmFtZT1hcHAlMkZhcGklMkZjcmVhdGUlMkZzY2hlZHVsZS1hY3Rpb25zJTJGcm91dGUmcGFnZT0lMkZhcGklMkZjcmVhdGUlMkZzY2hlZHVsZS1hY3Rpb25zJTJGcm91dGUmYXBwUGF0aHM9JnBhZ2VQYXRoPXByaXZhdGUtbmV4dC1hcHAtZGlyJTJGYXBpJTJGY3JlYXRlJTJGc2NoZWR1bGUtYWN0aW9ucyUyRnJvdXRlLnRzJmFwcERpcj0lMkZVc2VycyUyRmFsZXglMkZyZWdyZXRsZXNzLTMlMkZiYWNrZW5kJTJGYXBwJnBhZ2VFeHRlbnNpb25zPXRzeCZwYWdlRXh0ZW5zaW9ucz10cyZwYWdlRXh0ZW5zaW9ucz1qc3gmcGFnZUV4dGVuc2lvbnM9anMmcm9vdERpcj0lMkZVc2VycyUyRmFsZXglMkZyZWdyZXRsZXNzLTMlMkZiYWNrZW5kJmlzRGV2PXRydWUmdHNjb25maWdQYXRoPXRzY29uZmlnLmpzb24mYmFzZVBhdGg9JmFzc2V0UHJlZml4PSZuZXh0Q29uZmlnT3V0cHV0PSZwcmVmZXJyZWRSZWdpb249Jm1pZGRsZXdhcmVDb25maWc9ZTMwJTNEJmlzR2xvYmFsTm90Rm91bmRFbmFibGVkPSEiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBK0Y7QUFDdkM7QUFDcUI7QUFDZDtBQUNTO0FBQ087QUFDSztBQUNtQztBQUNqRDtBQUNPO0FBQ2Y7QUFDc0M7QUFDekI7QUFDTTtBQUNDO0FBQ2hCO0FBQ29DO0FBQ3RHO0FBQ0E7QUFDQTtBQUNBLHdCQUF3Qix5R0FBbUI7QUFDM0M7QUFDQSxjQUFjLGtFQUFTO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLGFBQWEsT0FBb0MsSUFBSSxDQUFFO0FBQ3ZELHdCQUF3QixNQUF1QztBQUMvRDtBQUNBO0FBQ0Es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Q2xFO0FBQ0Esa0JBQWtCLDZFQUFZO0FBQzlCO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWLDZFQUE2RSxnRkFBYztBQUMzRixpQ0FBaUMsUUFBUSxFQUFFLFFBQVE7QUFDbkQsMEJBQTBCLHVFQUFRO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsNENBQTRDLDZGQUFlO0FBQzNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDLDJGQUFtQjtBQUNyRDtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyw2RUFBWTtBQUMxQjtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7O0FBRUEiLCJzb3VyY2VzIjpbIiJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBBcHBSb3V0ZVJvdXRlTW9kdWxlIH0gZnJvbSBcIm5leHQvZGlzdC9zZXJ2ZXIvcm91dGUtbW9kdWxlcy9hcHAtcm91dGUvbW9kdWxlLmNvbXBpbGVkXCI7XG5pbXBvcnQgeyBSb3V0ZUtpbmQgfSBmcm9tIFwibmV4dC9kaXN0L3NlcnZlci9yb3V0ZS1raW5kXCI7XG5pbXBvcnQgeyBwYXRjaEZldGNoIGFzIF9wYXRjaEZldGNoIH0gZnJvbSBcIm5leHQvZGlzdC9zZXJ2ZXIvbGliL3BhdGNoLWZldGNoXCI7XG5pbXBvcnQgeyBnZXRSZXF1ZXN0TWV0YSB9IGZyb20gXCJuZXh0L2Rpc3Qvc2VydmVyL3JlcXVlc3QtbWV0YVwiO1xuaW1wb3J0IHsgZ2V0VHJhY2VyLCBTcGFuS2luZCB9IGZyb20gXCJuZXh0L2Rpc3Qvc2VydmVyL2xpYi90cmFjZS90cmFjZXJcIjtcbmltcG9ydCB7IG5vcm1hbGl6ZUFwcFBhdGggfSBmcm9tIFwibmV4dC9kaXN0L3NoYXJlZC9saWIvcm91dGVyL3V0aWxzL2FwcC1wYXRoc1wiO1xuaW1wb3J0IHsgTm9kZU5leHRSZXF1ZXN0LCBOb2RlTmV4dFJlc3BvbnNlIH0gZnJvbSBcIm5leHQvZGlzdC9zZXJ2ZXIvYmFzZS1odHRwL25vZGVcIjtcbmltcG9ydCB7IE5leHRSZXF1ZXN0QWRhcHRlciwgc2lnbmFsRnJvbU5vZGVSZXNwb25zZSB9IGZyb20gXCJuZXh0L2Rpc3Qvc2VydmVyL3dlYi9zcGVjLWV4dGVuc2lvbi9hZGFwdGVycy9uZXh0LXJlcXVlc3RcIjtcbmltcG9ydCB7IEJhc2VTZXJ2ZXJTcGFuIH0gZnJvbSBcIm5leHQvZGlzdC9zZXJ2ZXIvbGliL3RyYWNlL2NvbnN0YW50c1wiO1xuaW1wb3J0IHsgZ2V0UmV2YWxpZGF0ZVJlYXNvbiB9IGZyb20gXCJuZXh0L2Rpc3Qvc2VydmVyL2luc3RydW1lbnRhdGlvbi91dGlsc1wiO1xuaW1wb3J0IHsgc2VuZFJlc3BvbnNlIH0gZnJvbSBcIm5leHQvZGlzdC9zZXJ2ZXIvc2VuZC1yZXNwb25zZVwiO1xuaW1wb3J0IHsgZnJvbU5vZGVPdXRnb2luZ0h0dHBIZWFkZXJzLCB0b05vZGVPdXRnb2luZ0h0dHBIZWFkZXJzIH0gZnJvbSBcIm5leHQvZGlzdC9zZXJ2ZXIvd2ViL3V0aWxzXCI7XG5pbXBvcnQgeyBnZXRDYWNoZUNvbnRyb2xIZWFkZXIgfSBmcm9tIFwibmV4dC9kaXN0L3NlcnZlci9saWIvY2FjaGUtY29udHJvbFwiO1xuaW1wb3J0IHsgSU5GSU5JVEVfQ0FDSEUsIE5FWFRfQ0FDSEVfVEFHU19IRUFERVIgfSBmcm9tIFwibmV4dC9kaXN0L2xpYi9jb25zdGFudHNcIjtcbmltcG9ydCB7IE5vRmFsbGJhY2tFcnJvciB9IGZyb20gXCJuZXh0L2Rpc3Qvc2hhcmVkL2xpYi9uby1mYWxsYmFjay1lcnJvci5leHRlcm5hbFwiO1xuaW1wb3J0IHsgQ2FjaGVkUm91dGVLaW5kIH0gZnJvbSBcIm5leHQvZGlzdC9zZXJ2ZXIvcmVzcG9uc2UtY2FjaGVcIjtcbmltcG9ydCAqIGFzIHVzZXJsYW5kIGZyb20gXCIvVXNlcnMvYWxleC9yZWdyZXRsZXNzLTMvYmFja2VuZC9hcHAvYXBpL2NyZWF0ZS9zY2hlZHVsZS1hY3Rpb25zL3JvdXRlLnRzXCI7XG4vLyBXZSBpbmplY3QgdGhlIG5leHRDb25maWdPdXRwdXQgaGVyZSBzbyB0aGF0IHdlIGNhbiB1c2UgdGhlbSBpbiB0aGUgcm91dGVcbi8vIG1vZHVsZS5cbmNvbnN0IG5leHRDb25maWdPdXRwdXQgPSBcIlwiXG5jb25zdCByb3V0ZU1vZHVsZSA9IG5ldyBBcHBSb3V0ZVJvdXRlTW9kdWxlKHtcbiAgICBkZWZpbml0aW9uOiB7XG4gICAgICAgIGtpbmQ6IFJvdXRlS2luZC5BUFBfUk9VVEUsXG4gICAgICAgIHBhZ2U6IFwiL2FwaS9jcmVhdGUvc2NoZWR1bGUtYWN0aW9ucy9yb3V0ZVwiLFxuICAgICAgICBwYXRobmFtZTogXCIvYXBpL2NyZWF0ZS9zY2hlZHVsZS1hY3Rpb25zXCIsXG4gICAgICAgIGZpbGVuYW1lOiBcInJvdXRlXCIsXG4gICAgICAgIGJ1bmRsZVBhdGg6IFwiYXBwL2FwaS9jcmVhdGUvc2NoZWR1bGUtYWN0aW9ucy9yb3V0ZVwiXG4gICAgfSxcbiAgICBkaXN0RGlyOiBwcm9jZXNzLmVudi5fX05FWFRfUkVMQVRJVkVfRElTVF9ESVIgfHwgJycsXG4gICAgcmVsYXRpdmVQcm9qZWN0RGlyOiBwcm9jZXNzLmVudi5fX05FWFRfUkVMQVRJVkVfUFJPSkVDVF9ESVIgfHwgJycsXG4gICAgcmVzb2x2ZWRQYWdlUGF0aDogXCIvVXNlcnMvYWxleC9yZWdyZXRsZXNzLTMvYmFja2VuZC9hcHAvYXBpL2NyZWF0ZS9zY2hlZHVsZS1hY3Rpb25zL3JvdXRlLnRzXCIsXG4gICAgbmV4dENvbmZpZ091dHB1dCxcbiAgICB1c2VybGFuZFxufSk7XG4vLyBQdWxsIG91dCB0aGUgZXhwb3J0cyB0aGF0IHdlIG5lZWQgdG8gZXhwb3NlIGZyb20gdGhlIG1vZHVsZS4gVGhpcyBzaG91bGRcbi8vIGJlIGVsaW1pbmF0ZWQgd2hlbiB3ZSd2ZSBtb3ZlZCB0aGUgb3RoZXIgcm91dGVzIHRvIHRoZSBuZXcgZm9ybWF0LiBUaGVzZVxuLy8gYXJlIHVzZWQgdG8gaG9vayBpbnRvIHRoZSByb3V0ZS5cbmNvbnN0IHsgd29ya0FzeW5jU3RvcmFnZSwgd29ya1VuaXRBc3luY1N0b3JhZ2UsIHNlcnZlckhvb2tzIH0gPSByb3V0ZU1vZHVsZTtcbmZ1bmN0aW9uIHBhdGNoRmV0Y2goKSB7XG4gICAgcmV0dXJuIF9wYXRjaEZldGNoKHtcbiAgICAgICAgd29ya0FzeW5jU3RvcmFnZSxcbiAgICAgICAgd29ya1VuaXRBc3luY1N0b3JhZ2VcbiAgICB9KTtcbn1cbmV4cG9ydCB7IHJvdXRlTW9kdWxlLCB3b3JrQXN5bmNTdG9yYWdlLCB3b3JrVW5pdEFzeW5jU3RvcmFnZSwgc2VydmVySG9va3MsIHBhdGNoRmV0Y2gsICB9O1xuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGhhbmRsZXIocmVxLCByZXMsIGN0eCkge1xuICAgIHZhciBfbmV4dENvbmZpZ19leHBlcmltZW50YWw7XG4gICAgbGV0IHNyY1BhZ2UgPSBcIi9hcGkvY3JlYXRlL3NjaGVkdWxlLWFjdGlvbnMvcm91dGVcIjtcbiAgICAvLyB0dXJib3BhY2sgZG9lc24ndCBub3JtYWxpemUgYC9pbmRleGAgaW4gdGhlIHBhZ2UgbmFtZVxuICAgIC8vIHNvIHdlIG5lZWQgdG8gdG8gcHJvY2VzcyBkeW5hbWljIHJvdXRlcyBwcm9wZXJseVxuICAgIC8vIFRPRE86IGZpeCB0dXJib3BhY2sgcHJvdmlkaW5nIGRpZmZlcmluZyB2YWx1ZSBmcm9tIHdlYnBhY2tcbiAgICBpZiAocHJvY2Vzcy5lbnYuVFVSQk9QQUNLKSB7XG4gICAgICAgIHNyY1BhZ2UgPSBzcmNQYWdlLnJlcGxhY2UoL1xcL2luZGV4JC8sICcnKSB8fCAnLyc7XG4gICAgfSBlbHNlIGlmIChzcmNQYWdlID09PSAnL2luZGV4Jykge1xuICAgICAgICAvLyB3ZSBhbHdheXMgbm9ybWFsaXplIC9pbmRleCBzcGVjaWZpY2FsbHlcbiAgICAgICAgc3JjUGFnZSA9ICcvJztcbiAgICB9XG4gICAgY29uc3QgbXVsdGlab25lRHJhZnRNb2RlID0gcHJvY2Vzcy5lbnYuX19ORVhUX01VTFRJX1pPTkVfRFJBRlRfTU9ERTtcbiAgICBjb25zdCBwcmVwYXJlUmVzdWx0ID0gYXdhaXQgcm91dGVNb2R1bGUucHJlcGFyZShyZXEsIHJlcywge1xuICAgICAgICBzcmNQYWdlLFxuICAgICAgICBtdWx0aVpvbmVEcmFmdE1vZGVcbiAgICB9KTtcbiAgICBpZiAoIXByZXBhcmVSZXN1bHQpIHtcbiAgICAgICAgcmVzLnN0YXR1c0NvZGUgPSA0MDA7XG4gICAgICAgIHJlcy5lbmQoJ0JhZCBSZXF1ZXN0Jyk7XG4gICAgICAgIGN0eC53YWl0VW50aWwgPT0gbnVsbCA/IHZvaWQgMCA6IGN0eC53YWl0VW50aWwuY2FsbChjdHgsIFByb21pc2UucmVzb2x2ZSgpKTtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGNvbnN0IHsgYnVpbGRJZCwgcGFyYW1zLCBuZXh0Q29uZmlnLCBpc0RyYWZ0TW9kZSwgcHJlcmVuZGVyTWFuaWZlc3QsIHJvdXRlclNlcnZlckNvbnRleHQsIGlzT25EZW1hbmRSZXZhbGlkYXRlLCByZXZhbGlkYXRlT25seUdlbmVyYXRlZCwgcmVzb2x2ZWRQYXRobmFtZSB9ID0gcHJlcGFyZVJlc3VsdDtcbiAgICBjb25zdCBub3JtYWxpemVkU3JjUGFnZSA9IG5vcm1hbGl6ZUFwcFBhdGgoc3JjUGFnZSk7XG4gICAgbGV0IGlzSXNyID0gQm9vbGVhbihwcmVyZW5kZXJNYW5pZmVzdC5keW5hbWljUm91dGVzW25vcm1hbGl6ZWRTcmNQYWdlXSB8fCBwcmVyZW5kZXJNYW5pZmVzdC5yb3V0ZXNbcmVzb2x2ZWRQYXRobmFtZV0pO1xuICAgIGlmIChpc0lzciAmJiAhaXNEcmFmdE1vZGUpIHtcbiAgICAgICAgY29uc3QgaXNQcmVyZW5kZXJlZCA9IEJvb2xlYW4ocHJlcmVuZGVyTWFuaWZlc3Qucm91dGVzW3Jlc29sdmVkUGF0aG5hbWVdKTtcbiAgICAgICAgY29uc3QgcHJlcmVuZGVySW5mbyA9IHByZXJlbmRlck1hbmlmZXN0LmR5bmFtaWNSb3V0ZXNbbm9ybWFsaXplZFNyY1BhZ2VdO1xuICAgICAgICBpZiAocHJlcmVuZGVySW5mbykge1xuICAgICAgICAgICAgaWYgKHByZXJlbmRlckluZm8uZmFsbGJhY2sgPT09IGZhbHNlICYmICFpc1ByZXJlbmRlcmVkKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IE5vRmFsbGJhY2tFcnJvcigpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGxldCBjYWNoZUtleSA9IG51bGw7XG4gICAgaWYgKGlzSXNyICYmICFyb3V0ZU1vZHVsZS5pc0RldiAmJiAhaXNEcmFmdE1vZGUpIHtcbiAgICAgICAgY2FjaGVLZXkgPSByZXNvbHZlZFBhdGhuYW1lO1xuICAgICAgICAvLyBlbnN1cmUgL2luZGV4IGFuZCAvIGlzIG5vcm1hbGl6ZWQgdG8gb25lIGtleVxuICAgICAgICBjYWNoZUtleSA9IGNhY2hlS2V5ID09PSAnL2luZGV4JyA/ICcvJyA6IGNhY2hlS2V5O1xuICAgIH1cbiAgICBjb25zdCBzdXBwb3J0c0R5bmFtaWNSZXNwb25zZSA9IC8vIElmIHdlJ3JlIGluIGRldmVsb3BtZW50LCB3ZSBhbHdheXMgc3VwcG9ydCBkeW5hbWljIEhUTUxcbiAgICByb3V0ZU1vZHVsZS5pc0RldiA9PT0gdHJ1ZSB8fCAvLyBJZiB0aGlzIGlzIG5vdCBTU0cgb3IgZG9lcyBub3QgaGF2ZSBzdGF0aWMgcGF0aHMsIHRoZW4gaXQgc3VwcG9ydHNcbiAgICAvLyBkeW5hbWljIEhUTUwuXG4gICAgIWlzSXNyO1xuICAgIC8vIFRoaXMgaXMgYSByZXZhbGlkYXRpb24gcmVxdWVzdCBpZiB0aGUgcmVxdWVzdCBpcyBmb3IgYSBzdGF0aWNcbiAgICAvLyBwYWdlIGFuZCBpdCBpcyBub3QgYmVpbmcgcmVzdW1lZCBmcm9tIGEgcG9zdHBvbmVkIHJlbmRlciBhbmRcbiAgICAvLyBpdCBpcyBub3QgYSBkeW5hbWljIFJTQyByZXF1ZXN0IHRoZW4gaXQgaXMgYSByZXZhbGlkYXRpb25cbiAgICAvLyByZXF1ZXN0LlxuICAgIGNvbnN0IGlzUmV2YWxpZGF0ZSA9IGlzSXNyICYmICFzdXBwb3J0c0R5bmFtaWNSZXNwb25zZTtcbiAgICBjb25zdCBtZXRob2QgPSByZXEubWV0aG9kIHx8ICdHRVQnO1xuICAgIGNvbnN0IHRyYWNlciA9IGdldFRyYWNlcigpO1xuICAgIGNvbnN0IGFjdGl2ZVNwYW4gPSB0cmFjZXIuZ2V0QWN0aXZlU2NvcGVTcGFuKCk7XG4gICAgY29uc3QgY29udGV4dCA9IHtcbiAgICAgICAgcGFyYW1zLFxuICAgICAgICBwcmVyZW5kZXJNYW5pZmVzdCxcbiAgICAgICAgcmVuZGVyT3B0czoge1xuICAgICAgICAgICAgZXhwZXJpbWVudGFsOiB7XG4gICAgICAgICAgICAgICAgY2FjaGVDb21wb25lbnRzOiBCb29sZWFuKG5leHRDb25maWcuZXhwZXJpbWVudGFsLmNhY2hlQ29tcG9uZW50cyksXG4gICAgICAgICAgICAgICAgYXV0aEludGVycnVwdHM6IEJvb2xlYW4obmV4dENvbmZpZy5leHBlcmltZW50YWwuYXV0aEludGVycnVwdHMpXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgc3VwcG9ydHNEeW5hbWljUmVzcG9uc2UsXG4gICAgICAgICAgICBpbmNyZW1lbnRhbENhY2hlOiBnZXRSZXF1ZXN0TWV0YShyZXEsICdpbmNyZW1lbnRhbENhY2hlJyksXG4gICAgICAgICAgICBjYWNoZUxpZmVQcm9maWxlczogKF9uZXh0Q29uZmlnX2V4cGVyaW1lbnRhbCA9IG5leHRDb25maWcuZXhwZXJpbWVudGFsKSA9PSBudWxsID8gdm9pZCAwIDogX25leHRDb25maWdfZXhwZXJpbWVudGFsLmNhY2hlTGlmZSxcbiAgICAgICAgICAgIGlzUmV2YWxpZGF0ZSxcbiAgICAgICAgICAgIHdhaXRVbnRpbDogY3R4LndhaXRVbnRpbCxcbiAgICAgICAgICAgIG9uQ2xvc2U6IChjYik9PntcbiAgICAgICAgICAgICAgICByZXMub24oJ2Nsb3NlJywgY2IpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIG9uQWZ0ZXJUYXNrRXJyb3I6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgIG9uSW5zdHJ1bWVudGF0aW9uUmVxdWVzdEVycm9yOiAoZXJyb3IsIF9yZXF1ZXN0LCBlcnJvckNvbnRleHQpPT5yb3V0ZU1vZHVsZS5vblJlcXVlc3RFcnJvcihyZXEsIGVycm9yLCBlcnJvckNvbnRleHQsIHJvdXRlclNlcnZlckNvbnRleHQpXG4gICAgICAgIH0sXG4gICAgICAgIHNoYXJlZENvbnRleHQ6IHtcbiAgICAgICAgICAgIGJ1aWxkSWRcbiAgICAgICAgfVxuICAgIH07XG4gICAgY29uc3Qgbm9kZU5leHRSZXEgPSBuZXcgTm9kZU5leHRSZXF1ZXN0KHJlcSk7XG4gICAgY29uc3Qgbm9kZU5leHRSZXMgPSBuZXcgTm9kZU5leHRSZXNwb25zZShyZXMpO1xuICAgIGNvbnN0IG5leHRSZXEgPSBOZXh0UmVxdWVzdEFkYXB0ZXIuZnJvbU5vZGVOZXh0UmVxdWVzdChub2RlTmV4dFJlcSwgc2lnbmFsRnJvbU5vZGVSZXNwb25zZShyZXMpKTtcbiAgICB0cnkge1xuICAgICAgICBjb25zdCBpbnZva2VSb3V0ZU1vZHVsZSA9IGFzeW5jIChzcGFuKT0+e1xuICAgICAgICAgICAgcmV0dXJuIHJvdXRlTW9kdWxlLmhhbmRsZShuZXh0UmVxLCBjb250ZXh0KS5maW5hbGx5KCgpPT57XG4gICAgICAgICAgICAgICAgaWYgKCFzcGFuKSByZXR1cm47XG4gICAgICAgICAgICAgICAgc3Bhbi5zZXRBdHRyaWJ1dGVzKHtcbiAgICAgICAgICAgICAgICAgICAgJ2h0dHAuc3RhdHVzX2NvZGUnOiByZXMuc3RhdHVzQ29kZSxcbiAgICAgICAgICAgICAgICAgICAgJ25leHQucnNjJzogZmFsc2VcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBjb25zdCByb290U3BhbkF0dHJpYnV0ZXMgPSB0cmFjZXIuZ2V0Um9vdFNwYW5BdHRyaWJ1dGVzKCk7XG4gICAgICAgICAgICAgICAgLy8gV2Ugd2VyZSB1bmFibGUgdG8gZ2V0IGF0dHJpYnV0ZXMsIHByb2JhYmx5IE9URUwgaXMgbm90IGVuYWJsZWRcbiAgICAgICAgICAgICAgICBpZiAoIXJvb3RTcGFuQXR0cmlidXRlcykge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChyb290U3BhbkF0dHJpYnV0ZXMuZ2V0KCduZXh0LnNwYW5fdHlwZScpICE9PSBCYXNlU2VydmVyU3Bhbi5oYW5kbGVSZXF1ZXN0KSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybihgVW5leHBlY3RlZCByb290IHNwYW4gdHlwZSAnJHtyb290U3BhbkF0dHJpYnV0ZXMuZ2V0KCduZXh0LnNwYW5fdHlwZScpfScuIFBsZWFzZSByZXBvcnQgdGhpcyBOZXh0LmpzIGlzc3VlIGh0dHBzOi8vZ2l0aHViLmNvbS92ZXJjZWwvbmV4dC5qc2ApO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnN0IHJvdXRlID0gcm9vdFNwYW5BdHRyaWJ1dGVzLmdldCgnbmV4dC5yb3V0ZScpO1xuICAgICAgICAgICAgICAgIGlmIChyb3V0ZSkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBuYW1lID0gYCR7bWV0aG9kfSAke3JvdXRlfWA7XG4gICAgICAgICAgICAgICAgICAgIHNwYW4uc2V0QXR0cmlidXRlcyh7XG4gICAgICAgICAgICAgICAgICAgICAgICAnbmV4dC5yb3V0ZSc6IHJvdXRlLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ2h0dHAucm91dGUnOiByb3V0ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICduZXh0LnNwYW5fbmFtZSc6IG5hbWVcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIHNwYW4udXBkYXRlTmFtZShuYW1lKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBzcGFuLnVwZGF0ZU5hbWUoYCR7bWV0aG9kfSAke3JlcS51cmx9YCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IGhhbmRsZVJlc3BvbnNlID0gYXN5bmMgKGN1cnJlbnRTcGFuKT0+e1xuICAgICAgICAgICAgdmFyIF9jYWNoZUVudHJ5X3ZhbHVlO1xuICAgICAgICAgICAgY29uc3QgcmVzcG9uc2VHZW5lcmF0b3IgPSBhc3luYyAoeyBwcmV2aW91c0NhY2hlRW50cnkgfSk9PntcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIWdldFJlcXVlc3RNZXRhKHJlcSwgJ21pbmltYWxNb2RlJykgJiYgaXNPbkRlbWFuZFJldmFsaWRhdGUgJiYgcmV2YWxpZGF0ZU9ubHlHZW5lcmF0ZWQgJiYgIXByZXZpb3VzQ2FjaGVFbnRyeSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzLnN0YXR1c0NvZGUgPSA0MDQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBvbi1kZW1hbmQgcmV2YWxpZGF0ZSBhbHdheXMgc2V0cyB0aGlzIGhlYWRlclxuICAgICAgICAgICAgICAgICAgICAgICAgcmVzLnNldEhlYWRlcigneC1uZXh0anMtY2FjaGUnLCAnUkVWQUxJREFURUQnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlcy5lbmQoJ1RoaXMgcGFnZSBjb3VsZCBub3QgYmUgZm91bmQnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgaW52b2tlUm91dGVNb2R1bGUoY3VycmVudFNwYW4pO1xuICAgICAgICAgICAgICAgICAgICByZXEuZmV0Y2hNZXRyaWNzID0gY29udGV4dC5yZW5kZXJPcHRzLmZldGNoTWV0cmljcztcbiAgICAgICAgICAgICAgICAgICAgbGV0IHBlbmRpbmdXYWl0VW50aWwgPSBjb250ZXh0LnJlbmRlck9wdHMucGVuZGluZ1dhaXRVbnRpbDtcbiAgICAgICAgICAgICAgICAgICAgLy8gQXR0ZW1wdCB1c2luZyBwcm92aWRlZCB3YWl0VW50aWwgaWYgYXZhaWxhYmxlXG4gICAgICAgICAgICAgICAgICAgIC8vIGlmIGl0J3Mgbm90IHdlIGZhbGxiYWNrIHRvIHNlbmRSZXNwb25zZSdzIGhhbmRsaW5nXG4gICAgICAgICAgICAgICAgICAgIGlmIChwZW5kaW5nV2FpdFVudGlsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoY3R4LndhaXRVbnRpbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN0eC53YWl0VW50aWwocGVuZGluZ1dhaXRVbnRpbCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcGVuZGluZ1dhaXRVbnRpbCA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjb25zdCBjYWNoZVRhZ3MgPSBjb250ZXh0LnJlbmRlck9wdHMuY29sbGVjdGVkVGFncztcbiAgICAgICAgICAgICAgICAgICAgLy8gSWYgdGhlIHJlcXVlc3QgaXMgZm9yIGEgc3RhdGljIHJlc3BvbnNlLCB3ZSBjYW4gY2FjaGUgaXQgc28gbG9uZ1xuICAgICAgICAgICAgICAgICAgICAvLyBhcyBpdCdzIG5vdCBlZGdlLlxuICAgICAgICAgICAgICAgICAgICBpZiAoaXNJc3IpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGJsb2IgPSBhd2FpdCByZXNwb25zZS5ibG9iKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBDb3B5IHRoZSBoZWFkZXJzIGZyb20gdGhlIHJlc3BvbnNlLlxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgaGVhZGVycyA9IHRvTm9kZU91dGdvaW5nSHR0cEhlYWRlcnMocmVzcG9uc2UuaGVhZGVycyk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoY2FjaGVUYWdzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaGVhZGVyc1tORVhUX0NBQ0hFX1RBR1NfSEVBREVSXSA9IGNhY2hlVGFncztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghaGVhZGVyc1snY29udGVudC10eXBlJ10gJiYgYmxvYi50eXBlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaGVhZGVyc1snY29udGVudC10eXBlJ10gPSBibG9iLnR5cGU7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCByZXZhbGlkYXRlID0gdHlwZW9mIGNvbnRleHQucmVuZGVyT3B0cy5jb2xsZWN0ZWRSZXZhbGlkYXRlID09PSAndW5kZWZpbmVkJyB8fCBjb250ZXh0LnJlbmRlck9wdHMuY29sbGVjdGVkUmV2YWxpZGF0ZSA+PSBJTkZJTklURV9DQUNIRSA/IGZhbHNlIDogY29udGV4dC5yZW5kZXJPcHRzLmNvbGxlY3RlZFJldmFsaWRhdGU7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBleHBpcmUgPSB0eXBlb2YgY29udGV4dC5yZW5kZXJPcHRzLmNvbGxlY3RlZEV4cGlyZSA9PT0gJ3VuZGVmaW5lZCcgfHwgY29udGV4dC5yZW5kZXJPcHRzLmNvbGxlY3RlZEV4cGlyZSA+PSBJTkZJTklURV9DQUNIRSA/IHVuZGVmaW5lZCA6IGNvbnRleHQucmVuZGVyT3B0cy5jb2xsZWN0ZWRFeHBpcmU7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBDcmVhdGUgdGhlIGNhY2hlIGVudHJ5IGZvciB0aGUgcmVzcG9uc2UuXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBjYWNoZUVudHJ5ID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGtpbmQ6IENhY2hlZFJvdXRlS2luZC5BUFBfUk9VVEUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0YXR1czogcmVzcG9uc2Uuc3RhdHVzLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBib2R5OiBCdWZmZXIuZnJvbShhd2FpdCBibG9iLmFycmF5QnVmZmVyKCkpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBoZWFkZXJzXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYWNoZUNvbnRyb2w6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV2YWxpZGF0ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZXhwaXJlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBjYWNoZUVudHJ5O1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gc2VuZCByZXNwb25zZSB3aXRob3V0IGNhY2hpbmcgaWYgbm90IElTUlxuICAgICAgICAgICAgICAgICAgICAgICAgYXdhaXQgc2VuZFJlc3BvbnNlKG5vZGVOZXh0UmVxLCBub2RlTmV4dFJlcywgcmVzcG9uc2UsIGNvbnRleHQucmVuZGVyT3B0cy5wZW5kaW5nV2FpdFVudGlsKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGlmIHRoaXMgaXMgYSBiYWNrZ3JvdW5kIHJldmFsaWRhdGUgd2UgbmVlZCB0byByZXBvcnRcbiAgICAgICAgICAgICAgICAgICAgLy8gdGhlIHJlcXVlc3QgZXJyb3IgaGVyZSBhcyBpdCB3b24ndCBiZSBidWJibGVkXG4gICAgICAgICAgICAgICAgICAgIGlmIChwcmV2aW91c0NhY2hlRW50cnkgPT0gbnVsbCA/IHZvaWQgMCA6IHByZXZpb3VzQ2FjaGVFbnRyeS5pc1N0YWxlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhd2FpdCByb3V0ZU1vZHVsZS5vblJlcXVlc3RFcnJvcihyZXEsIGVyciwge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJvdXRlcktpbmQ6ICdBcHAgUm91dGVyJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByb3V0ZVBhdGg6IHNyY1BhZ2UsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcm91dGVUeXBlOiAncm91dGUnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldmFsaWRhdGVSZWFzb246IGdldFJldmFsaWRhdGVSZWFzb24oe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpc1JldmFsaWRhdGUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlzT25EZW1hbmRSZXZhbGlkYXRlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sIHJvdXRlclNlcnZlckNvbnRleHQpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHRocm93IGVycjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgY29uc3QgY2FjaGVFbnRyeSA9IGF3YWl0IHJvdXRlTW9kdWxlLmhhbmRsZVJlc3BvbnNlKHtcbiAgICAgICAgICAgICAgICByZXEsXG4gICAgICAgICAgICAgICAgbmV4dENvbmZpZyxcbiAgICAgICAgICAgICAgICBjYWNoZUtleSxcbiAgICAgICAgICAgICAgICByb3V0ZUtpbmQ6IFJvdXRlS2luZC5BUFBfUk9VVEUsXG4gICAgICAgICAgICAgICAgaXNGYWxsYmFjazogZmFsc2UsXG4gICAgICAgICAgICAgICAgcHJlcmVuZGVyTWFuaWZlc3QsXG4gICAgICAgICAgICAgICAgaXNSb3V0ZVBQUkVuYWJsZWQ6IGZhbHNlLFxuICAgICAgICAgICAgICAgIGlzT25EZW1hbmRSZXZhbGlkYXRlLFxuICAgICAgICAgICAgICAgIHJldmFsaWRhdGVPbmx5R2VuZXJhdGVkLFxuICAgICAgICAgICAgICAgIHJlc3BvbnNlR2VuZXJhdG9yLFxuICAgICAgICAgICAgICAgIHdhaXRVbnRpbDogY3R4LndhaXRVbnRpbFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAvLyB3ZSBkb24ndCBjcmVhdGUgYSBjYWNoZUVudHJ5IGZvciBJU1JcbiAgICAgICAgICAgIGlmICghaXNJc3IpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICgoY2FjaGVFbnRyeSA9PSBudWxsID8gdm9pZCAwIDogKF9jYWNoZUVudHJ5X3ZhbHVlID0gY2FjaGVFbnRyeS52YWx1ZSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9jYWNoZUVudHJ5X3ZhbHVlLmtpbmQpICE9PSBDYWNoZWRSb3V0ZUtpbmQuQVBQX1JPVVRFKSB7XG4gICAgICAgICAgICAgICAgdmFyIF9jYWNoZUVudHJ5X3ZhbHVlMTtcbiAgICAgICAgICAgICAgICB0aHJvdyBPYmplY3QuZGVmaW5lUHJvcGVydHkobmV3IEVycm9yKGBJbnZhcmlhbnQ6IGFwcC1yb3V0ZSByZWNlaXZlZCBpbnZhbGlkIGNhY2hlIGVudHJ5ICR7Y2FjaGVFbnRyeSA9PSBudWxsID8gdm9pZCAwIDogKF9jYWNoZUVudHJ5X3ZhbHVlMSA9IGNhY2hlRW50cnkudmFsdWUpID09IG51bGwgPyB2b2lkIDAgOiBfY2FjaGVFbnRyeV92YWx1ZTEua2luZH1gKSwgXCJfX05FWFRfRVJST1JfQ09ERVwiLCB7XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlOiBcIkU3MDFcIixcbiAgICAgICAgICAgICAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFnZXRSZXF1ZXN0TWV0YShyZXEsICdtaW5pbWFsTW9kZScpKSB7XG4gICAgICAgICAgICAgICAgcmVzLnNldEhlYWRlcigneC1uZXh0anMtY2FjaGUnLCBpc09uRGVtYW5kUmV2YWxpZGF0ZSA/ICdSRVZBTElEQVRFRCcgOiBjYWNoZUVudHJ5LmlzTWlzcyA/ICdNSVNTJyA6IGNhY2hlRW50cnkuaXNTdGFsZSA/ICdTVEFMRScgOiAnSElUJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBEcmFmdCBtb2RlIHNob3VsZCBuZXZlciBiZSBjYWNoZWRcbiAgICAgICAgICAgIGlmIChpc0RyYWZ0TW9kZSkge1xuICAgICAgICAgICAgICAgIHJlcy5zZXRIZWFkZXIoJ0NhY2hlLUNvbnRyb2wnLCAncHJpdmF0ZSwgbm8tY2FjaGUsIG5vLXN0b3JlLCBtYXgtYWdlPTAsIG11c3QtcmV2YWxpZGF0ZScpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgaGVhZGVycyA9IGZyb21Ob2RlT3V0Z29pbmdIdHRwSGVhZGVycyhjYWNoZUVudHJ5LnZhbHVlLmhlYWRlcnMpO1xuICAgICAgICAgICAgaWYgKCEoZ2V0UmVxdWVzdE1ldGEocmVxLCAnbWluaW1hbE1vZGUnKSAmJiBpc0lzcikpIHtcbiAgICAgICAgICAgICAgICBoZWFkZXJzLmRlbGV0ZShORVhUX0NBQ0hFX1RBR1NfSEVBREVSKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIElmIGNhY2hlIGNvbnRyb2wgaXMgYWxyZWFkeSBzZXQgb24gdGhlIHJlc3BvbnNlIHdlIGRvbid0XG4gICAgICAgICAgICAvLyBvdmVycmlkZSBpdCB0byBhbGxvdyB1c2VycyB0byBjdXN0b21pemUgaXQgdmlhIG5leHQuY29uZmlnXG4gICAgICAgICAgICBpZiAoY2FjaGVFbnRyeS5jYWNoZUNvbnRyb2wgJiYgIXJlcy5nZXRIZWFkZXIoJ0NhY2hlLUNvbnRyb2wnKSAmJiAhaGVhZGVycy5nZXQoJ0NhY2hlLUNvbnRyb2wnKSkge1xuICAgICAgICAgICAgICAgIGhlYWRlcnMuc2V0KCdDYWNoZS1Db250cm9sJywgZ2V0Q2FjaGVDb250cm9sSGVhZGVyKGNhY2hlRW50cnkuY2FjaGVDb250cm9sKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBhd2FpdCBzZW5kUmVzcG9uc2Uobm9kZU5leHRSZXEsIG5vZGVOZXh0UmVzLCBuZXcgUmVzcG9uc2UoY2FjaGVFbnRyeS52YWx1ZS5ib2R5LCB7XG4gICAgICAgICAgICAgICAgaGVhZGVycyxcbiAgICAgICAgICAgICAgICBzdGF0dXM6IGNhY2hlRW50cnkudmFsdWUuc3RhdHVzIHx8IDIwMFxuICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH07XG4gICAgICAgIC8vIFRPRE86IGFjdGl2ZVNwYW4gY29kZSBwYXRoIGlzIGZvciB3aGVuIHdyYXBwZWQgYnlcbiAgICAgICAgLy8gbmV4dC1zZXJ2ZXIgY2FuIGJlIHJlbW92ZWQgd2hlbiB0aGlzIGlzIG5vIGxvbmdlciB1c2VkXG4gICAgICAgIGlmIChhY3RpdmVTcGFuKSB7XG4gICAgICAgICAgICBhd2FpdCBoYW5kbGVSZXNwb25zZShhY3RpdmVTcGFuKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGF3YWl0IHRyYWNlci53aXRoUHJvcGFnYXRlZENvbnRleHQocmVxLmhlYWRlcnMsICgpPT50cmFjZXIudHJhY2UoQmFzZVNlcnZlclNwYW4uaGFuZGxlUmVxdWVzdCwge1xuICAgICAgICAgICAgICAgICAgICBzcGFuTmFtZTogYCR7bWV0aG9kfSAke3JlcS51cmx9YCxcbiAgICAgICAgICAgICAgICAgICAga2luZDogU3BhbktpbmQuU0VSVkVSLFxuICAgICAgICAgICAgICAgICAgICBhdHRyaWJ1dGVzOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAnaHR0cC5tZXRob2QnOiBtZXRob2QsXG4gICAgICAgICAgICAgICAgICAgICAgICAnaHR0cC50YXJnZXQnOiByZXEudXJsXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9LCBoYW5kbGVSZXNwb25zZSkpO1xuICAgICAgICB9XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIC8vIGlmIHdlIGFyZW4ndCB3cmFwcGVkIGJ5IGJhc2Utc2VydmVyIGhhbmRsZSBoZXJlXG4gICAgICAgIGlmICghYWN0aXZlU3BhbiAmJiAhKGVyciBpbnN0YW5jZW9mIE5vRmFsbGJhY2tFcnJvcikpIHtcbiAgICAgICAgICAgIGF3YWl0IHJvdXRlTW9kdWxlLm9uUmVxdWVzdEVycm9yKHJlcSwgZXJyLCB7XG4gICAgICAgICAgICAgICAgcm91dGVyS2luZDogJ0FwcCBSb3V0ZXInLFxuICAgICAgICAgICAgICAgIHJvdXRlUGF0aDogbm9ybWFsaXplZFNyY1BhZ2UsXG4gICAgICAgICAgICAgICAgcm91dGVUeXBlOiAncm91dGUnLFxuICAgICAgICAgICAgICAgIHJldmFsaWRhdGVSZWFzb246IGdldFJldmFsaWRhdGVSZWFzb24oe1xuICAgICAgICAgICAgICAgICAgICBpc1JldmFsaWRhdGUsXG4gICAgICAgICAgICAgICAgICAgIGlzT25EZW1hbmRSZXZhbGlkYXRlXG4gICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIC8vIHJldGhyb3cgc28gdGhhdCB3ZSBjYW4gaGFuZGxlIHNlcnZpbmcgZXJyb3IgcGFnZVxuICAgICAgICAvLyBJZiB0aGlzIGlzIGR1cmluZyBzdGF0aWMgZ2VuZXJhdGlvbiwgdGhyb3cgdGhlIGVycm9yIGFnYWluLlxuICAgICAgICBpZiAoaXNJc3IpIHRocm93IGVycjtcbiAgICAgICAgLy8gT3RoZXJ3aXNlLCBzZW5kIGEgNTAwIHJlc3BvbnNlLlxuICAgICAgICBhd2FpdCBzZW5kUmVzcG9uc2Uobm9kZU5leHRSZXEsIG5vZGVOZXh0UmVzLCBuZXcgUmVzcG9uc2UobnVsbCwge1xuICAgICAgICAgICAgc3RhdHVzOiA1MDBcbiAgICAgICAgfSkpO1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG59XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWFwcC1yb3V0ZS5qcy5tYXBcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/next/dist/build/webpack/loaders/next-app-loader/index.js?name=app%2Fapi%2Fcreate%2Fschedule-actions%2Froute&page=%2Fapi%2Fcreate%2Fschedule-actions%2Froute&appPaths=&pagePath=private-next-app-dir%2Fapi%2Fcreate%2Fschedule-actions%2Froute.ts&appDir=%2FUsers%2Falex%2Fregretless-3%2Fbackend%2Fapp&pageExtensions=tsx&pageExtensions=ts&pageExtensions=jsx&pageExtensions=js&rootDir=%2FUsers%2Falex%2Fregretless-3%2Fbackend&isDev=true&tsconfigPath=tsconfig.json&basePath=&assetPrefix=&nextConfigOutput=&preferredRegion=&middlewareConfig=e30%3D&isGlobalNotFoundEnabled=!\n");

/***/ }),

/***/ "(rsc)/./node_modules/next/dist/build/webpack/loaders/next-flight-client-entry-loader.js?server=true!":
/*!******************************************************************************************************!*\
  !*** ./node_modules/next/dist/build/webpack/loaders/next-flight-client-entry-loader.js?server=true! ***!
  \******************************************************************************************************/
/***/ (() => {



/***/ }),

/***/ "(ssr)/./node_modules/next/dist/build/webpack/loaders/next-flight-client-entry-loader.js?server=true!":
/*!******************************************************************************************************!*\
  !*** ./node_modules/next/dist/build/webpack/loaders/next-flight-client-entry-loader.js?server=true! ***!
  \******************************************************************************************************/
/***/ (() => {



/***/ }),

/***/ "../app-render/action-async-storage.external":
/*!*******************************************************************************!*\
  !*** external "next/dist/server/app-render/action-async-storage.external.js" ***!
  \*******************************************************************************/
/***/ ((module) => {

"use strict";
module.exports = require("next/dist/server/app-render/action-async-storage.external.js");

/***/ }),

/***/ "../app-render/after-task-async-storage.external":
/*!***********************************************************************************!*\
  !*** external "next/dist/server/app-render/after-task-async-storage.external.js" ***!
  \***********************************************************************************/
/***/ ((module) => {

"use strict";
module.exports = require("next/dist/server/app-render/after-task-async-storage.external.js");

/***/ }),

/***/ "../app-render/work-async-storage.external":
/*!*****************************************************************************!*\
  !*** external "next/dist/server/app-render/work-async-storage.external.js" ***!
  \*****************************************************************************/
/***/ ((module) => {

"use strict";
module.exports = require("next/dist/server/app-render/work-async-storage.external.js");

/***/ }),

/***/ "../app-render/work-unit-async-storage.external":
/*!**********************************************************************************!*\
  !*** external "next/dist/server/app-render/work-unit-async-storage.external.js" ***!
  \**********************************************************************************/
/***/ ((module) => {

"use strict";
module.exports = require("next/dist/server/app-render/work-unit-async-storage.external.js");

/***/ }),

/***/ "http":
/*!***********************!*\
  !*** external "http" ***!
  \***********************/
/***/ ((module) => {

"use strict";
module.exports = require("http");

/***/ }),

/***/ "https":
/*!************************!*\
  !*** external "https" ***!
  \************************/
/***/ ((module) => {

"use strict";
module.exports = require("https");

/***/ }),

/***/ "next/dist/compiled/next-server/app-page.runtime.dev.js":
/*!*************************************************************************!*\
  !*** external "next/dist/compiled/next-server/app-page.runtime.dev.js" ***!
  \*************************************************************************/
/***/ ((module) => {

"use strict";
module.exports = require("next/dist/compiled/next-server/app-page.runtime.dev.js");

/***/ }),

/***/ "next/dist/compiled/next-server/app-route.runtime.dev.js":
/*!**************************************************************************!*\
  !*** external "next/dist/compiled/next-server/app-route.runtime.dev.js" ***!
  \**************************************************************************/
/***/ ((module) => {

"use strict";
module.exports = require("next/dist/compiled/next-server/app-route.runtime.dev.js");

/***/ }),

/***/ "next/dist/shared/lib/no-fallback-error.external":
/*!******************************************************************!*\
  !*** external "next/dist/shared/lib/no-fallback-error.external" ***!
  \******************************************************************/
/***/ ((module) => {

"use strict";
module.exports = require("next/dist/shared/lib/no-fallback-error.external");

/***/ }),

/***/ "next/dist/shared/lib/router/utils/app-paths":
/*!**************************************************************!*\
  !*** external "next/dist/shared/lib/router/utils/app-paths" ***!
  \**************************************************************/
/***/ ((module) => {

"use strict";
module.exports = require("next/dist/shared/lib/router/utils/app-paths");

/***/ }),

/***/ "punycode":
/*!***************************!*\
  !*** external "punycode" ***!
  \***************************/
/***/ ((module) => {

"use strict";
module.exports = require("punycode");

/***/ }),

/***/ "stream":
/*!*************************!*\
  !*** external "stream" ***!
  \*************************/
/***/ ((module) => {

"use strict";
module.exports = require("stream");

/***/ }),

/***/ "url":
/*!**********************!*\
  !*** external "url" ***!
  \**********************/
/***/ ((module) => {

"use strict";
module.exports = require("url");

/***/ }),

/***/ "zlib":
/*!***********************!*\
  !*** external "zlib" ***!
  \***********************/
/***/ ((module) => {

"use strict";
module.exports = require("zlib");

/***/ })

};
;

// load runtime
var __webpack_require__ = require("../../../../webpack-runtime.js");
__webpack_require__.C(exports);
var __webpack_exec__ = (moduleId) => (__webpack_require__(__webpack_require__.s = moduleId))
var __webpack_exports__ = __webpack_require__.X(0, ["vendor-chunks/@supabase","vendor-chunks/next","vendor-chunks/tr46","vendor-chunks/whatwg-url","vendor-chunks/webidl-conversions"], () => (__webpack_exec__("(rsc)/./node_modules/next/dist/build/webpack/loaders/next-app-loader/index.js?name=app%2Fapi%2Fcreate%2Fschedule-actions%2Froute&page=%2Fapi%2Fcreate%2Fschedule-actions%2Froute&appPaths=&pagePath=private-next-app-dir%2Fapi%2Fcreate%2Fschedule-actions%2Froute.ts&appDir=%2FUsers%2Falex%2Fregretless-3%2Fbackend%2Fapp&pageExtensions=tsx&pageExtensions=ts&pageExtensions=jsx&pageExtensions=js&rootDir=%2FUsers%2Falex%2Fregretless-3%2Fbackend&isDev=true&tsconfigPath=tsconfig.json&basePath=&assetPrefix=&nextConfigOutput=&preferredRegion=&middlewareConfig=e30%3D&isGlobalNotFoundEnabled=!")));
module.exports = __webpack_exports__;

})();