import type { Dream, Area, Action, ActionOccurrence } from '../../database/types'

// Configuration constants
const TARGET_PER_WEEK = 3
const REST_DAYS = new Set([0]) // Sunday = 0
const GLOBAL_DAILY_CAP = 5
const PER_DREAM_CAP_DEFAULT = 1
const PER_DREAM_CAP_MAX = 3
const MIN_GAP_DAYS_BETWEEN_SEEDS = 1

// Types for scheduling
interface SchedulingContext {
  user_id: string
  timezone: string
}

interface SchedulingResult {
  success: boolean
  occurrences: ActionOccurrence[]
  errors: string[]
  warnings: string[]
  auto_compacted?: boolean
  too_tight?: boolean
  recommended_end?: string
}

interface CapacityTracker {
  global_remaining: Map<string, number> // date -> remaining slots
  per_dream_remaining: Map<string, Map<string, number>> // date -> dream_id -> remaining slots
}

interface ScheduledPlacement {
  action_id: string
  dream_id: string
  area_id: string
  occurrence_no: number
  planned_due_on: string
  due_on: string
  is_repeat: boolean
  is_fixed: boolean // true for repeats that can't be moved
}

interface DreamSchedulingData {
  dream: Dream
  areas: Area[]
  actions: Action[]
  existing_occurrences: ActionOccurrence[]
}

/**
 * Main scheduling function that creates action occurrences for a dream
 */
export async function scheduleDreamActions(
  context: SchedulingContext,
  dreamData: DreamSchedulingData
): Promise<SchedulingResult> {
  const { dream, areas, actions, existing_occurrences } = dreamData
  
  console.log('🎯 Starting scheduling for dream:', dream.title)
  console.log('📊 Input data:', {
    areasCount: areas.length,
    actionsCount: actions.length,
    existingOccurrencesCount: existing_occurrences.length
  })
  
  try {
    // Step 1: Calculate scheduling window
    const window = calculateSchedulingWindow(dream, actions)
    console.log('📅 Scheduling window:', {
      start: window.start_date.toISOString().split('T')[0],
      end: window.end_date.toISOString().split('T')[0],
      autoCompacted: window.auto_compacted
    })
    
    // Step 2: Build capacity tracker
    const capacity = buildCapacityTracker(window.start_date, window.end_date)
    console.log('📊 Capacity tracker initialized:', {
      totalDays: capacity.global_remaining.size,
      sampleDay: Array.from(capacity.global_remaining.entries())[0]
    })
    
    // Step 3: Sort actions by position (area.position, action.position)
    const sortedActions = sortActionsByPosition(actions, areas)
    console.log('📋 Areas with positions:', areas.map(a => `${a.title} (area pos: ${a.position})`))
    console.log('📋 Sorted actions:', sortedActions.map(a => {
      const area = areas.find(area => area.id === a.area_id)
      return `${a.title} (area pos: ${area?.position || 'unknown'}, action pos: ${a.position})`
    }))
    
    // Step 4: Seed all actions (Step 1 of algorithm)
    const seedResults = await seedAllActions(
      context,
      dream,
      sortedActions,
      areas,
      window,
      capacity,
      existing_occurrences
    )
    
    console.log('🌱 Seed results:', {
      placementsCount: seedResults.placements.length,
      tightPendingCount: seedResults.tight_pending.length
    })
    
    // Step 5: Expand repeats (Step 2 of algorithm)
    const repeatResults = await expandRepeats(
      context,
      dream,
      sortedActions,
      window,
      capacity,
      seedResults.placements || []
    )
    
    // Step 6: Global balancing (Step 3 of algorithm)
    const balancedResults = await globalBalancing(
      context,
      dream,
      window,
      capacity,
      [...(seedResults.placements || []), ...(repeatResults.placements || [])]
    )
    
    // Step 7: Tight fallback escalation (Step 4 of algorithm)
    const finalResults = await tightFallbackEscalation(
      context,
      dream,
      sortedActions,
      window,
      capacity,
      balancedResults.placements || [],
      seedResults.tight_pending || []
    )
    
    // Step 8: Convert to ActionOccurrence format
    const occurrences = (finalResults.placements || []).map(placement => ({
      id: '', // Will be generated by database
      action_id: placement.action_id,
      area_id: placement.area_id,
      occurrence_no: placement.occurrence_no,
      planned_due_on: placement.planned_due_on,
      due_on: placement.due_on,
      defer_count: 0,
      note: undefined,
      completed_at: undefined,
      ai_rating: undefined,
      ai_feedback: undefined,
      created_at: new Date().toISOString(),
      updated_at: new Date().toISOString()
    }))
    
    console.log('✅ Scheduling completed:', {
      totalOccurrences: occurrences.length,
      autoCompacted: window.auto_compacted,
      tooTight: finalResults.too_tight,
      warnings: finalResults.warnings.length
    })
    
    return {
      success: true,
      occurrences,
      errors: [],
      warnings: finalResults.warnings,
      auto_compacted: window.auto_compacted,
      too_tight: finalResults.too_tight,
      recommended_end: window.recommended_end
    }
    
  } catch (error) {
    console.error('❌ Scheduling error:', error)
    return {
      success: false,
      occurrences: [],
      errors: [error instanceof Error ? error.message : 'Unknown scheduling error'],
      warnings: []
    }
  }
}

/**
 * Calculate the scheduling window for a dream
 */
function calculateSchedulingWindow(dream: Dream, actions: Action[]) {
  const startDate = new Date(dream.start_date)
  const endDate = dream.end_date ? new Date(dream.end_date) : null
  
  // Count seedable actions (one-offs + first occurrence of each repeater)
  const seedableActions = actions.filter(action => 
    action.is_active && !action.deleted_at
  ).length
  
  // Calculate recommended end date
  const weeksNeeded = Math.ceil(seedableActions / TARGET_PER_WEEK)
  const recommendedEnd = new Date(startDate)
  recommendedEnd.setDate(startDate.getDate() + (weeksNeeded * 7) - 1)
  
  // Window end is the earlier of end_date or recommended_end
  const windowEnd = endDate && endDate < recommendedEnd ? endDate : recommendedEnd
  const autoCompacted = !endDate || endDate > recommendedEnd
  
  return {
    start_date: startDate,
    end_date: windowEnd,
    recommended_end: recommendedEnd.toISOString().split('T')[0],
    auto_compacted: autoCompacted
  }
}

/**
 * Build capacity tracker for the scheduling window
 */
function buildCapacityTracker(startDate: Date, endDate: Date): CapacityTracker {
  const globalRemaining = new Map<string, number>()
  const perDreamRemaining = new Map<string, Map<string, number>>()
  
  const currentDate = new Date(startDate)
  while (currentDate <= endDate) {
    const dateStr = currentDate.toISOString().split('T')[0]
    const dayOfWeek = currentDate.getDay()
    
    // Check if it's a rest day
    if (REST_DAYS.has(dayOfWeek)) {
      globalRemaining.set(dateStr, 0)
    } else {
      globalRemaining.set(dateStr, GLOBAL_DAILY_CAP)
    }
    
    perDreamRemaining.set(dateStr, new Map())
    
    currentDate.setDate(currentDate.getDate() + 1)
  }
  
  return {
    global_remaining: globalRemaining,
    per_dream_remaining: perDreamRemaining
  }
}

/**
 * Sort actions by area position, then action position
 */
function sortActionsByPosition(actions: Action[], areas: Area[]): Action[] {
  const areaPositionMap = new Map(areas.map(area => [area.id, area.position]))
  
  return actions
    .filter(action => action.is_active && !action.deleted_at)
    .sort((a, b) => {
      const aAreaPos = areaPositionMap.get(a.area_id) || 0
      const bAreaPos = areaPositionMap.get(b.area_id) || 0
      
      if (aAreaPos !== bAreaPos) {
        return aAreaPos - bAreaPos
      }
      
      return a.position - b.position
    })
}

/**
 * Step 1: Seed all actions in order
 */
async function seedAllActions(
  context: SchedulingContext,
  dream: Dream,
  sortedActions: Action[],
  areas: Area[],
  window: { start_date: Date; end_date: Date; auto_compacted: boolean },
  capacity: CapacityTracker,
  existingOccurrences: ActionOccurrence[]
): Promise<{ placements: ScheduledPlacement[]; tight_pending: string[] }> {
  const placements: ScheduledPlacement[] = []
  const tightPending: string[] = []
  
  // Get eligible workdays
  const eligibleDays = getEligibleWorkdays(window.start_date, window.end_date)
  
  console.log('📅 Eligible workdays:', {
    totalDays: eligibleDays.length,
    firstDay: eligibleDays[0]?.toISOString().split('T')[0],
    lastDay: eligibleDays[eligibleDays.length - 1]?.toISOString().split('T')[0]
  })
  
  // Calculate total occurrences needed upfront
  let totalOccurrences = 0
  const actionOccurrenceCounts = new Map<string, number>()
  
  for (const action of sortedActions) {
    let count = 1 // Default to 1 occurrence
    if (action.slice_count_target && action.slice_count_target > 1) {
      count = action.slice_count_target
    } else if (action.repeat_every_days) {
      // For habits, estimate occurrences based on window length
      const windowDays = Math.ceil((window.end_date.getTime() - window.start_date.getTime()) / (1000 * 60 * 60 * 24))
      const workDays = Math.floor(windowDays * 6 / 7) // Rough estimate excluding Sundays
      count = Math.max(1, Math.floor(workDays / action.repeat_every_days))
    }
    actionOccurrenceCounts.set(action.id, count)
    totalOccurrences += count
  }
  
  console.log(`📊 Total occurrences needed: ${totalOccurrences} across ${eligibleDays.length} workdays`)
  console.log(`📊 Average load: ${(totalOccurrences / eligibleDays.length).toFixed(2)} occurrences per day`)
  
  // Calculate target day indices for even distribution
  const targetDayIndices: number[] = []
  let occurrenceIndex = 0
  
  for (const action of sortedActions) {
    const count = actionOccurrenceCounts.get(action.id) || 1
    for (let i = 0; i < count; i++) {
      const targetIndex = Math.round((occurrenceIndex + 0.5) * (eligibleDays.length - 1) / (totalOccurrences - 1))
      targetDayIndices.push(Math.max(0, Math.min(eligibleDays.length - 1, targetIndex)))
      occurrenceIndex++
    }
  }
  
  console.log(`🎯 Target day indices: [${targetDayIndices.slice(0, 10).join(', ')}${targetDayIndices.length > 10 ? '...' : ''}]`)
  
  let currentOccurrenceIndex = 0
  
  // Group actions by area to ensure we process all actions in an area before moving to the next
  const actionsByArea = new Map<number, Action[]>()
  for (const action of sortedActions) {
    const area = areas.find(area => area.id === action.area_id)
    const areaPosition = area?.position || 0
    if (!actionsByArea.has(areaPosition)) {
      actionsByArea.set(areaPosition, [])
    }
    actionsByArea.get(areaPosition)!.push(action)
  }
  
  // Process areas in order
  const sortedAreaPositions = Array.from(actionsByArea.keys()).sort((a, b) => a - b)
  
  for (const areaPosition of sortedAreaPositions) {
    const areaActions = actionsByArea.get(areaPosition)!
    console.log(`🏗️  Processing area ${areaPosition} with ${areaActions.length} actions`)
    
    for (const action of areaActions) {
    
    // Check if this action has existing occurrences
    const existingActionOccurrences = existingOccurrences.filter(occ => occ.action_id === action.id)
    
    if (existingActionOccurrences.length > 0) {
      // Add existing occurrences to placements for capacity tracking
      for (const existingOcc of existingActionOccurrences) {
        placements.push({
          action_id: action.id,
          dream_id: dream.id,
          area_id: action.area_id,
          occurrence_no: existingOcc.occurrence_no,
          planned_due_on: existingOcc.planned_due_on,
          due_on: existingOcc.due_on,
          is_repeat: false,
          is_fixed: false
        })
      }
      continue
    }
    
    // Get the number of occurrences needed for this action
    const occurrenceCount = actionOccurrenceCounts.get(action.id) || 1
    
    if (occurrenceCount > 1) {
      console.log(`📚 Seeding ${occurrenceCount} occurrences for: "${action.title}"`)
    } else {
      console.log(`🎯 Seeding single occurrence for: "${action.title}"`)
    }
    
    // Schedule all occurrences for this action using pre-calculated target days
    for (let i = 0; i < occurrenceCount; i++) {
      if (currentOccurrenceIndex >= targetDayIndices.length) {
        console.log(`  ❌ No more target days available for "${action.title}" occurrence ${i + 1}`)
        tightPending.push(action.id)
        break
      }
      
      const targetDayIndex = targetDayIndices[currentOccurrenceIndex]
      const targetDay = eligibleDays[targetDayIndex]
      
      if (!targetDay) {
        console.log(`  ❌ Target day index ${targetDayIndex} is out of range for "${action.title}" occurrence ${i + 1}`)
        tightPending.push(action.id)
        break
      }
      
      const dateStr = targetDay.toISOString().split('T')[0]
      
      // Create placement for this occurrence
      placements.push({
        action_id: action.id,
        dream_id: dream.id,
        area_id: action.area_id,
        occurrence_no: i + 1,
        planned_due_on: dateStr,
        due_on: dateStr,
        is_repeat: false,
        is_fixed: false
      })
      
      // Update capacity (can go negative to track violations)
      const currentGlobal = capacity.global_remaining.get(dateStr) || 0
      const currentPerDream = capacity.per_dream_remaining.get(dateStr)?.get(dream.id) || 0
      
      if (currentGlobal <= 0) {
        console.log(`  ⚠️  Global capacity violation on ${dateStr}`)
      }
      if (currentPerDream <= 0) {
        console.log(`  ⚠️  Per-dream capacity violation on ${dateStr}`)
      }
      
      capacity.global_remaining.set(dateStr, currentGlobal - 1)
      
      if (!capacity.per_dream_remaining.get(dateStr)!.has(dream.id)) {
        capacity.per_dream_remaining.get(dateStr)!.set(dream.id, PER_DREAM_CAP_DEFAULT)
      }
      capacity.per_dream_remaining.get(dateStr)!.set(dream.id, currentPerDream - 1)
      
      currentOccurrenceIndex++
    }
    }
  }
  
  return { placements, tight_pending: tightPending }
}

/**
 * Step 2: Expand repeats
 */
async function expandRepeats(
  context: SchedulingContext,
  dream: Dream,
  sortedActions: Action[],
  window: { start_date: Date; end_date: Date },
  capacity: CapacityTracker,
  seedPlacements: ScheduledPlacement[]
): Promise<{ placements: ScheduledPlacement[] }> {
  const placements: ScheduledPlacement[] = []
  
  for (const action of sortedActions) {
    const seedPlacement = seedPlacements.find(p => p.action_id === action.id)
    if (!seedPlacement) continue
    
    // Only handle ongoing habits (repeat_every_days) - finite series are handled in seeding
    if (action.repeat_every_days) {
      console.log(`🔄 Creating ongoing repeats for habit: "${action.title}" (every ${action.repeat_every_days} days)`)
      
      const seedDate = new Date(seedPlacement.due_on)
      let currentDate = new Date(seedDate)
      let occurrenceNo = 2
      
      // Add repeat occurrences
      while (currentDate <= window.end_date) {
        currentDate.setDate(currentDate.getDate() + action.repeat_every_days)
        
        if (currentDate > window.end_date) break
        
        // Skip rest days
        const dayOfWeek = currentDate.getDay()
        if (REST_DAYS.has(dayOfWeek)) {
          // Roll to next non-rest day
          currentDate.setDate(currentDate.getDate() + 1)
          if (currentDate > window.end_date) break
        }
        
        const dateStr = currentDate.toISOString().split('T')[0]
        
        // Check capacity (advisory - we'll schedule even if violated)
        const globalRemaining = capacity.global_remaining.get(dateStr) || 0
        const perDreamRemaining = capacity.per_dream_remaining.get(dateStr)?.get(dream.id) || 0
        
        placements.push({
          action_id: action.id,
          dream_id: dream.id,
          area_id: action.area_id,
          occurrence_no: occurrenceNo,
          planned_due_on: dateStr,
          due_on: dateStr,
          is_repeat: true,
          is_fixed: true // Repeats are fixed and can't be moved easily
        })
        
        // Update capacity (can go negative to track violations)
        capacity.global_remaining.set(dateStr, globalRemaining - 1)
        capacity.per_dream_remaining.get(dateStr)!.set(dream.id, perDreamRemaining - 1)
        
        occurrenceNo++
      }
    }
  }
  
  return { placements }
}

/**
 * Step 3: Global balancing to enforce ≤5/day user-wide
 */
async function globalBalancing(
  context: SchedulingContext,
  dream: Dream,
  window: { start_date: Date; end_date: Date },
  capacity: CapacityTracker,
  allPlacements: ScheduledPlacement[]
): Promise<{ placements: ScheduledPlacement[]; warnings: string[] }> {
  const warnings: string[] = []
  const placements = [...allPlacements]
  
  // Check for days that exceed global cap
  const currentDate = new Date(window.start_date)
  while (currentDate <= window.end_date) {
    const dateStr = currentDate.toISOString().split('T')[0]
    const dayPlacements = placements.filter(p => p.due_on === dateStr)
    
    if (dayPlacements.length > GLOBAL_DAILY_CAP) {
      // Find non-repeat one-offs that can be moved
      const moveablePlacements = dayPlacements.filter(p => 
        !p.is_repeat && !p.is_fixed
      )
      
      // Sort by move priority (newest, hardest, longest)
      moveablePlacements.sort((a, b) => {
        // This is a simplified sort - in practice you'd need action details
        return b.action_id.localeCompare(a.action_id)
      })
      
      // Try to move excess placements
      const excess = dayPlacements.length - GLOBAL_DAILY_CAP
      for (let i = 0; i < Math.min(excess, moveablePlacements.length); i++) {
        const placement = moveablePlacements[i]
        const newDate = findNextAvailableDate(
          placement,
          new Date(dateStr),
          window.end_date,
          capacity,
          placements
        )
        
        if (newDate) {
          placement.due_on = newDate.toISOString().split('T')[0]
          placement.planned_due_on = newDate.toISOString().split('T')[0]
        } else {
          // If we can't find a better date, keep the original placement
          // This ensures we don't lose any scheduled actions
          warnings.push(`Could not balance global cap for ${dateStr} - keeping original placement`)
        }
      }
    }
    
    currentDate.setDate(currentDate.getDate() + 1)
  }
  
  return { placements, warnings }
}

/**
 * Step 4: Tight fallback escalation
 */
async function tightFallbackEscalation(
  context: SchedulingContext,
  dream: Dream,
  sortedActions: Action[],
  window: { start_date: Date; end_date: Date },
  capacity: CapacityTracker,
  placements: ScheduledPlacement[],
  tightPending: string[]
): Promise<{ placements: ScheduledPlacement[]; warnings: string[]; too_tight?: boolean }> {
  const warnings: string[] = []
  let tooTight = false
  
  if (tightPending.length === 0) {
    return { placements, warnings }
  }
  
  // Try escalating per-dream cap to 2/day
  const escalatedCapacity = { ...capacity }
  const currentDate = new Date(window.start_date)
  while (currentDate <= window.end_date) {
    const dateStr = currentDate.toISOString().split('T')[0]
    const perDreamMap = escalatedCapacity.per_dream_remaining.get(dateStr)
    if (perDreamMap) {
      perDreamMap.set(dream.id, 2)
    }
    currentDate.setDate(currentDate.getDate() + 1)
  }
  
  // Try to place tight pending actions
  for (const actionId of tightPending) {
    // Get the actual action from sortedActions
    const action = sortedActions.find(a => a.id === actionId)
    if (!action) {
      warnings.push(`Action ${actionId} not found in context`)
      continue
    }
    
    const placement = findFeasiblePlacement(
      action,
      dream.id,
      new Date(window.start_date),
      window.end_date,
      escalatedCapacity,
      getEligibleWorkdays(window.start_date, window.end_date)
    )
    
    if (placement) {
      placements.push(placement)
      warnings.push(`Escalated per-dream cap to 2/day for ${dream.title}`)
    } else {
      // Try 3/day as last resort
      const maxCapacity = { ...escalatedCapacity }
      const currentDate = new Date(window.start_date)
      while (currentDate <= window.end_date) {
        const dateStr = currentDate.toISOString().split('T')[0]
        const perDreamMap = maxCapacity.per_dream_remaining.get(dateStr)
        if (perDreamMap) {
          perDreamMap.set(dream.id, PER_DREAM_CAP_MAX)
        }
        currentDate.setDate(currentDate.getDate() + 1)
      }
      
      const maxPlacement = findFeasiblePlacement(
        action,
        dream.id,
        new Date(window.start_date),
        window.end_date,
        maxCapacity,
        getEligibleWorkdays(window.start_date, window.end_date)
      )
      
      if (maxPlacement) {
        placements.push(maxPlacement)
        warnings.push(`Escalated per-dream cap to 3/day for ${dream.title}`)
      } else {
        tooTight = true
        warnings.push(`Cannot fit all actions for ${dream.title} within window and caps`)
      }
    }
  }
  
  return { placements, warnings, too_tight: tooTight }
}

/**
 * Helper function to get eligible workdays (excluding rest days)
 */
function getEligibleWorkdays(startDate: Date, endDate: Date): Date[] {
  const workdays: Date[] = []
  const currentDate = new Date(startDate)
  
  while (currentDate <= endDate) {
    const dayOfWeek = currentDate.getDay()
    if (!REST_DAYS.has(dayOfWeek)) {
      workdays.push(new Date(currentDate))
    }
    currentDate.setDate(currentDate.getDate() + 1)
  }
  
  return workdays
}

/**
 * Helper function to find feasible placement for an action
 */
function findFeasiblePlacement(
  action: Action,
  dreamId: string,
  minDate: Date,
  maxDate: Date,
  capacity: CapacityTracker,
  eligibleDays: Date[]
): ScheduledPlacement | null {
  console.log(`🔍 Finding placement for "${action.title}" (min: ${minDate.toISOString().split('T')[0]}, max: ${maxDate.toISOString().split('T')[0]})`)
  
  // First pass: Try to find a placement that respects capacity constraints
  for (const day of eligibleDays) {
    if (day < minDate) continue
    if (day > maxDate) break
    
    const dateStr = day.toISOString().split('T')[0]
    const globalRemaining = capacity.global_remaining.get(dateStr) || 0
    const perDreamRemaining = capacity.per_dream_remaining.get(dateStr)?.get(dreamId) || 0
    
    console.log(`  📅 ${dateStr}: global=${globalRemaining}, perDream=${perDreamRemaining}`)
    
    if (globalRemaining > 0 && perDreamRemaining > 0) {
      console.log(`  ✅ Found capacity-respecting placement on ${dateStr}`)
      return {
        action_id: action.id,
        dream_id: dreamId,
        area_id: action.area_id,
        occurrence_no: 1,
        planned_due_on: dateStr,
        due_on: dateStr,
        is_repeat: false,
        is_fixed: false
      }
    }
  }
  
  // Second pass: If no capacity-respecting placement found, find the earliest possible date
  // This ensures we ALWAYS schedule the action, even if it breaks capacity rules
  for (const day of eligibleDays) {
    if (day < minDate) continue
    if (day > maxDate) break
    
    const dateStr = day.toISOString().split('T')[0]
    console.log(`  ⚠️  Using capacity-breaking placement on ${dateStr} (advisory constraint violated)`)
    
    return {
      action_id: action.id,
      dream_id: dreamId,
      area_id: action.area_id,
      occurrence_no: 1,
      planned_due_on: dateStr,
      due_on: dateStr,
      is_repeat: false,
      is_fixed: false
    }
  }
  
  console.log(`  ❌ No placement possible within date range for "${action.title}"`)
  return null
}

/**
 * Helper function to find next available date for balancing
 */
function findNextAvailableDate(
  placement: ScheduledPlacement,
  startDate: Date,
  maxDate: Date,
  capacity: CapacityTracker,
  allPlacements: ScheduledPlacement[]
): Date | null {
  const currentDate = new Date(startDate)
  currentDate.setDate(currentDate.getDate() + 1) // Start from next day
  
  // First pass: Try to find a date that respects capacity constraints
  while (currentDate <= maxDate) {
    const dateStr = currentDate.toISOString().split('T')[0]
    const dayOfWeek = currentDate.getDay()
    
    // Skip rest days
    if (REST_DAYS.has(dayOfWeek)) {
      currentDate.setDate(currentDate.getDate() + 1)
      continue
    }
    
    const globalRemaining = capacity.global_remaining.get(dateStr) || 0
    const perDreamRemaining = capacity.per_dream_remaining.get(dateStr)?.get(placement.dream_id) || 0
    
    if (globalRemaining > 0 && perDreamRemaining > 0) {
      return currentDate
    }
    
    currentDate.setDate(currentDate.getDate() + 1)
  }
  
  // Second pass: If no capacity-respecting date found, find the earliest workday
  // This ensures we ALWAYS find a date, even if it violates capacity rules
  currentDate.setTime(startDate.getTime())
  currentDate.setDate(currentDate.getDate() + 1)
  
  while (currentDate <= maxDate) {
    const dayOfWeek = currentDate.getDay()
    
    // Skip rest days
    if (REST_DAYS.has(dayOfWeek)) {
      currentDate.setDate(currentDate.getDate() + 1)
      continue
    }
    
    // Return the first available workday (capacity violations are acceptable)
    return currentDate
  }
  
  return null
}
