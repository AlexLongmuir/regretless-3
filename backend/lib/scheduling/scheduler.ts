import type { Dream, Area, Action, ActionOccurrence } from '../../database/types'

// Configuration constants
const TARGET_PER_WEEK = 3
const REST_DAYS = new Set([0]) // Sunday = 0
const GLOBAL_DAILY_CAP = 5
const PER_DREAM_CAP_DEFAULT = 1
const PER_DREAM_CAP_MAX = 3
const MIN_GAP_DAYS_BETWEEN_SEEDS = 1
const DEFAULT_DAILY_TIME_MINUTES = 30 // Default if no time commitment specified

// Types for scheduling
interface SchedulingContext {
  user_id: string
  timezone: string
}

interface SchedulingResult {
  success: boolean
  occurrences: ActionOccurrence[]
  errors: string[]
  warnings: string[]
  auto_compacted?: boolean
  too_tight?: boolean
  recommended_end?: string
}

interface CapacityTracker {
  global_remaining: Map<string, number> // date -> remaining slots
  per_dream_remaining: Map<string, Map<string, number>> // date -> dream_id -> remaining slots
}

interface ScheduledPlacement {
  action_id: string
  dream_id: string
  area_id: string
  occurrence_no: number
  planned_due_on: string
  due_on: string
  is_repeat: boolean
  is_fixed: boolean // true for repeats that can't be moved
}

interface DreamSchedulingData {
  dream: Dream
  areas: Area[]
  actions: Action[]
  existing_occurrences: ActionOccurrence[]
}

/**
 * Main scheduling function that creates action occurrences for a dream
 */
export async function scheduleDreamActions(
  context: SchedulingContext,
  dreamData: DreamSchedulingData
): Promise<SchedulingResult> {
  const { dream, areas, actions, existing_occurrences } = dreamData
  
  console.log('üéØ Starting scheduling for dream:', dream.title)
  console.log('üìä Input data:', {
    areasCount: areas.length,
    actionsCount: actions.length,
    existingOccurrencesCount: existing_occurrences.length
  })
  
  try {
    // Step 1: Calculate scheduling window
    const window = calculateSchedulingWindow(dream, actions)
    console.log('üìÖ Scheduling window:', {
      start: window.start_date.toISOString().split('T')[0],
      end: window.end_date.toISOString().split('T')[0],
      autoCompacted: window.auto_compacted
    })
    
    // Step 2: Build capacity tracker
    const capacity = buildCapacityTracker(window.start_date, window.end_date, dream.time_commitment)
    console.log('üìä Capacity tracker initialized:', {
      totalDays: capacity.global_remaining.size,
      sampleDay: Array.from(capacity.global_remaining.entries())[0]
    })
    
    // Step 3: Sort actions by position (area.position, action.position)
    const sortedActions = sortActionsByPosition(actions, areas)
    console.log('üìã Areas with positions:', areas.map(a => `${a.title} (area pos: ${a.position})`))
    console.log('üìã Sorted actions:', sortedActions.map(a => {
      const area = areas.find(area => area.id === a.area_id)
      return `${a.title} (area pos: ${area?.position || 'unknown'}, action pos: ${a.position})`
    }))
    
    // Step 4: Seed all actions (Step 1 of algorithm)
    const seedResults = await seedAllActions(
      context,
      dream,
      sortedActions,
      areas,
      window,
      capacity,
      existing_occurrences
    )
    
    console.log('üå± Seed results:', {
      placementsCount: seedResults.placements.length,
      tightPendingCount: seedResults.tight_pending.length
    })
    
    // Step 5: Expand repeats (Step 2 of algorithm)
    const repeatResults = await expandRepeats(
      context,
      dream,
      sortedActions,
      window,
      capacity,
      seedResults.placements || []
    )
    
    // Step 6: Global balancing (Step 3 of algorithm)
    const balancedResults = await globalBalancing(
      context,
      dream,
      window,
      capacity,
      [...(seedResults.placements || []), ...(repeatResults.placements || [])],
      sortedActions
    )
    
    // Step 7: Tight fallback escalation (Step 4 of algorithm)
    const finalResults = await tightFallbackEscalation(
      context,
      dream,
      sortedActions,
      window,
      capacity,
      balancedResults.placements || [],
      seedResults.tight_pending || []
    )
    
    // Step 8: Convert to ActionOccurrence format
    const occurrences = (finalResults.placements || []).map(placement => ({
      id: '', // Will be generated by database
      action_id: placement.action_id,
      area_id: placement.area_id,
      occurrence_no: placement.occurrence_no,
      planned_due_on: placement.planned_due_on,
      due_on: placement.due_on,
      defer_count: 0,
      note: undefined,
      completed_at: undefined,
      ai_rating: undefined,
      ai_feedback: undefined,
      created_at: new Date().toISOString(),
      updated_at: new Date().toISOString()
    }))
    
    console.log('‚úÖ Scheduling completed:', {
      totalOccurrences: occurrences.length,
      autoCompacted: window.auto_compacted,
      tooTight: finalResults.too_tight,
      warnings: finalResults.warnings.length
    })
    
    return {
      success: true,
      occurrences,
      errors: [],
      warnings: finalResults.warnings,
      auto_compacted: window.auto_compacted,
      too_tight: finalResults.too_tight,
      recommended_end: window.recommended_end
    }
    
  } catch (error) {
    console.error('‚ùå Scheduling error:', error)
    return {
      success: false,
      occurrences: [],
      errors: [error instanceof Error ? error.message : 'Unknown scheduling error'],
      warnings: []
    }
  }
}

/**
 * Calculate the scheduling window for a dream
 */
function calculateSchedulingWindow(dream: Dream, actions: Action[]) {
  const startDate = new Date(dream.start_date)
  const endDate = dream.end_date ? new Date(dream.end_date) : null
  
  // Count seedable actions (one-offs + first occurrence of each repeater)
  const seedableActions = actions.filter(action => 
    action.is_active && !action.deleted_at
  ).length
  
  // Calculate recommended end date based on time commitment
  const timeCommitment = dream.time_commitment
  const dailyTimeMinutes = timeCommitment 
    ? timeCommitment.hours * 60 + timeCommitment.minutes 
    : DEFAULT_DAILY_TIME_MINUTES
  
  // Calculate total time needed for all actions
  let totalTimeNeeded = 0
  for (const action of actions) {
    if (action.is_active && !action.deleted_at && action.est_minutes) {
      if (action.slice_count_target) {
        // Finite series: total time = est_minutes * slice_count_target
        totalTimeNeeded += action.est_minutes * action.slice_count_target
      } else if (action.repeat_every_days) {
        // Habit: estimate based on window length and repeat frequency
        // Respect repeat_until_date if set
        let effectiveEndDate = endDate || new Date(startDate.getTime() + 90 * 24 * 60 * 60 * 1000) // Default 90 days if no end date
        if (action.repeat_until_date) {
          const actionEnd = new Date(action.repeat_until_date)
          if (!isNaN(actionEnd.getTime()) && actionEnd < effectiveEndDate) {
            effectiveEndDate = actionEnd
          }
        }
        
        const windowDays = Math.ceil((effectiveEndDate.getTime() - startDate.getTime()) / (1000 * 60 * 60 * 24))
        const workDays = Math.floor(windowDays * 6 / 7) // Rough estimate excluding Sundays
        const occurrences = Math.max(1, Math.floor(workDays / action.repeat_every_days))
        totalTimeNeeded += action.est_minutes * occurrences
      } else {
        // One-off action
        totalTimeNeeded += action.est_minutes
      }
    }
  }
  
  // Calculate weeks needed based on time commitment
  const workDaysPerWeek = 6 // Excluding Sundays
  const weeklyTimeMinutes = dailyTimeMinutes * workDaysPerWeek
  const weeksNeeded = Math.max(1, Math.ceil(totalTimeNeeded / weeklyTimeMinutes))
  
  const recommendedEnd = new Date(startDate)
  recommendedEnd.setDate(startDate.getDate() + (weeksNeeded * 7) - 1)
  
  // Window end is the earlier of end_date or recommended_end
  const windowEnd = endDate && endDate < recommendedEnd ? endDate : recommendedEnd
  const autoCompacted = !endDate || endDate > recommendedEnd
  
  console.log('‚è∞ Time-based scheduling calculation:', {
    dailyTimeMinutes,
    totalTimeNeeded,
    weeklyTimeMinutes,
    weeksNeeded,
    recommendedEnd: recommendedEnd.toISOString().split('T')[0]
  })
  
  return {
    start_date: startDate,
    end_date: windowEnd,
    recommended_end: recommendedEnd.toISOString().split('T')[0],
    auto_compacted: autoCompacted
  }
}

/**
 * Build capacity tracker for the scheduling window
 */
function buildCapacityTracker(startDate: Date, endDate: Date, timeCommitment?: { hours: number; minutes: number }): CapacityTracker {
  const globalRemaining = new Map<string, number>()
  const perDreamRemaining = new Map<string, Map<string, number>>()
  
  // Calculate daily time budget
  const dailyTimeMinutes = timeCommitment 
    ? timeCommitment.hours * 60 + timeCommitment.minutes 
    : DEFAULT_DAILY_TIME_MINUTES
  
  // Calculate time-based capacity (estimate actions that can fit in daily time)
  // Use a conservative estimate: assume average action takes 45 minutes
  // This gives us a reasonable cap that respects time commitment
  const estimatedTimePerAction = 45 // minutes
  const timeBasedDailyCap = Math.max(1, Math.floor(dailyTimeMinutes / estimatedTimePerAction))
  
  // Use the smaller of time-based cap or global cap to respect both constraints
  const effectiveDailyCap = Math.min(timeBasedDailyCap, GLOBAL_DAILY_CAP)
  
  console.log('üìä Capacity calculation:', {
    dailyTimeMinutes,
    timeBasedDailyCap,
    effectiveDailyCap,
    globalCap: GLOBAL_DAILY_CAP
  })
  
  const currentDate = new Date(startDate)
  while (currentDate <= endDate) {
    const dateStr = currentDate.toISOString().split('T')[0]
    const dayOfWeek = currentDate.getDay()
    
    // Check if it's a rest day
    if (REST_DAYS.has(dayOfWeek)) {
      globalRemaining.set(dateStr, 0)
    } else {
      globalRemaining.set(dateStr, effectiveDailyCap)
    }
    
    perDreamRemaining.set(dateStr, new Map())
    
    currentDate.setDate(currentDate.getDate() + 1)
  }
  
  return {
    global_remaining: globalRemaining,
    per_dream_remaining: perDreamRemaining
  }
}

/**
 * Sort actions by area position, then action position
 */
function sortActionsByPosition(actions: Action[], areas: Area[]): Action[] {
  const areaPositionMap = new Map(areas.map(area => [area.id, area.position]))
  
  return actions
    .filter(action => action.is_active && !action.deleted_at)
    .sort((a, b) => {
      const aAreaPos = areaPositionMap.get(a.area_id) || 0
      const bAreaPos = areaPositionMap.get(b.area_id) || 0
      
      if (aAreaPos !== bAreaPos) {
        return aAreaPos - bAreaPos
      }
      
      return a.position - b.position
    })
}

/**
 * Step 1: Seed all actions in order
 */
async function seedAllActions(
  context: SchedulingContext,
  dream: Dream,
  sortedActions: Action[],
  areas: Area[],
  window: { start_date: Date; end_date: Date; auto_compacted: boolean },
  capacity: CapacityTracker,
  existingOccurrences: ActionOccurrence[]
): Promise<{ placements: ScheduledPlacement[]; tight_pending: string[] }> {
  const placements: ScheduledPlacement[] = []
  const tightPending: string[] = []
  
  // Compute daily time budget for oversized detection
  const dailyTimeMinutes = dream.time_commitment 
    ? dream.time_commitment.hours * 60 + dream.time_commitment.minutes 
    : DEFAULT_DAILY_TIME_MINUTES
  
  // Get eligible workdays
  const eligibleDays = getEligibleWorkdays(window.start_date, window.end_date)
  
  console.log('üìÖ Eligible workdays:', {
    totalDays: eligibleDays.length,
    firstDay: eligibleDays[0]?.toISOString().split('T')[0],
    lastDay: eligibleDays[eligibleDays.length - 1]?.toISOString().split('T')[0]
  })
  
  // Calculate total occurrences needed upfront
  let totalOccurrences = 0
  const actionOccurrenceCounts = new Map<string, number>()
  
  for (const action of sortedActions) {
    let count = 1 // Default to 1 occurrence
    if (action.repeat_every_days) {
      // For habits, only seed the FIRST occurrence. Ongoing repeats are handled in expandRepeats.
      count = 1
    } else if (action.slice_count_target && action.slice_count_target > 1) {
      count = action.slice_count_target
    }
    actionOccurrenceCounts.set(action.id, count)
    totalOccurrences += count
  }
  
  console.log(`üìä Total occurrences needed: ${totalOccurrences} across ${eligibleDays.length} workdays`)
  console.log(`üìä Average load: ${(totalOccurrences / eligibleDays.length).toFixed(2)} occurrences per day`)
  
  // Calculate target day indices for even distribution
  const targetDayIndices: number[] = []
  let occurrenceIndex = 0
  
  for (const action of sortedActions) {
    const count = actionOccurrenceCounts.get(action.id) || 1
    for (let i = 0; i < count; i++) {
      const targetIndex = Math.round((occurrenceIndex + 0.5) * (eligibleDays.length - 1) / (totalOccurrences - 1))
      targetDayIndices.push(Math.max(0, Math.min(eligibleDays.length - 1, targetIndex)))
      occurrenceIndex++
    }
  }
  
  console.log(`üéØ Target day indices: [${targetDayIndices.slice(0, 10).join(', ')}${targetDayIndices.length > 10 ? '...' : ''}]`)
  
  let currentOccurrenceIndex = 0
  
  // Group actions by area to ensure we process all actions in an area before moving to the next
  const actionsByArea = new Map<number, Action[]>()
  for (const action of sortedActions) {
    const area = areas.find(area => area.id === action.area_id)
    const areaPosition = area?.position || 0
    if (!actionsByArea.has(areaPosition)) {
      actionsByArea.set(areaPosition, [])
    }
    actionsByArea.get(areaPosition)!.push(action)
  }
  
  // Process areas in order
  const sortedAreaPositions = Array.from(actionsByArea.keys()).sort((a, b) => a - b)
  
  for (const areaPosition of sortedAreaPositions) {
    const areaActions = actionsByArea.get(areaPosition)!
    console.log(`üèóÔ∏è  Processing area ${areaPosition} with ${areaActions.length} actions`)
    
    for (const action of areaActions) {
    
    // Check if this action has existing occurrences
    const existingActionOccurrences = existingOccurrences.filter(occ => occ.action_id === action.id)
    
    if (existingActionOccurrences.length > 0) {
      // Add existing occurrences to placements for capacity tracking
      for (const existingOcc of existingActionOccurrences) {
        placements.push({
          action_id: action.id,
          dream_id: dream.id,
          area_id: action.area_id,
          occurrence_no: existingOcc.occurrence_no,
          planned_due_on: existingOcc.planned_due_on,
          due_on: existingOcc.due_on,
          is_repeat: false,
          is_fixed: false
        })
      }
      continue
    }
    
    // Get the number of occurrences needed for this action
    const occurrenceCount = actionOccurrenceCounts.get(action.id) || 1
    
    if (occurrenceCount > 1) {
      console.log(`üìö Seeding ${occurrenceCount} occurrences for: "${action.title}"`)
    } else {
      console.log(`üéØ Seeding single occurrence for: "${action.title}"`)
    }
    
    // Schedule all occurrences for this action using pre-calculated target days
    for (let i = 0; i < occurrenceCount; i++) {
      if (currentOccurrenceIndex >= targetDayIndices.length) {
        console.log(`  ‚ùå No more target days available for "${action.title}" occurrence ${i + 1}`)
        tightPending.push(action.id)
        break
      }
      
      const targetDayIndex = targetDayIndices[currentOccurrenceIndex]
      const targetDay = eligibleDays[targetDayIndex]
      
      if (!targetDay) {
        console.log(`  ‚ùå Target day index ${targetDayIndex} is out of range for "${action.title}" occurrence ${i + 1}`)
        tightPending.push(action.id)
        break
      }
      
      const dateStr = targetDay.toISOString().split('T')[0]
      
      // Create placement for this occurrence
      placements.push({
        action_id: action.id,
        dream_id: dream.id,
        area_id: action.area_id,
        occurrence_no: i + 1,
        planned_due_on: dateStr,
        due_on: dateStr,
        is_repeat: false,
        // Mark oversized actions as fixed so they are not moved by balancing
        is_fixed: (action.est_minutes || 0) > dailyTimeMinutes
      })
      
      // Update capacity (can go negative to track violations)
      const currentGlobal = capacity.global_remaining.get(dateStr) || 0
      const currentPerDream = capacity.per_dream_remaining.get(dateStr)?.get(dream.id) || 0
      
      if (currentGlobal <= 0) {
        console.log(`  ‚ö†Ô∏è  Global capacity violation on ${dateStr}`)
      }
      if (currentPerDream <= 0) {
        console.log(`  ‚ö†Ô∏è  Per-dream capacity violation on ${dateStr}`)
      }
      
      capacity.global_remaining.set(dateStr, currentGlobal - 1)
      
      if (!capacity.per_dream_remaining.get(dateStr)!.has(dream.id)) {
        capacity.per_dream_remaining.get(dateStr)!.set(dream.id, PER_DREAM_CAP_DEFAULT)
      }
      capacity.per_dream_remaining.get(dateStr)!.set(dream.id, currentPerDream - 1)
      
      currentOccurrenceIndex++
    }
    }
  }
  
  return { placements, tight_pending: tightPending }
}

/**
 * Step 2: Expand repeats
 */
async function expandRepeats(
  context: SchedulingContext,
  dream: Dream,
  sortedActions: Action[],
  window: { start_date: Date; end_date: Date },
  capacity: CapacityTracker,
  seedPlacements: ScheduledPlacement[]
): Promise<{ placements: ScheduledPlacement[] }> {
  const placements: ScheduledPlacement[] = []
  
  for (const action of sortedActions) {
    const seedPlacement = seedPlacements.find(p => p.action_id === action.id)
    if (!seedPlacement) continue
    
    // Only handle ongoing habits (repeat_every_days) - finite series are handled in seeding
    if (action.repeat_every_days) {
      console.log(`üîÑ Creating ongoing repeats for habit: "${action.title}" (every ${action.repeat_every_days} days)`)
      
      const seedDate = new Date(seedPlacement.due_on)
      let currentDate = new Date(seedDate)
      let occurrenceNo = 2
      
      // Determine effective end date for this action
      let effectiveEndDate = window.end_date
      if (action.repeat_until_date) {
        const actionEndDate = new Date(action.repeat_until_date)
        // If action end date is valid and earlier than window end date, use it
        if (!isNaN(actionEndDate.getTime()) && actionEndDate < effectiveEndDate) {
          effectiveEndDate = actionEndDate
        }
      }
      
      // Add repeat occurrences
      while (currentDate <= effectiveEndDate) {
        currentDate.setDate(currentDate.getDate() + action.repeat_every_days)
        
        if (currentDate > effectiveEndDate) break
        
        // Skip rest days
        const dayOfWeek = currentDate.getDay()
        if (REST_DAYS.has(dayOfWeek)) {
          // Roll to next non-rest day
          currentDate.setDate(currentDate.getDate() + 1)
          if (currentDate > window.end_date) break
        }
        
        const dateStr = currentDate.toISOString().split('T')[0]
        
        // Check capacity (advisory - we'll schedule even if violated)
        const globalRemaining = capacity.global_remaining.get(dateStr) || 0
        
        // Ensure per_dream_remaining has an entry for this date
        if (!capacity.per_dream_remaining.has(dateStr)) {
          capacity.per_dream_remaining.set(dateStr, new Map())
        }
        const perDreamRemaining = capacity.per_dream_remaining.get(dateStr)?.get(dream.id) || 0
        
        placements.push({
          action_id: action.id,
          dream_id: dream.id,
          area_id: action.area_id,
          occurrence_no: occurrenceNo,
          planned_due_on: dateStr,
          due_on: dateStr,
          is_repeat: true,
          is_fixed: true // Repeats are fixed and can't be moved easily
        })
        
        // Update capacity (can go negative to track violations)
        capacity.global_remaining.set(dateStr, globalRemaining - 1)
        capacity.per_dream_remaining.get(dateStr)!.set(dream.id, perDreamRemaining - 1)
        
        occurrenceNo++
      }
    }
  }
  
  return { placements }
}

/**
 * Step 3: Global balancing to enforce time-based capacity limits
 */
async function globalBalancing(
  context: SchedulingContext,
  dream: Dream,
  window: { start_date: Date; end_date: Date },
  capacity: CapacityTracker,
  allPlacements: ScheduledPlacement[],
  actions: Action[]
): Promise<{ placements: ScheduledPlacement[]; warnings: string[] }> {
  const warnings: string[] = []
  const placements = [...allPlacements]
  
  // Get time commitment for capacity calculations
  const timeCommitment = dream.time_commitment
  const dailyTimeMinutes = timeCommitment 
    ? timeCommitment.hours * 60 + timeCommitment.minutes 
    : DEFAULT_DAILY_TIME_MINUTES
  
  // Create action lookup map for time estimation
  const actionMap = new Map(actions.map(action => [action.id, action]))
  
  // Track moved placements to prevent infinite loops
  const movedPlacements = new Set<string>()
  
  // Maximum number of iterations to prevent infinite loops
  const MAX_ITERATIONS = 100
  let iteration = 0
  
  // Check for days that exceed time-based capacity
  while (iteration < MAX_ITERATIONS) {
    iteration++
    let hasChanges = false
    const currentDate = new Date(window.start_date)
    // Track target dates we've already moved to in this iteration to avoid clustering
    const usedTargetDates = new Set<string>()
    
    while (currentDate <= window.end_date) {
      const dateStr = currentDate.toISOString().split('T')[0]
      const dayPlacements = placements.filter(p => p.due_on === dateStr)
      
      // Calculate total time for this day
      let totalDayTime = 0
      for (const placement of dayPlacements) {
        const action = actionMap.get(placement.action_id)
        if (action?.est_minutes) {
          totalDayTime += action.est_minutes
        }
      }
      
      // Check if this day exceeds the time budget
          if (totalDayTime > dailyTimeMinutes) {
        console.log(`‚è∞ Day ${dateStr} exceeds time budget: ${totalDayTime}min > ${dailyTimeMinutes}min`)
        
            // Find non-repeat one-offs that can be moved (skip oversized actions marked fixed)
         const moveablePlacements = dayPlacements.filter(p => 
              !p.is_repeat && !p.is_fixed && !movedPlacements.has(p.action_id)
         )
        
        // Sort by move priority (longest actions first to maximize time savings)
        moveablePlacements.sort((a, b) => {
          const actionA = actionMap.get(a.action_id)
          const actionB = actionMap.get(b.action_id)
          const timeA = actionA?.est_minutes || 0
          const timeB = actionB?.est_minutes || 0
          return timeB - timeA // Sort by time descending
        })
        
        // Try to move actions until we're under the time budget
        let remainingTime = totalDayTime
        for (const placement of moveablePlacements) {
          if (remainingTime <= dailyTimeMinutes) break
          
          const action = actionMap.get(placement.action_id)
          if (!action?.est_minutes) continue
          
              const avoidDates = new Set<string>([
                dateStr,
                ...Array.from(usedTargetDates)
              ])
               const newDate = findNextAvailableDate(
            placement,
            new Date(dateStr),
            window.end_date,
            capacity,
            placements,
            actions,
                 dailyTimeMinutes,
                 avoidDates
          )
          
          if (newDate) {
            placement.due_on = newDate.toISOString().split('T')[0]
            placement.planned_due_on = newDate.toISOString().split('T')[0]
            remainingTime -= action.est_minutes
            movedPlacements.add(placement.action_id)
                usedTargetDates.add(placement.due_on)
            hasChanges = true
            console.log(`üìÖ Moved "${action.title}" (${action.est_minutes}min) from ${dateStr} to ${newDate.toISOString().split('T')[0]}`)
          } else {
            // If we can't find a better date, keep the original placement
            // This ensures we don't lose any scheduled actions
            warnings.push(`Could not balance time budget for ${dateStr} - keeping original placement`)
            break
          }
        }
      }
      
      currentDate.setDate(currentDate.getDate() + 1)
    }
    
    // If no changes were made in this iteration, we're done
    if (!hasChanges) {
      break
    }
    
    // Clear moved placements for next iteration
    movedPlacements.clear()
  }
  
  if (iteration >= MAX_ITERATIONS) {
    warnings.push('Maximum balancing iterations reached - some days may still exceed time budget')
  }
  
  return { placements, warnings }
}

/**
 * Step 4: Tight fallback escalation
 */
async function tightFallbackEscalation(
  context: SchedulingContext,
  dream: Dream,
  sortedActions: Action[],
  window: { start_date: Date; end_date: Date },
  capacity: CapacityTracker,
  placements: ScheduledPlacement[],
  tightPending: string[]
): Promise<{ placements: ScheduledPlacement[]; warnings: string[]; too_tight?: boolean }> {
  const warnings: string[] = []
  let tooTight = false
  
  if (tightPending.length === 0) {
    return { placements, warnings }
  }
  
  // Try escalating per-dream cap to 2/day
  const escalatedCapacity = { ...capacity }
  const currentDate = new Date(window.start_date)
  while (currentDate <= window.end_date) {
    const dateStr = currentDate.toISOString().split('T')[0]
    const perDreamMap = escalatedCapacity.per_dream_remaining.get(dateStr)
    if (perDreamMap) {
      perDreamMap.set(dream.id, 2)
    }
    currentDate.setDate(currentDate.getDate() + 1)
  }
  
  // Try to place tight pending actions
  for (const actionId of tightPending) {
    // Get the actual action from sortedActions
    const action = sortedActions.find(a => a.id === actionId)
    if (!action) {
      warnings.push(`Action ${actionId} not found in context`)
      continue
    }
    
    const placement = findFeasiblePlacement(
      action,
      dream.id,
      new Date(window.start_date),
      window.end_date,
      escalatedCapacity,
      getEligibleWorkdays(window.start_date, window.end_date)
    )
    
    if (placement) {
      placements.push(placement)
      warnings.push(`Escalated per-dream cap to 2/day for ${dream.title}`)
    } else {
      // Try 3/day as last resort
      const maxCapacity = { ...escalatedCapacity }
      const currentDate = new Date(window.start_date)
      while (currentDate <= window.end_date) {
        const dateStr = currentDate.toISOString().split('T')[0]
        const perDreamMap = maxCapacity.per_dream_remaining.get(dateStr)
        if (perDreamMap) {
          perDreamMap.set(dream.id, PER_DREAM_CAP_MAX)
        }
        currentDate.setDate(currentDate.getDate() + 1)
      }
      
      const maxPlacement = findFeasiblePlacement(
        action,
        dream.id,
        new Date(window.start_date),
        window.end_date,
        maxCapacity,
        getEligibleWorkdays(window.start_date, window.end_date)
      )
      
      if (maxPlacement) {
        placements.push(maxPlacement)
        warnings.push(`Escalated per-dream cap to 3/day for ${dream.title}`)
      } else {
        tooTight = true
        warnings.push(`Cannot fit all actions for ${dream.title} within window and caps`)
      }
    }
  }
  
  return { placements, warnings, too_tight: tooTight }
}

/**
 * Helper function to get eligible workdays (excluding rest days)
 */
function getEligibleWorkdays(startDate: Date, endDate: Date): Date[] {
  const workdays: Date[] = []
  const currentDate = new Date(startDate)
  
  while (currentDate <= endDate) {
    const dayOfWeek = currentDate.getDay()
    if (!REST_DAYS.has(dayOfWeek)) {
      workdays.push(new Date(currentDate))
    }
    currentDate.setDate(currentDate.getDate() + 1)
  }
  
  return workdays
}

/**
 * Helper function to find feasible placement for an action
 */
function findFeasiblePlacement(
  action: Action,
  dreamId: string,
  minDate: Date,
  maxDate: Date,
  capacity: CapacityTracker,
  eligibleDays: Date[]
): ScheduledPlacement | null {
  console.log(`üîç Finding placement for "${action.title}" (min: ${minDate.toISOString().split('T')[0]}, max: ${maxDate.toISOString().split('T')[0]})`)
  
  // First pass: Try to find a placement that respects capacity constraints
  for (const day of eligibleDays) {
    if (day < minDate) continue
    if (day > maxDate) break
    
    const dateStr = day.toISOString().split('T')[0]
    const globalRemaining = capacity.global_remaining.get(dateStr) || 0
    const perDreamRemaining = capacity.per_dream_remaining.get(dateStr)?.get(dreamId) || 0
    
    console.log(`  üìÖ ${dateStr}: global=${globalRemaining}, perDream=${perDreamRemaining}`)
    
    if (globalRemaining > 0 && perDreamRemaining > 0) {
      console.log(`  ‚úÖ Found capacity-respecting placement on ${dateStr}`)
      return {
        action_id: action.id,
        dream_id: dreamId,
        area_id: action.area_id,
        occurrence_no: 1,
        planned_due_on: dateStr,
        due_on: dateStr,
        is_repeat: false,
        is_fixed: false
      }
    }
  }
  
  // Second pass: If no capacity-respecting placement found, find the earliest possible date
  // This ensures we ALWAYS schedule the action, even if it breaks capacity rules
  for (const day of eligibleDays) {
    if (day < minDate) continue
    if (day > maxDate) break
    
    const dateStr = day.toISOString().split('T')[0]
    console.log(`  ‚ö†Ô∏è  Using capacity-breaking placement on ${dateStr} (advisory constraint violated)`)
    
    return {
      action_id: action.id,
      dream_id: dreamId,
      area_id: action.area_id,
      occurrence_no: 1,
      planned_due_on: dateStr,
      due_on: dateStr,
      is_repeat: false,
      is_fixed: false
    }
  }
  
  console.log(`  ‚ùå No placement possible within date range for "${action.title}"`)
  return null
}

/**
 * Helper function to find next available date for balancing
 */
function findNextAvailableDate(
  placement: ScheduledPlacement,
  startDate: Date,
  maxDate: Date,
  capacity: CapacityTracker,
  allPlacements: ScheduledPlacement[],
  actions: Action[],
  dailyTimeMinutes?: number,
  avoidDates?: Set<string>
): Date | null {
  const currentDate = new Date(startDate)
  currentDate.setDate(currentDate.getDate() + 1) // Start from next day
  
  // Create action lookup map for time estimation
  const actionMap = new Map(actions.map(action => [action.id, action]))
  const currentAction = actionMap.get(placement.action_id)
  const currentActionTime = currentAction?.est_minutes || 0
  
  // First pass: Try to find a date that respects capacity and, when reasonable, time constraints
  while (currentDate <= maxDate) {
    const dateStr = currentDate.toISOString().split('T')[0]
    const dayOfWeek = currentDate.getDay()
    
    // Skip rest days
    if (REST_DAYS.has(dayOfWeek)) {
      currentDate.setDate(currentDate.getDate() + 1)
      continue
    }
    
    const globalRemaining = capacity.global_remaining.get(dateStr) ?? 0
    const perDreamRemaining = capacity.per_dream_remaining.get(dateStr)?.get(placement.dream_id) ?? 0
    
    // Capacity is advisory: do not block placement solely due to slot counts
    // (We still prefer lower-load days in fallback)
    
    // Check time constraints if daily time budget is provided
    // If the single action itself exceeds the daily budget, allow placement (advisory constraint)
    if (dailyTimeMinutes && currentActionTime > 0 && currentActionTime <= dailyTimeMinutes) {
      const dayPlacements = allPlacements.filter(p => p.due_on === dateStr)
      let totalDayTime = 0
      for (const dayPlacement of dayPlacements) {
        const action = actionMap.get(dayPlacement.action_id)
        if (action?.est_minutes) {
          totalDayTime += action.est_minutes
        }
      }
      
      // Check if adding this action would exceed the time budget
      if (totalDayTime + currentActionTime > dailyTimeMinutes) {
        currentDate.setDate(currentDate.getDate() + 1)
        continue
      }
    }
    
    if (avoidDates && avoidDates.has(dateStr)) {
      currentDate.setDate(currentDate.getDate() + 1)
      continue
    }
    
    return currentDate
  }
  
  // Second pass: If no capacity/time-respecting date found, choose earliest among K lightest future days
  // Priority 1: Minimize number of big actions (> dailyTimeMinutes) on that day
  // Priority 2: Minimize total scheduled time on that day
  let bestDate: Date | null = null
  let bestBigCount = Number.POSITIVE_INFINITY
  let bestLoad = Number.POSITIVE_INFINITY
  const candidates: { date: Date; big: number; load: number }[] = []
  
  const scanDate = new Date(startDate)
  scanDate.setDate(scanDate.getDate() + 1)
  
  while (scanDate <= maxDate) {
    const dayOfWeek = scanDate.getDay()
    if (REST_DAYS.has(dayOfWeek)) {
      scanDate.setDate(scanDate.getDate() + 1)
      continue
    }
    const dateStr = scanDate.toISOString().split('T')[0]
    if (avoidDates && avoidDates.has(dateStr)) {
      scanDate.setDate(scanDate.getDate() + 1)
      continue
    }
    const dayPlacements = allPlacements.filter(p => p.due_on === dateStr)
    let totalDayTime = 0
    let bigCount = 0
    for (const dayPlacement of dayPlacements) {
      const action = actionMap.get(dayPlacement.action_id)
      if (!action) continue
      const mins = action.est_minutes || 0
      totalDayTime += mins
      if (dailyTimeMinutes && mins > dailyTimeMinutes) bigCount++
    }
    candidates.push({ date: new Date(scanDate), big: bigCount, load: totalDayTime })
    scanDate.setDate(scanDate.getDate() + 1)
  }
  
  if (candidates.length > 0) {
    candidates.sort((a, b) => {
      if (a.big !== b.big) return a.big - b.big
      if (a.load !== b.load) return a.load - b.load
      return a.date.getTime() - b.date.getTime()
    })
    // Pick earliest among top-K lightest (K=7) to promote distribution
    const K = Math.min(7, candidates.length)
    const choice = candidates.slice(0, K).sort((a, b) => a.date.getTime() - b.date.getTime())[0]
    return choice.date
  }
  
  return null
}
